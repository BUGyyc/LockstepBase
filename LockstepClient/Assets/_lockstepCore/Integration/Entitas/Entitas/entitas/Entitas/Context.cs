using System;
using System.Collections.Generic;
using System.Linq;
using DesperateDevs.Utils;

namespace Entitas
{

    /// A context manages the lifecycle of entities and groups.
    /// You can create and destroy entities and get groups of entities.
    /// The prefered way to create a context is to use the generated methods
    /// from the code generator, e.g. var context = new GameContext();
    public class Context<TEntity> : IContext<TEntity>, IContext where TEntity : class, IEntity
    {
        private readonly int _totalComponents;

        private readonly Stack<IComponent>[] _componentPools;

        private readonly ContextInfo _contextInfo;

        private readonly Func<IEntity, IAERC> _aercFactory;

        private readonly Func<TEntity> _entityFactory;

        private readonly HashSet<TEntity> _entities = new HashSet<TEntity>(EntityEqualityComparer<TEntity>.comparer);

        private readonly Stack<TEntity> _reusableEntities = new Stack<TEntity>();

        private readonly HashSet<TEntity> _retainedEntities = new HashSet<TEntity>(EntityEqualityComparer<TEntity>.comparer);

        private readonly Dictionary<IMatcher<TEntity>, IGroup<TEntity>> _groups = new Dictionary<IMatcher<TEntity>, IGroup<TEntity>>();

        private readonly List<IGroup<TEntity>>[] _groupsForIndex;

        private readonly ObjectPool<List<GroupChanged<TEntity>>> _groupChangedListPool;

        private readonly Dictionary<string, IEntityIndex> _entityIndices;

        private int _creationIndex;

        private TEntity[] _entitiesCache;

        private readonly EntityComponentChanged _cachedEntityChanged;

        private readonly EntityComponentReplaced _cachedComponentReplaced;

        private readonly EntityEvent _cachedEntityReleased;

        private readonly EntityEvent _cachedDestroyEntity;

        /// The total amount of components an entity can possibly have.
        /// This value is generated by the code generator,
        /// e.g ComponentLookup.TotalComponents.
        public int totalComponents => _totalComponents;

        /// Returns all componentPools. componentPools is used to reuse
        /// removed components.
        /// Removed components will be pushed to the componentPool.
        /// Use entity.CreateComponent(index, type) to get a new or reusable
        /// component from the componentPool.
        public Stack<IComponent>[] componentPools => _componentPools;

        /// The contextInfo contains information about the context.
        /// It's used to provide better error messages.
        public ContextInfo contextInfo => _contextInfo;

        /// Returns the number of entities in the context.
        public int count => _entities.Count;

        /// Returns the number of entities in the internal ObjectPool
        /// for entities which can be reused.
        public int reusableEntitiesCount => _reusableEntities.Count;

        /// Returns the number of entities that are currently retained by
        /// other objects (e.g. Group, Collector, ReactiveSystem).
        public int retainedEntitiesCount => _retainedEntities.Count;

        /// Occurs when an entity gets created.
        public event ContextEntityChanged OnEntityCreated;

        /// Occurs when an entity will be destroyed.
        public event ContextEntityChanged OnEntityWillBeDestroyed;

        /// Occurs when an entity got destroyed.
        public event ContextEntityChanged OnEntityDestroyed;

        /// Occurs when a group gets created for the first time.
        public event ContextGroupChanged OnGroupCreated;

        /// The prefered way to create a context is to use the generated methods
        /// from the code generator, e.g. var context = new GameContext();
        public Context(int totalComponents, Func<TEntity> entityFactory)
            : this(totalComponents, 0, (ContextInfo)null, (Func<IEntity, IAERC>)null, entityFactory)
        {
        }

        /// The prefered way to create a context is to use the generated methods
        /// from the code generator, e.g. var context = new GameContext();
        public Context(int totalComponents, int startCreationIndex, ContextInfo contextInfo, Func<IEntity, IAERC> aercFactory, Func<TEntity> entityFactory)
        {
            _totalComponents = totalComponents;
            _creationIndex = startCreationIndex;
            if (contextInfo != null)
            {
                _contextInfo = contextInfo;
                if (contextInfo.componentNames.Length != totalComponents)
                {
                    throw new ContextInfoException(this, contextInfo);
                }
            }
            else
            {
                _contextInfo = createDefaultContextInfo();
            }
            _aercFactory = aercFactory ?? ((Func<IEntity, IAERC>)((IEntity entity) => new SafeAERC(entity)));
            _entityFactory = entityFactory;
            _groupsForIndex = new List<IGroup<TEntity>>[totalComponents];
            _componentPools = new Stack<IComponent>[totalComponents];
            _entityIndices = new Dictionary<string, IEntityIndex>();
            _groupChangedListPool = (ObjectPool<List<GroupChanged<TEntity>>>)(object)new ObjectPool<List<GroupChanged<List<GroupChanged<TEntity>>>>>((Func<List<GroupChanged<List<GroupChanged<TEntity>>>>>)(object)(Func<List<GroupChanged<TEntity>>>)(() => new List<GroupChanged<TEntity>>()), (Action<List<GroupChanged<List<GroupChanged<TEntity>>>>>)(object)(Action<List<GroupChanged<TEntity>>>)delegate (List<GroupChanged<TEntity>> list)
            {
                list.Clear();
            });
            _cachedEntityChanged = updateGroupsComponentAddedOrRemoved;
            _cachedComponentReplaced = updateGroupsComponentReplaced;
            _cachedEntityReleased = onEntityReleased;
            _cachedDestroyEntity = onDestroyEntity;
        }

        private ContextInfo createDefaultContextInfo()
        {
            string[] array = new string[_totalComponents];
            for (int i = 0; i < array.Length; i++)
            {
                array[i] = "Index " + i;
            }
            return new ContextInfo("Unnamed Context", array, null);
        }

        /// Creates a new entity or gets a reusable entity from the
        /// internal ObjectPool for entities.
        public TEntity CreateEntity()
        {
            TEntity val;
            if (_reusableEntities.Count > 0)
            {
                val = _reusableEntities.Pop();
                val.Reactivate(_creationIndex++);
            }
            else
            {
                val = _entityFactory();
                val.Initialize(_creationIndex++, _totalComponents, _componentPools, _contextInfo, _aercFactory(val));
            }
            _entities.Add(val);
            val.Retain(this);
            _entitiesCache = null;
            val.OnComponentAdded += _cachedEntityChanged;
            val.OnComponentRemoved += _cachedEntityChanged;
            val.OnComponentReplaced += _cachedComponentReplaced;
            val.OnEntityReleased += _cachedEntityReleased;
            val.OnDestroyEntity += _cachedDestroyEntity;
            if (this.OnEntityCreated != null)
            {
                this.OnEntityCreated(this, val);
            }
            return val;
        }

        /// Destroys all entities in the context.
        /// Throws an exception if there are still retained entities.
        public void DestroyAllEntities()
        {
            TEntity[] entities = GetEntities();
            for (int i = 0; i < entities.Length; i++)
            {
                entities[i].Destroy();
            }
            _entities.Clear();
            if (_retainedEntities.Count != 0)
            {
                IEntity[] entities2 = _retainedEntities.ToArray();
                throw new ContextStillHasRetainedEntitiesException(this, entities2);
            }
        }

        /// Determines whether the context has the specified entity.
        public bool HasEntity(TEntity entity)
        {
            return _entities.Contains(entity);
        }

        /// Returns all entities which are currently in the context.
        public TEntity[] GetEntities()
        {
            if (_entitiesCache == null)
            {
                _entitiesCache = new TEntity[_entities.Count];
                _entities.CopyTo(_entitiesCache);
            }
            return _entitiesCache;
        }

        /// Returns a group for the specified matcher.
        /// Calling context.GetGroup(matcher) with the same matcher will always
        /// return the same instance of the group.
        public IGroup<TEntity> GetGroup(IMatcher<TEntity> matcher)
        {
            if (!_groups.TryGetValue(matcher, out var value))
            {
                value = new Group<TEntity>(matcher);
                TEntity[] entities = GetEntities();
                for (int i = 0; i < entities.Length; i++)
                {
                    value.HandleEntitySilently(entities[i]);
                }
                _groups.Add(matcher, value);
                for (int j = 0; j < matcher.indices.Length; j++)
                {
                    int num = matcher.indices[j];
                    if (_groupsForIndex[num] == null)
                    {
                        _groupsForIndex[num] = new List<IGroup<TEntity>>();
                    }
                    _groupsForIndex[num].Add(value);
                }
                if (this.OnGroupCreated != null)
                {
                    this.OnGroupCreated(this, value);
                }
            }
            return value;
        }

        /// Adds the IEntityIndex for the specified name.
        /// There can only be one IEntityIndex per name.
        public void AddEntityIndex(IEntityIndex entityIndex)
        {
            if (_entityIndices.ContainsKey(entityIndex.name))
            {
                throw new ContextEntityIndexDoesAlreadyExistException(this, entityIndex.name);
            }
            _entityIndices.Add(entityIndex.name, entityIndex);
        }

        /// Gets the IEntityIndex for the specified name.
        public IEntityIndex GetEntityIndex(string name)
        {
            if (!_entityIndices.TryGetValue(name, out var value))
            {
                throw new ContextEntityIndexDoesNotExistException(this, name);
            }
            return value;
        }

        /// Resets the creationIndex back to 0.
        public void ResetCreationIndex()
        {
            _creationIndex = 0;
        }

        /// Clears the componentPool at the specified index.
        public void ClearComponentPool(int index)
        {
            _componentPools[index]?.Clear();
        }

        /// Clears all componentPools.
        public void ClearComponentPools()
        {
            for (int i = 0; i < _componentPools.Length; i++)
            {
                ClearComponentPool(i);
            }
        }

        /// Resets the context (destroys all entities and
        /// resets creationIndex back to 0).
        public void Reset()
        {
            DestroyAllEntities();
            ResetCreationIndex();
        }

        /// Removes all event handlers
        /// OnEntityCreated, OnEntityWillBeDestroyed,
        /// OnEntityDestroyed and OnGroupCreated
        public void RemoveAllEventHandlers()
        {
            this.OnEntityCreated = null;
            this.OnEntityWillBeDestroyed = null;
            this.OnEntityDestroyed = null;
            this.OnGroupCreated = null;
        }

        public override string ToString()
        {
            return _contextInfo.name;
        }

        private void updateGroupsComponentAddedOrRemoved(IEntity entity, int index, IComponent component)
        {
            List<IGroup<TEntity>> list = _groupsForIndex[index];
            if (list != null)
            {

                //List<GroupChanged<TEntity>> val = _groupChangedListPool.Get();


                List<GroupChanged<TEntity>> list2 = ((ObjectPool<List<GroupChanged<List<GroupChanged<TEntity>>>>>)(object)_groupChangedListPool).Get();
                TEntity entity2 = (TEntity)entity;
                for (int i = 0; i < list.Count; i++)
                {
                    list2.Add(list[i].HandleEntity(entity2));
                }
                for (int j = 0; j < list2.Count; j++)
                {
                    list2[j]?.Invoke(list[j], entity2, index, component);
                }
                ((ObjectPool<List<GroupChanged<List<GroupChanged<TEntity>>>>>)(object)_groupChangedListPool).Push((List<GroupChanged<List<GroupChanged<TEntity>>>>)(object)list2);
            }
        }

        private void updateGroupsComponentReplaced(IEntity entity, int index, IComponent previousComponent, IComponent newComponent)
        {
            List<IGroup<TEntity>> list = _groupsForIndex[index];
            if (list != null)
            {
                TEntity entity2 = (TEntity)entity;
                for (int i = 0; i < list.Count; i++)
                {
                    list[i].UpdateEntity(entity2, index, previousComponent, newComponent);
                }
            }
        }

        private void onEntityReleased(IEntity entity)
        {
            if (entity.isEnabled)
            {
                throw new EntityIsNotDestroyedException(string.Concat("Cannot release ", entity, "!"));
            }
            TEntity item = (TEntity)entity;
            entity.RemoveAllOnEntityReleasedHandlers();
            _retainedEntities.Remove(item);
            _reusableEntities.Push(item);
        }

        private void onDestroyEntity(IEntity entity)
        {
            TEntity val = (TEntity)entity;
            if (!_entities.Remove(val))
            {
                throw new ContextDoesNotContainEntityException(string.Concat("'", this, "' cannot destroy ", val, "!"), "This cannot happen!?!");
            }
            _entitiesCache = null;
            if (this.OnEntityWillBeDestroyed != null)
            {
                this.OnEntityWillBeDestroyed(this, val);
            }
            val.InternalDestroy();
            if (this.OnEntityDestroyed != null)
            {
                this.OnEntityDestroyed(this, val);
            }
            if (val.retainCount == 1)
            {
                val.OnEntityReleased -= _cachedEntityReleased;
                _reusableEntities.Push(val);
                val.Release(this);
                val.RemoveAllOnEntityReleasedHandlers();
            }
            else
            {
                _retainedEntities.Add(val);
                val.Release(this);
            }
        }
    }
}