// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: proto_editor.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Protocol {

  /// <summary>Holder for reflection information generated from proto_editor.proto</summary>
  public static partial class ProtoEditorReflection {

    #region Descriptor
    /// <summary>File descriptor for proto_editor.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProtoEditorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJwcm90b19lZGl0b3IucHJvdG8SCFByb3RvY29sGhJwcm90b19jb21tb24u",
            "cHJvdG8aEnByb3RvX2NvbmZpZy5wcm90byKFAwoJRWZmZWN0Q2ZnEhEKBHRp",
            "bWUYASABKAJIAIgBARIwCgliaW5kX3R5cGUYAiABKA4yGC5Qcm90b2NvbC5F",
            "ZmZlY3RCaW5kVHlwZUgBiAEBEjkKDmJpbmRfcm9vdF90eXBlGAMgASgOMhwu",
            "UHJvdG9jb2wuRWZmZWN0QmluZFJvb3RUeXBlSAKIAQESIAoTb25seV9teXNl",
            "bGZfY2FuX3NlZRgEIAEoCEgDiAEBEhsKDmNhbl9zZWVfbm9ybWFsGAUgASgN",
            "SASIAQESHgoRY2FuX3NlZV9pbnZpc2libGUYBiABKA1IBYgBARIbCg5iaW5k",
            "X2JvbmVfdHlwZRgHIAEoDUgGiAEBQgcKBV90aW1lQgwKCl9iaW5kX3R5cGVC",
            "EQoPX2JpbmRfcm9vdF90eXBlQhYKFF9vbmx5X215c2VsZl9jYW5fc2VlQhEK",
            "D19jYW5fc2VlX25vcm1hbEIUChJfY2FuX3NlZV9pbnZpc2libGVCEQoPX2Jp",
            "bmRfYm9uZV90eXBlIssDCgdBcmVhQ2ZnEhQKB2FyZWFfSWQYASABKA1IAIgB",
            "ARIrCgxjZW50ZXJfcG9pbnQYAiABKAsyEC5Qcm90b2NvbC5GbG9hdDNIAYgB",
            "ARIpCg9zaWRlX3BvaW50X2xpc3QYAyADKAsyEC5Qcm90b2NvbC5GbG9hdDMS",
            "EwoGcmFkaXVzGAQgASgCSAKIAQESNwoQYXJlYV9hY3Rpb25fdHlwZRgFIAEo",
            "DjIYLlByb3RvY29sLkFyZWFBY3Rpb25UeXBlSAOIAQESFAoHaXNfaGlkZRgG",
            "IAEoCEgEiAEBEhQKB21heF9ucGMYByABKA1IBYgBARIWCglmcmVxdWVuY3kY",
            "CCABKAJIBogBARIZCgxwb3dlcl9yYWRpdXMYCSABKAJIB4gBARIxCg9hcmVh",
            "X3N0YW5kX2xpc3QYCiADKAsyGC5Qcm90b2NvbC5BcmVhU3RhbmRQb2ludEIK",
            "CghfYXJlYV9JZEIPCg1fY2VudGVyX3BvaW50QgkKB19yYWRpdXNCEwoRX2Fy",
            "ZWFfYWN0aW9uX3R5cGVCCgoIX2lzX2hpZGVCCgoIX21heF9ucGNCDAoKX2Zy",
            "ZXF1ZW5jeUIPCg1fcG93ZXJfcmFkaXVzIpIECglMYWRkZXJDZmcSFQoIbGFk",
            "ZGVySWQYASABKA1IAIgBARImCgdwb3N0aW9uGAIgASgLMhAuUHJvdG9jb2wu",
            "RmxvYXQzSAGIAQESJwoIcm90YXRpb24YAyABKAsyEC5Qcm90b2NvbC5GbG9h",
            "dDNIAogBARInCg1zdGFydF9wb3N0aW9uGAQgAygLMhAuUHJvdG9jb2wuRmxv",
            "YXQ0EiUKC2VuZF9wb3N0aW9uGAUgAygLMhAuUHJvdG9jb2wuRmxvYXQ0EhMK",
            "BmR1cmluZxgGIAEoAkgDiAEBEjAKCGNvbGxpZGVyGAcgASgLMhkuUHJvdG9j",
            "b2wuQm94Q29sbGlkZXJEYXRhSASIAQESKgoEdHlwZRgIIAEoDjIXLlByb3Rv",
            "Y29sLkxhZGRlclN1YlR5cGVIBYgBARIWCgl1c2VfdGltZXMYCSABKAVIBogB",
            "ARIRCgluZWVkX3Byb3AYCiADKA0SGAoLaG90X2FyZWFfaWQYCyABKA1IB4gB",
            "ARIcCg9ob3RfYXJlYV9ucGNfaWQYDCABKA1ICIgBAUILCglfbGFkZGVySWRC",
            "CgoIX3Bvc3Rpb25CCwoJX3JvdGF0aW9uQgkKB19kdXJpbmdCCwoJX2NvbGxp",
            "ZGVyQgcKBV90eXBlQgwKCl91c2VfdGltZXNCDgoMX2hvdF9hcmVhX2lkQhIK",
            "EF9ob3RfYXJlYV9ucGNfaWQiPQoPUGxheWVyQ2FtZXJhQ2ZnEioKDWNhbWVy",
            "YUNmZ0xpc3QYASADKAsyEy5Qcm90b2NvbC5DYW1lcmFDZmcimAQKCUNhbWVy",
            "YUNmZxIWCgljYW1lcmFfaWQYASABKA1IAIgBARIYCgtjYW1lcmFfdHlwZRgC",
            "IAEoBUgBiAEBEhYKCXN1Yl9zdGF0ZRgDIAEoBUgCiAEBEhsKDmtleV9ib2Fy",
            "ZF90eXBlGAQgASgFSAOIAQESLwoQcmVsYXRpdmVfcG9zdGlvbhgFIAEoCzIQ",
            "LlByb3RvY29sLkZsb2F0M0gEiAEBEh8KEmNhbWVyYV9wcmVmYWJfcGF0aBgG",
            "IAEoCUgFiAEBEhAKA2ZvdhgHIAEoAkgGiAEBEh0KEG1pbl9mb2xsb3dfc3Bl",
            "ZWQYCCABKAJIB4gBARIdChBtYXhfZm9sbG93X3NwZWVkGAkgASgCSAiIAQES",
            "IAoTbWF4X2ZvbGxvd19kaXN0YW5jZRgKIAEoAkgJiAEBEisKC3NwZWVkX2N1",
            "cnZlGAsgAygLMhYuUHJvdG9jb2wuTW92ZUtleUZyYW1lQgwKCl9jYW1lcmFf",
            "aWRCDgoMX2NhbWVyYV90eXBlQgwKCl9zdWJfc3RhdGVCEQoPX2tleV9ib2Fy",
            "ZF90eXBlQhMKEV9yZWxhdGl2ZV9wb3N0aW9uQhUKE19jYW1lcmFfcHJlZmFi",
            "X3BhdGhCBgoEX2ZvdkITChFfbWluX2ZvbGxvd19zcGVlZEITChFfbWF4X2Zv",
            "bGxvd19zcGVlZEIWChRfbWF4X2ZvbGxvd19kaXN0YW5jZSLFAQoHQm9ybkNm",
            "ZxIpCgZlX3R5cGUYASABKA4yFC5Qcm90b2NvbC5FbnRpdHlUeXBlSACIAQES",
            "JgoHcG9zdGlvbhgCIAEoCzIQLlByb3RvY29sLkZsb2F0M0gBiAEBEicKCHJv",
            "dGF0aW9uGAMgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAKIAQESEQoEY2FtcBgE",
            "IAEoDUgDiAEBQgkKB19lX3R5cGVCCgoIX3Bvc3Rpb25CCwoJX3JvdGF0aW9u",
            "QgcKBV9jYW1wIvEECg1Hb2FwVGFyZ2V0Q2ZnEhsKDmFyY2hpdGVjdHVyZUlk",
            "GAEgASgNSACIAQESJgoHcG9zdGlvbhgCIAEoCzIQLlByb3RvY29sLkZsb2F0",
            "M0gBiAEBEicKCHJvdGF0aW9uGAMgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAKI",
            "AQESEgoFbnBjSWQYBCABKA1IA4gBARIlCgZucGNQb3MYBSABKAsyEC5Qcm90",
            "b2NvbC5GbG9hdDNIBIgBARImCgducGNSb3RhGAYgASgLMhAuUHJvdG9jb2wu",
            "RmxvYXQzSAWIAQESKQoGZV90eXBlGAcgASgOMhQuUHJvdG9jb2wuRW50aXR5",
            "VHlwZUgGiAEBEioKB3N1YlR5cGUYCCABKA4yFC5Qcm90b2NvbC5OcGNTdWJU",
            "eXBlSAeIAQESKgoJYm9ybl90eXBlGAkgASgOMhIuUHJvdG9jb2wuQm9yblR5",
            "cGVICIgBARIcCg9nb2FwX2Fzc2V0X25hbWUYCiABKAlICYgBARIhChRhcmNo",
            "X2dvYXBfYXNzZXRfbmFtZRgMIAEoCUgKiAEBEiwKDGxpbmVfdXBfaW5mbxgN",
            "IAMoCzIWLlByb3RvY29sLk5wY0xpbmVVcENmZ0IRCg9fYXJjaGl0ZWN0dXJl",
            "SWRCCgoIX3Bvc3Rpb25CCwoJX3JvdGF0aW9uQggKBl9ucGNJZEIJCgdfbnBj",
            "UG9zQgoKCF9ucGNSb3RhQgkKB19lX3R5cGVCCgoIX3N1YlR5cGVCDAoKX2Jv",
            "cm5fdHlwZUISChBfZ29hcF9hc3NldF9uYW1lQhcKFV9hcmNoX2dvYXBfYXNz",
            "ZXRfbmFtZSK2AQoMTnBjTGluZVVwQ2ZnEhQKB2xpbmVfSWQYASABKA1IAIgB",
            "ARImCgdwb3N0aW9uGAIgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAGIAQESJwoI",
            "cm90YXRpb24YAyABKAsyEC5Qcm90b2NvbC5GbG9hdDNIAogBARIRCgR1c2Vk",
            "GAQgASgISAOIAQFCCgoIX2xpbmVfSWRCCgoIX3Bvc3Rpb25CCwoJX3JvdGF0",
            "aW9uQgcKBV91c2VkInIKCkNsdXN0ZXJDZmcSJgoHcG9zdGlvbhgCIAEoCzIQ",
            "LlByb3RvY29sLkZsb2F0M0gAiAEBEjAKD25wY19jbHVzdGVyX2NmZxgDIAMo",
            "CzIXLlByb3RvY29sLk5wY0NsdXN0ZXJDZmdCCgoIX3Bvc3Rpb24i7QMKDU5w",
            "Y0NsdXN0ZXJDZmcSEgoFbnBjSWQYASABKA1IAIgBARIlCgZucGNQb3MYAiAB",
            "KAsyEC5Qcm90b2NvbC5GbG9hdDNIAYgBARImCgducGNSb3RhGAMgASgLMhAu",
            "UHJvdG9jb2wuRmxvYXQzSAKIAQESKgoJYm9ybl90eXBlGAQgASgOMhIuUHJv",
            "dG9jb2wuQm9yblR5cGVIA4gBARIcCg9nb2FwX2Fzc2V0X25hbWUYBSABKAlI",
            "BIgBARIpCgZlX3R5cGUYBiABKA4yFC5Qcm90b2NvbC5FbnRpdHlUeXBlSAWI",
            "AQESGgoNb3Blbl9nYXplX2Z1bhgHIAEoCEgGiAEBEhsKDmdhemVfbWF4X2Fu",
            "Z2xlGAggASgCSAeIAQESHAoPZ2F6ZV9tYXhfcmFkaXVzGAkgASgCSAiIAQES",
            "FwoKY2x1c3Rlcl9pZBgKIAEoDUgJiAEBQggKBl9ucGNJZEIJCgdfbnBjUG9z",
            "QgoKCF9ucGNSb3RhQgwKCl9ib3JuX3R5cGVCEgoQX2dvYXBfYXNzZXRfbmFt",
            "ZUIJCgdfZV90eXBlQhAKDl9vcGVuX2dhemVfZnVuQhEKD19nYXplX21heF9h",
            "bmdsZUISChBfZ2F6ZV9tYXhfcmFkaXVzQg0KC19jbHVzdGVyX2lkIqYBCgxO",
            "cGNHYXplUG9pbnQSJgoHcG9zdGlvbhgBIAEoCzIQLlByb3RvY29sLkZsb2F0",
            "M0gAiAEBEicKCHJvdGF0aW9uGAIgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAGI",
            "AQESGgoNbG9va19wcmlvcml0eRgDIAEoDUgCiAEBQgoKCF9wb3N0aW9uQgsK",
            "CV9yb3RhdGlvbkIQCg5fbG9va19wcmlvcml0eSKECgoKTnBjQm9ybkNmZxIp",
            "CgZlX3R5cGUYASABKA4yFC5Qcm90b2NvbC5FbnRpdHlUeXBlSACIAQESJgoH",
            "cG9zdGlvbhgCIAEoCzIQLlByb3RvY29sLkZsb2F0M0gBiAEBEicKCHJvdGF0",
            "aW9uGAMgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAKIAQESKgoJYm9ybl90eXBl",
            "GAQgASgOMhIuUHJvdG9jb2wuQm9yblR5cGVIA4gBARIZCgxjbHVlX2FyZWFf",
            "aWQYBSABKA1IBIgBARIXCgp3YXlfbWFwX2lkGAYgASgNSAWIAQESGgoNZm9j",
            "dXNfYXJlYV9pZBgHIAEoDUgGiAEBEhoKDWd1YXJkX2FyZWFfaWQYCCABKA1I",
            "B4gBARIdChBpc190ZW1wX2NsdWVfbnBjGAkgASgISAiIAQESFwoKbnBjX2Nm",
            "Z19pZBgKIAEoDUgJiAEBEisKCHN1Yl90eXBlGAsgASgOMhQuUHJvdG9jb2wu",
            "TnBjU3ViVHlwZUgKiAEBEhsKDndheV9wb2ludF90eXBlGAwgASgNSAuIAQES",
            "GwoObnBjX21vdmVfc3BlZWQYDSABKAJIDIgBARIZCgx1c2VfYnRfYWdlbnQY",
            "DiABKAhIDYgBARIfChJwcmVfbWluX3N0YW5kX3RpbWUYDyABKAJIDogBARIf",
            "ChJwcmVfbWF4X3N0YW5kX3RpbWUYECABKAJID4gBARIZCgxib3JuX2xpbmtf",
            "aWQYESABKA1IEIgBARIVCghncm91cF9pZBgSIAEoDUgRiAEBEhwKD2RlbGF5",
            "X2Jvcm5fdGltZRgTIAEoAkgSiAEBEhwKD2dvYXBfYXNzZXRfbmFtZRgUIAEo",
            "CUgTiAEBEh0KEGFyY2hpdGVjdHVyZV9ucGMYFSABKAhIFIgBARIhChRhcmNo",
            "aXRlY3R1cmVfYmluZF9pZBgWIAEoDUgViAEBEhoKDW9wZW5fZ2F6ZV9mdW4Y",
            "FyABKAhIFogBARIbCg5nYXplX21heF9hbmdsZRgYIAEoAkgXiAEBEhwKD2dh",
            "emVfbWF4X3JhZGl1cxgZIAEoAkgYiAEBEhcKCmNsdXN0ZXJfaWQYGiABKA1I",
            "GYgBAUIJCgdfZV90eXBlQgoKCF9wb3N0aW9uQgsKCV9yb3RhdGlvbkIMCgpf",
            "Ym9ybl90eXBlQg8KDV9jbHVlX2FyZWFfaWRCDQoLX3dheV9tYXBfaWRCEAoO",
            "X2ZvY3VzX2FyZWFfaWRCEAoOX2d1YXJkX2FyZWFfaWRCEwoRX2lzX3RlbXBf",
            "Y2x1ZV9ucGNCDQoLX25wY19jZmdfaWRCCwoJX3N1Yl90eXBlQhEKD193YXlf",
            "cG9pbnRfdHlwZUIRCg9fbnBjX21vdmVfc3BlZWRCDwoNX3VzZV9idF9hZ2Vu",
            "dEIVChNfcHJlX21pbl9zdGFuZF90aW1lQhUKE19wcmVfbWF4X3N0YW5kX3Rp",
            "bWVCDwoNX2Jvcm5fbGlua19pZEILCglfZ3JvdXBfaWRCEgoQX2RlbGF5X2Jv",
            "cm5fdGltZUISChBfZ29hcF9hc3NldF9uYW1lQhMKEV9hcmNoaXRlY3R1cmVf",
            "bnBjQhcKFV9hcmNoaXRlY3R1cmVfYmluZF9pZEIQCg5fb3Blbl9nYXplX2Z1",
            "bkIRCg9fZ2F6ZV9tYXhfYW5nbGVCEgoQX2dhemVfbWF4X3JhZGl1c0INCgtf",
            "Y2x1c3Rlcl9pZCJXCglXYXlNYXBDZmcSJQoGcG9pbnRzGAEgAygLMhUuUHJv",
            "dG9jb2wuV2F5UG9pbnRDZmcSIwoFbGluZXMYAiADKAsyFC5Qcm90b2NvbC5X",
            "YXlMaW5lQ2ZnItkDCgtXYXlQb2ludENmZxIPCgJpZBgBIAEoDUgAiAEBEhMK",
            "Bm1hcF9pZBgCIAEoDUgBiAEBEicKCHBvc2l0aW9uGAMgASgLMhAuUHJvdG9j",
            "b2wuRmxvYXQzSAKIAQESJgoHZm9yd2FyZBgEIAEoCzIQLlByb3RvY29sLkZs",
            "b2F0M0gDiAEBEhsKDm1pbl9zdGFuZF90aW1lGAUgASgCSASIAQESGwoObWF4",
            "X3N0YW5kX3RpbWUYBiABKAJIBYgBARIRCgR0eXBlGAcgASgNSAaIAQESFwoK",
            "bGluZV9jb3VudBgIIAEoDUgHiAEBEhsKDnBhc3NfbGluZV90aW1lGAkgASgC",
            "SAiIAQESGAoLbmVlZF9vZmZzZXQYCiABKAhICYgBARIZCgxvZmZzZXRfdmFs",
            "dWUYCyABKAJICogBAUIFCgNfaWRCCQoHX21hcF9pZEILCglfcG9zaXRpb25C",
            "CgoIX2ZvcndhcmRCEQoPX21pbl9zdGFuZF90aW1lQhEKD19tYXhfc3RhbmRf",
            "dGltZUIHCgVfdHlwZUINCgtfbGluZV9jb3VudEIRCg9fcGFzc19saW5lX3Rp",
            "bWVCDgoMX25lZWRfb2Zmc2V0Qg8KDV9vZmZzZXRfdmFsdWUitgEKCldheUxp",
            "bmVDZmcSKAoEaGVhZBgBIAEoCzIVLlByb3RvY29sLldheVBvaW50Q2ZnSACI",
            "AQESKAoEbGFzdBgCIAEoCzIVLlByb3RvY29sLldheVBvaW50Q2ZnSAGIAQES",
            "EQoEY29zdBgDIAEoAkgCiAEBEhcKCmlzX29uZV93YXkYBCABKAhIA4gBAUIH",
            "CgVfaGVhZEIHCgVfbGFzdEIHCgVfY29zdEINCgtfaXNfb25lX3dheSKoAwoI",
            "VGhpbmdDZmcSEwoGY2ZnX2lkGAEgASgNSACIAQESLAoKdGhpbmdfdHlwZRgC",
            "IAEoDjITLlByb3RvY29sLlRoaW5nVHlwZUgBiAEBEiYKB3Bvc3Rpb24YAyAB",
            "KAsyEC5Qcm90b2NvbC5GbG9hdDNIAogBARInCghyb3RhdGlvbhgEIAEoCzIQ",
            "LlByb3RvY29sLkZsb2F0M0gDiAEBEjAKCGNvbGxpZGVyGAUgASgLMhkuUHJv",
            "dG9jb2wuQm94Q29sbGlkZXJEYXRhSASIAQESFAoHY2x1ZV9pZBgGIAEoDUgF",
            "iAEBEioKCWJvcm5fdHlwZRgHIAEoDjISLlByb3RvY29sLkJvcm5UeXBlSAaI",
            "AQESLQoIc3ViX3R5cGUYCCABKA4yFi5Qcm90b2NvbC5UaGluZ1N1YlR5cGVI",
            "B4gBAUIJCgdfY2ZnX2lkQg0KC190aGluZ190eXBlQgoKCF9wb3N0aW9uQgsK",
            "CV9yb3RhdGlvbkILCglfY29sbGlkZXJCCgoIX2NsdWVfaWRCDAoKX2Jvcm5f",
            "dHlwZUILCglfc3ViX3R5cGUi8wEKB0Ryb3BDZmcSJgoHcG9zdGlvbhgBIAEo",
            "CzIQLlByb3RvY29sLkZsb2F0M0gAiAEBEicKCHJvdGF0aW9uGAIgASgLMhAu",
            "UHJvdG9jb2wuRmxvYXQzSAGIAQESDwoCaWQYAyABKA1IAogBARIUCgdhcmVh",
            "X2lkGAQgASgNSAOIAQESFgoOZ3JvdXBfc2VsZWN0ZWQYBSADKA0SGgoNZHJv",
            "cF9ncm91cF9pZBgGIAEoDUgEiAEBQgoKCF9wb3N0aW9uQgsKCV9yb3RhdGlv",
            "bkIFCgNfaWRCCgoIX2FyZWFfaWRCEAoOX2Ryb3BfZ3JvdXBfaWQimwIKEkFu",
            "dGlkb3RlU2NhdHRlckNmZxImCgdwb3N0aW9uGAEgASgLMhAuUHJvdG9jb2wu",
            "RmxvYXQzSACIAQESJwoIcm90YXRpb24YAiABKAsyEC5Qcm90b2NvbC5GbG9h",
            "dDNIAYgBARIqCglib3JuX3R5cGUYAyABKA4yEi5Qcm90b2NvbC5Cb3JuVHlw",
            "ZUgCiAEBEhUKCG1vZGVsX2lkGAQgASgNSAOIAQESMAoIY29sbGlkZXIYBSAB",
            "KAsyGS5Qcm90b2NvbC5Cb3hDb2xsaWRlckRhdGFIBIgBAUIKCghfcG9zdGlv",
            "bkILCglfcm90YXRpb25CDAoKX2Jvcm5fdHlwZUILCglfbW9kZWxfaWRCCwoJ",
            "X2NvbGxpZGVyIuIBChJHdWFyZFRhcmdldEFyZWFDZmcSDwoCaWQYASABKA1I",
            "AIgBARImCgdwb3N0aW9uGAIgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAGIAQES",
            "EwoGcmFkaXVzGAMgASgCSAKIAQESGgoNZ3VhcmRfYXJlYV9pZBgEIAEoDUgD",
            "iAEBEiYKB2ZvcndhcmQYBSABKAsyEC5Qcm90b2NvbC5GbG9hdDNIBIgBAUIF",
            "CgNfaWRCCgoIX3Bvc3Rpb25CCQoHX3JhZGl1c0IQCg5fZ3VhcmRfYXJlYV9p",
            "ZEIKCghfZm9yd2FyZCKaAQoMSG9va1BvaW50Q2ZnEiYKB3Bvc3Rpb24YASAB",
            "KAsyEC5Qcm90b2NvbC5GbG9hdDNIAIgBARITCgZyYWRpdXMYAiABKAJIAYgB",
            "ARIfChJyZXB1bHNpb25fZGlzdGFuY2UYAyABKAJIAogBAUIKCghfcG9zdGlv",
            "bkIJCgdfcmFkaXVzQhUKE19yZXB1bHNpb25fZGlzdGFuY2Ui0gEKDEp1bXBQ",
            "b2ludENmZxImCgdwb3N0aW9uGAEgASgLMhAuUHJvdG9jb2wuRmxvYXQzSACI",
            "AQESJwoIcm90YXRpb24YAiABKAsyEC5Qcm90b2NvbC5GbG9hdDNIAYgBARIS",
            "CgV3aWR0aBgDIAEoAkgCiAEBEhMKBmhlaWdodBgEIAEoAkgDiAEBEhEKBHR5",
            "cGUYBSABKAVIBIgBAUIKCghfcG9zdGlvbkILCglfcm90YXRpb25CCAoGX3dp",
            "ZHRoQgkKB19oZWlnaHRCBwoFX3R5cGUi7wUKC0hpZGVBcmVhQ2ZnEg8KAmlk",
            "GAEgASgNSACIAQESFgoJaW52aXNpYmxlGAIgASgISAGIAQESLgoQZW50aXR5",
            "X3R5cGVfbGlzdBgDIAMoDjIULlByb3RvY29sLkVudGl0eVR5cGUSGAoQcmVx",
            "dWlyZV90YWdfbGlzdBgEIAMoDRIWCg5ibG9ja190YWdfbGlzdBgFIAMoDRIc",
            "Cg9jYW5fc2VlX2luX2FyZWEYBiABKAhIAogBARInChp2aXNpYmxlX3ZhbF9y",
            "ZWNvdmVyeV9zcGVlZBgHIAEoAkgDiAEBEiAKE3N0YXlfaW52aXNpYmxlX3Rp",
            "bWUYCCABKAJIBIgBARIuCg9jZW50ZXJfcG9zaXRpb24YCSABKAsyEC5Qcm90",
            "b2NvbC5GbG9hdDNIBYgBARIsCg1jb2xsaWRlcl9zaXplGAogASgLMhAuUHJv",
            "dG9jb2wuRmxvYXQzSAaIAQESFQoIbW9kZWxfaWQYCyABKA1IB4gBARIzCg5o",
            "aWRlX2FyZWFfdHlwZRgMIAEoDjIWLlByb3RvY29sLkhpZGVBcmVhVHlwZUgI",
            "iAEBEhoKDW1vZGVsX29jY2x1ZGUYDSABKAhICYgBARIpCgptb2RlbF9zaXpl",
            "GA4gASgLMhAuUHJvdG9jb2wuRmxvYXQzSAqIAQESJwoIcm90YXRpb24YDyAB",
            "KAsyEC5Qcm90b2NvbC5GbG9hdDNIC4gBAUIFCgNfaWRCDAoKX2ludmlzaWJs",
            "ZUISChBfY2FuX3NlZV9pbl9hcmVhQh0KG192aXNpYmxlX3ZhbF9yZWNvdmVy",
            "eV9zcGVlZEIWChRfc3RheV9pbnZpc2libGVfdGltZUISChBfY2VudGVyX3Bv",
            "c2l0aW9uQhAKDl9jb2xsaWRlcl9zaXplQgsKCV9tb2RlbF9pZEIRCg9faGlk",
            "ZV9hcmVhX3R5cGVCEAoOX21vZGVsX29jY2x1ZGVCDQoLX21vZGVsX3NpemVC",
            "CwoJX3JvdGF0aW9uIs4HCghMZXZlbENmZxIVCghtYXBfbmFtZRgBIAEoCUgA",
            "iAEBEjEKC2JhdHRsZV9kYXRhGAIgASgLMhcuUHJvdG9jb2wuQmF0dGxlQ2Zn",
            "RGF0YUgBiAEBEiQKCWJvcm5fbGlzdBgHIAMoCzIRLlByb3RvY29sLkJvcm5D",
            "ZmcSJAoJYXJlYV9saXN0GAggAygLMhEuUHJvdG9jb2wuQXJlYUNmZxImCgp0",
            "aGluZ19saXN0GAkgAygLMhIuUHJvdG9jb2wuVGhpbmdDZmcSKAoLbGFkZGVy",
            "X2xpc3QYCiADKAsyEy5Qcm90b2NvbC5MYWRkZXJDZmcSKAoLY2FtZXJhX2xp",
            "c3QYCyADKAsyEy5Qcm90b2NvbC5DYW1lcmFDZmcSNwoRZ3VhcmRfdGFyZ2V0",
            "X2xpc3QYDSADKAsyHC5Qcm90b2NvbC5HdWFyZFRhcmdldEFyZWFDZmcSKwoN",
            "bnBjX2Jvcm5fbGlzdBgOIAMoCzIULlByb3RvY29sLk5wY0Jvcm5DZmcSLQoL",
            "d2F5X21hcF9jZmcYDyABKAsyEy5Qcm90b2NvbC5XYXlNYXBDZmdIAogBARIa",
            "Cg1uZWVkX2RlYnVnX3VpGBAgASgISAOIAQESMQoSdGhpbmdfd2F5X21hcF9s",
            "aXN0GBEgAygLMhUuUHJvdG9jb2wuVGhpbmdXYXlNYXASJAoJZHJvcF9saXN0",
            "GBMgAygLMhEuUHJvdG9jb2wuRHJvcENmZxIvCg9ob29rX3BvaW50X2xpc3QY",
            "FCADKAsyFi5Qcm90b2NvbC5Ib29rUG9pbnRDZmcSLwoPanVtcF9wb2ludF9s",
            "aXN0GBUgAygLMhYuUHJvdG9jb2wuSnVtcFBvaW50Q2ZnEjsKFWFudGlkb3Rl",
            "X3NjYXR0ZXJfbGlzdBgWIAMoCzIcLlByb3RvY29sLkFudGlkb3RlU2NhdHRl",
            "ckNmZxItCg5oaWRlX2FyZWFfbGlzdBgXIAMoCzIVLlByb3RvY29sLkhpZGVB",
            "cmVhQ2ZnEjEKEGdvYXBfdGFyZ2V0X2xpc3QYGCADKAsyFy5Qcm90b2NvbC5H",
            "b2FwVGFyZ2V0Q2ZnEjEKE2NsdXN0ZXJfdGFyZ2V0X2xpc3QYGSADKAsyFC5Q",
            "cm90b2NvbC5DbHVzdGVyQ2ZnEjMKE25wY19nYXplX3BvaW50X2xpc3QYGiAD",
            "KAsyFi5Qcm90b2NvbC5OcGNHYXplUG9pbnRCCwoJX21hcF9uYW1lQg4KDF9i",
            "YXR0bGVfZGF0YUIOCgxfd2F5X21hcF9jZmdCEAoOX25lZWRfZGVidWdfdWki",
            "ZAoLVGhpbmdXYXlNYXASDwoCaWQYASABKA1IAIgBARItCgt3YXlfbWFwX2Nm",
            "ZxgCIAEoCzITLlByb3RvY29sLldheU1hcENmZ0gBiAEBQgUKA19pZEIOCgxf",
            "d2F5X21hcF9jZmci6AEKDE1vdmVLZXlGcmFtZRIRCgR0aW1lGAEgASgCSACI",
            "AQESEgoFdmFsdWUYAiABKAJIAYgBARIXCgppbl90YW5nZW50GAMgASgCSAKI",
            "AQESGAoLb3V0X3RhbmdlbnQYBCABKAJIA4gBARIWCglpbl93ZWlnaHQYBSAB",
            "KAJIBIgBARIXCgpvdXRfd2VpZ2h0GAYgASgCSAWIAQFCBwoFX3RpbWVCCAoG",
            "X3ZhbHVlQg0KC19pbl90YW5nZW50Qg4KDF9vdXRfdGFuZ2VudEIMCgpfaW5f",
            "d2VpZ2h0Qg0KC19vdXRfd2VpZ2h0Ip0GCgpNb3ZlTW90aW9uEhMKBmxlbmd0",
            "aBgBIAEoAkgAiAEBEjAKEHBvc2l0aW9uX3hfY3VydmUYAiADKAsyFi5Qcm90",
            "b2NvbC5Nb3ZlS2V5RnJhbWUSMAoQcG9zaXRpb25fel9jdXJ2ZRgDIAMoCzIW",
            "LlByb3RvY29sLk1vdmVLZXlGcmFtZRIwChByb3RhdGlvbl94X2N1cnZlGAQg",
            "AygLMhYuUHJvdG9jb2wuTW92ZUtleUZyYW1lEjAKEHJvdGF0aW9uX3lfY3Vy",
            "dmUYBSADKAsyFi5Qcm90b2NvbC5Nb3ZlS2V5RnJhbWUSMAoQcm90YXRpb25f",
            "el9jdXJ2ZRgGIAMoCzIWLlByb3RvY29sLk1vdmVLZXlGcmFtZRIwChByb3Rh",
            "dGlvbl93X2N1cnZlGAcgAygLMhYuUHJvdG9jb2wuTW92ZUtleUZyYW1lEhgK",
            "C21vdGlvbl9uYW1lGAggASgJSAGIAQESMAoQcG9zaXRpb25feV9jdXJ2ZRgJ",
            "IAMoCzIWLlByb3RvY29sLk1vdmVLZXlGcmFtZRIaCg1ub25lX3JvdGF0aW9u",
            "GAogASgISAKIAQESHAoPbm9uZV9wb3N0aW9uX3h6GAsgASgISAOIAQESGwoO",
            "bm9uZV9wb3N0aW9uX3kYDCABKAhIBIgBARIUCgdpc19sb29wGBEgASgISAWI",
            "AQESLQoNc2NhbGVfeF9jdXJ2ZRgSIAMoCzIWLlByb3RvY29sLk1vdmVLZXlG",
            "cmFtZRItCg1zY2FsZV95X2N1cnZlGBMgAygLMhYuUHJvdG9jb2wuTW92ZUtl",
            "eUZyYW1lEi0KDXNjYWxlX3pfY3VydmUYFCADKAsyFi5Qcm90b2NvbC5Nb3Zl",
            "S2V5RnJhbWUSGAoLbW90aW9uX3R5cGUYFSABKA1IBogBAUIJCgdfbGVuZ3Ro",
            "Qg4KDF9tb3Rpb25fbmFtZUIQCg5fbm9uZV9yb3RhdGlvbkISChBfbm9uZV9w",
            "b3N0aW9uX3h6QhEKD19ub25lX3Bvc3Rpb25feUIKCghfaXNfbG9vcEIOCgxf",
            "bW90aW9uX3R5cGUi1QQKCUJsZW5kTm9kZRIXCgptb3ZlX3NwZWVkGAEgASgC",
            "SACIAQESGAoLYW5nbGVfc3BlZWQYAiABKAJIAYgBARIWCgl4X3Bvc3Rpb24Y",
            "AyABKAJIAogBARIWCgl5X3Bvc3Rpb24YBCABKAJIA4gBARInCghtb3ZlX2Rp",
            "chgFIAEoCzIQLlByb3RvY29sLkZsb2F0M0gEiAEBEhMKBmxlbmd0aBgGIAEo",
            "AkgFiAEBEhcKCmlzX2FkZHRpb24YByABKAhIBogBARIpCgZtb3Rpb24YCCAB",
            "KAsyFC5Qcm90b2NvbC5Nb3ZlTW90aW9uSAeIAQESKwoMYm91bmRfY2VudGVy",
            "GAkgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAiIAQESKQoKYm91bmRfc2l6ZRgK",
            "IAEoCzIQLlByb3RvY29sLkZsb2F0M0gJiAEBEiwKDWhlYWRfcG9zaXRpb24Y",
            "CyABKAsyEC5Qcm90b2NvbC5GbG9hdDNICogBARIsCg1oZWFkX3JvdGF0aW9u",
            "GAwgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAuIAQFCDQoLX21vdmVfc3BlZWRC",
            "DgoMX2FuZ2xlX3NwZWVkQgwKCl94X3Bvc3Rpb25CDAoKX3lfcG9zdGlvbkIL",
            "CglfbW92ZV9kaXJCCQoHX2xlbmd0aEINCgtfaXNfYWRkdGlvbkIJCgdfbW90",
            "aW9uQg8KDV9ib3VuZF9jZW50ZXJCDQoLX2JvdW5kX3NpemVCEAoOX2hlYWRf",
            "cG9zaXRpb25CEAoOX2hlYWRfcm90YXRpb24i1gEKB0JsZW5kZXISLAoKYmxl",
            "bmRfdHlwZRgBIAEoDjITLlByb3RvY29sLkJsZW5kVHlwZUgAiAEBEiYKCW5v",
            "ZGVfbGlzdBgCIAMoCzITLlByb3RvY29sLkJsZW5kTm9kZRITCgZsZW5ndGgY",
            "AyABKAJIAYgBARIRCgRuYW1lGAQgASgJSAKIAQESGQoMaXNfZml4X2FuZ2xl",
            "GAUgASgISAOIAQFCDQoLX2JsZW5kX3R5cGVCCQoHX2xlbmd0aEIHCgVfbmFt",
            "ZUIPCg1faXNfZml4X2FuZ2xlIqQCChFNb3ZlQ29udHJvbGxlckNmZxIsCg5l",
            "eHBvcnRfbW90aW9ucxgBIAMoCzIULlByb3RvY29sLk1vdmVNb3Rpb24SKgoP",
            "ZXhwb3J0X2JsZW5kZXJzGAIgAygLMhEuUHJvdG9jb2wuQmxlbmRlchIYCgt3",
            "ZWFwb25fcGF0aBgDIAEoCUgAiAEBEhcKD2JvdW5kX3BhdGhfbGlzdBgEIAMo",
            "CRIWCgloZWFkX3BhdGgYBSABKAlIAYgBARIWCgloZWFkX3NpemUYBiABKAJI",
            "AogBARIXCgptb2RlbF9wYXRoGAcgASgJSAOIAQFCDgoMX3dlYXBvbl9wYXRo",
            "QgwKCl9oZWFkX3BhdGhCDAoKX2hlYWRfc2l6ZUINCgtfbW9kZWxfcGF0aCJV",
            "CgtUaW1lbGluZUNmZxIUCgxhZGRfdGFnX2xpc3QYASADKA0SGAoQcmVxdWly",
            "ZV90YWdfbGlzdBgCIAMoDRIWCg5ibG9ja190YWdfbGlzdBgDIAMoDSKsAQoR",
            "UGxheWVyVGltZWxpbmVDZmcSSQoQdGltZWxpbmVfY2ZnX2RpYxgBIAMoCzIv",
            "LlByb3RvY29sLlBsYXllclRpbWVsaW5lQ2ZnLlRpbWVsaW5lQ2ZnRGljRW50",
            "cnkaTAoTVGltZWxpbmVDZmdEaWNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFs",
            "dWUYAiABKAsyFS5Qcm90b2NvbC5UaW1lbGluZUNmZzoCOAEiiwIKDUJhdHRs",
            "ZUNmZ0RhdGESGAoLYmF0dGxlX3R5cGUYASABKA1IAIgBARIXCgp0ZWFtX2Nv",
            "dW50GAIgASgNSAGIAQESHgoRdGVhbV9tZW1iZXJfY291bnQYAyABKA1IAogB",
            "ARIUCgdoaWRlX3VpGAQgASgISAOIAQESEAoIYWRkX3RhZ3MYBSADKAUSLwoK",
            "dHdvX3ZzX3R3bxgKIAEoCzIWLlByb3RvY29sLlR3b1ZzVHdvRGF0YUgEiAEB",
            "Qg4KDF9iYXR0bGVfdHlwZUINCgtfdGVhbV9jb3VudEIUChJfdGVhbV9tZW1i",
            "ZXJfY291bnRCCgoIX2hpZGVfdWlCDQoLX3R3b192c190d28i5AIKDFdpblBv",
            "aW50RGF0YRIVCghwb2ludF9pZBgBIAEoBUgAiAEBEhkKDHRyaWdnZXJfdHlw",
            "ZRgCIAEoBUgBiAEBEhMKBmxpbmtJZBgDIAEoBUgCiAEBEhkKDHBpY2tpbmdf",
            "dGltZRgEIAEoAkgDiAEBEhYKCXdpbl9zY29yZRgFIAEoBUgEiAEBEicKCHBv",
            "c2l0aW9uGAYgASgLMhAuUHJvdG9jb2wuRmxvYXQzSAWIAQESJwoIcm90YXRp",
            "b24YByABKAsyEC5Qcm90b2NvbC5GbG9hdDNIBogBARIXCgpkZWxheV90aW1l",
            "GAggASgCSAeIAQFCCwoJX3BvaW50X2lkQg8KDV90cmlnZ2VyX3R5cGVCCQoH",
            "X2xpbmtJZEIPCg1fcGlja2luZ190aW1lQgwKCl93aW5fc2NvcmVCCwoJX3Bv",
            "c2l0aW9uQgsKCV9yb3RhdGlvbkINCgtfZGVsYXlfdGltZSLgAQoMVHdvVnNU",
            "d29EYXRhEhgKC3JvdW5kX2NvdW50GAEgASgNSACIAQESGgoNdG90YWxfc2Vj",
            "b25kcxgCIAEoDUgBiAEBEhYKCXdpbl9zY29yZRgDIAEoDUgCiAEBEhUKCG1v",
            "ZGVsX2lkGAQgASgNSAOIAQESLgoOd2luX3BvaW50X2xpc3QYBSADKAsyFi5Q",
            "cm90b2NvbC5XaW5Qb2ludERhdGFCDgoMX3JvdW5kX2NvdW50QhAKDl90b3Rh",
            "bF9zZWNvbmRzQgwKCl93aW5fc2NvcmVCCwoJX21vZGVsX2lkIp8CCglBSU1h",
            "cERhdGESJgoHdXBfc2lkZRgBIAEoCzIQLlByb3RvY29sLkZsb2F0M0gAiAEB",
            "EigKCWRvd25fc2lkZRgCIAEoCzIQLlByb3RvY29sLkZsb2F0M0gBiAEBEhQK",
            "B2NvdW50X3gYAyABKAVIAogBARIUCgdjb3VudF95GAQgASgFSAOIAQESLAoK",
            "cG9pbnRfbGlzdBgFIAMoCzIYLlByb3RvY29sLkFJTWFwUG9pbnREYXRhEh4K",
            "EWxldmVsX2NvbmZpZ19uYW1lGAYgASgJSASIAQFCCgoIX3VwX3NpZGVCDAoK",
            "X2Rvd25fc2lkZUIKCghfY291bnRfeEIKCghfY291bnRfeUIUChJfbGV2ZWxf",
            "Y29uZmlnX25hbWUiUgoOQUlNYXBQb2ludERhdGESEwoGaGVpZ2h0GAEgASgC",
            "SACIAQESFAoHaXNfaGlkZRgCIAEoCEgBiAEBQgkKB19oZWlnaHRCCgoIX2lz",
            "X2hpZGUqTAoJQmxlbmRUeXBlEgsKB0JUX05vbmUQABIKCgZTaW1wbGUQARIJ",
            "CgVQb2xhchACEg0KCUNhcnRlc2lhbhADEgwKCFNpbXBsZTFEEARiBnByb3Rv",
            "Mw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Protocol.ProtoCommonReflection.Descriptor, global::Protocol.ProtoConfigReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Protocol.BlendType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.EffectCfg), global::Protocol.EffectCfg.Parser, new[]{ "Time", "BindType", "BindRootType", "OnlyMyselfCanSee", "CanSeeNormal", "CanSeeInvisible", "BindBoneType" }, new[]{ "Time", "BindType", "BindRootType", "OnlyMyselfCanSee", "CanSeeNormal", "CanSeeInvisible", "BindBoneType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.AreaCfg), global::Protocol.AreaCfg.Parser, new[]{ "AreaId", "CenterPoint", "SidePointList", "Radius", "AreaActionType", "IsHide", "MaxNpc", "Frequency", "PowerRadius", "AreaStandList" }, new[]{ "AreaId", "CenterPoint", "Radius", "AreaActionType", "IsHide", "MaxNpc", "Frequency", "PowerRadius" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.LadderCfg), global::Protocol.LadderCfg.Parser, new[]{ "LadderId", "Postion", "Rotation", "StartPostion", "EndPostion", "During", "Collider", "Type", "UseTimes", "NeedProp", "HotAreaId", "HotAreaNpcId" }, new[]{ "LadderId", "Postion", "Rotation", "During", "Collider", "Type", "UseTimes", "HotAreaId", "HotAreaNpcId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.PlayerCameraCfg), global::Protocol.PlayerCameraCfg.Parser, new[]{ "CameraCfgList" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.CameraCfg), global::Protocol.CameraCfg.Parser, new[]{ "CameraId", "CameraType", "SubState", "KeyBoardType", "RelativePostion", "CameraPrefabPath", "Fov", "MinFollowSpeed", "MaxFollowSpeed", "MaxFollowDistance", "SpeedCurve" }, new[]{ "CameraId", "CameraType", "SubState", "KeyBoardType", "RelativePostion", "CameraPrefabPath", "Fov", "MinFollowSpeed", "MaxFollowSpeed", "MaxFollowDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.BornCfg), global::Protocol.BornCfg.Parser, new[]{ "EType", "Postion", "Rotation", "Camp" }, new[]{ "EType", "Postion", "Rotation", "Camp" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.GoapTargetCfg), global::Protocol.GoapTargetCfg.Parser, new[]{ "ArchitectureId", "Postion", "Rotation", "NpcId", "NpcPos", "NpcRota", "EType", "SubType", "BornType", "GoapAssetName", "ArchGoapAssetName", "LineUpInfo" }, new[]{ "ArchitectureId", "Postion", "Rotation", "NpcId", "NpcPos", "NpcRota", "EType", "SubType", "BornType", "GoapAssetName", "ArchGoapAssetName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.NpcLineUpCfg), global::Protocol.NpcLineUpCfg.Parser, new[]{ "LineId", "Postion", "Rotation", "Used" }, new[]{ "LineId", "Postion", "Rotation", "Used" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.ClusterCfg), global::Protocol.ClusterCfg.Parser, new[]{ "Postion", "NpcClusterCfg" }, new[]{ "Postion" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.NpcClusterCfg), global::Protocol.NpcClusterCfg.Parser, new[]{ "NpcId", "NpcPos", "NpcRota", "BornType", "GoapAssetName", "EType", "OpenGazeFun", "GazeMaxAngle", "GazeMaxRadius", "ClusterId" }, new[]{ "NpcId", "NpcPos", "NpcRota", "BornType", "GoapAssetName", "EType", "OpenGazeFun", "GazeMaxAngle", "GazeMaxRadius", "ClusterId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.NpcGazePoint), global::Protocol.NpcGazePoint.Parser, new[]{ "Postion", "Rotation", "LookPriority" }, new[]{ "Postion", "Rotation", "LookPriority" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.NpcBornCfg), global::Protocol.NpcBornCfg.Parser, new[]{ "EType", "Postion", "Rotation", "BornType", "ClueAreaId", "WayMapId", "FocusAreaId", "GuardAreaId", "IsTempClueNpc", "NpcCfgId", "SubType", "WayPointType", "NpcMoveSpeed", "UseBtAgent", "PreMinStandTime", "PreMaxStandTime", "BornLinkId", "GroupId", "DelayBornTime", "GoapAssetName", "ArchitectureNpc", "ArchitectureBindId", "OpenGazeFun", "GazeMaxAngle", "GazeMaxRadius", "ClusterId" }, new[]{ "EType", "Postion", "Rotation", "BornType", "ClueAreaId", "WayMapId", "FocusAreaId", "GuardAreaId", "IsTempClueNpc", "NpcCfgId", "SubType", "WayPointType", "NpcMoveSpeed", "UseBtAgent", "PreMinStandTime", "PreMaxStandTime", "BornLinkId", "GroupId", "DelayBornTime", "GoapAssetName", "ArchitectureNpc", "ArchitectureBindId", "OpenGazeFun", "GazeMaxAngle", "GazeMaxRadius", "ClusterId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.WayMapCfg), global::Protocol.WayMapCfg.Parser, new[]{ "Points", "Lines" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.WayPointCfg), global::Protocol.WayPointCfg.Parser, new[]{ "Id", "MapId", "Position", "Forward", "MinStandTime", "MaxStandTime", "Type", "LineCount", "PassLineTime", "NeedOffset", "OffsetValue" }, new[]{ "Id", "MapId", "Position", "Forward", "MinStandTime", "MaxStandTime", "Type", "LineCount", "PassLineTime", "NeedOffset", "OffsetValue" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.WayLineCfg), global::Protocol.WayLineCfg.Parser, new[]{ "Head", "Last", "Cost", "IsOneWay" }, new[]{ "Head", "Last", "Cost", "IsOneWay" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.ThingCfg), global::Protocol.ThingCfg.Parser, new[]{ "CfgId", "ThingType", "Postion", "Rotation", "Collider", "ClueId", "BornType", "SubType" }, new[]{ "CfgId", "ThingType", "Postion", "Rotation", "Collider", "ClueId", "BornType", "SubType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.DropCfg), global::Protocol.DropCfg.Parser, new[]{ "Postion", "Rotation", "Id", "AreaId", "GroupSelected", "DropGroupId" }, new[]{ "Postion", "Rotation", "Id", "AreaId", "DropGroupId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.AntidoteScatterCfg), global::Protocol.AntidoteScatterCfg.Parser, new[]{ "Postion", "Rotation", "BornType", "ModelId", "Collider" }, new[]{ "Postion", "Rotation", "BornType", "ModelId", "Collider" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.GuardTargetAreaCfg), global::Protocol.GuardTargetAreaCfg.Parser, new[]{ "Id", "Postion", "Radius", "GuardAreaId", "Forward" }, new[]{ "Id", "Postion", "Radius", "GuardAreaId", "Forward" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.HookPointCfg), global::Protocol.HookPointCfg.Parser, new[]{ "Postion", "Radius", "RepulsionDistance" }, new[]{ "Postion", "Radius", "RepulsionDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.JumpPointCfg), global::Protocol.JumpPointCfg.Parser, new[]{ "Postion", "Rotation", "Width", "Height", "Type" }, new[]{ "Postion", "Rotation", "Width", "Height", "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.HideAreaCfg), global::Protocol.HideAreaCfg.Parser, new[]{ "Id", "Invisible", "EntityTypeList", "RequireTagList", "BlockTagList", "CanSeeInArea", "VisibleValRecoverySpeed", "StayInvisibleTime", "CenterPosition", "ColliderSize", "ModelId", "HideAreaType", "ModelOcclude", "ModelSize", "Rotation" }, new[]{ "Id", "Invisible", "CanSeeInArea", "VisibleValRecoverySpeed", "StayInvisibleTime", "CenterPosition", "ColliderSize", "ModelId", "HideAreaType", "ModelOcclude", "ModelSize", "Rotation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.LevelCfg), global::Protocol.LevelCfg.Parser, new[]{ "MapName", "BattleData", "BornList", "AreaList", "ThingList", "LadderList", "CameraList", "GuardTargetList", "NpcBornList", "WayMapCfg", "NeedDebugUi", "ThingWayMapList", "DropList", "HookPointList", "JumpPointList", "AntidoteScatterList", "HideAreaList", "GoapTargetList", "ClusterTargetList", "NpcGazePointList" }, new[]{ "MapName", "BattleData", "WayMapCfg", "NeedDebugUi" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.ThingWayMap), global::Protocol.ThingWayMap.Parser, new[]{ "Id", "WayMapCfg" }, new[]{ "Id", "WayMapCfg" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.MoveKeyFrame), global::Protocol.MoveKeyFrame.Parser, new[]{ "Time", "Value", "InTangent", "OutTangent", "InWeight", "OutWeight" }, new[]{ "Time", "Value", "InTangent", "OutTangent", "InWeight", "OutWeight" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.MoveMotion), global::Protocol.MoveMotion.Parser, new[]{ "Length", "PositionXCurve", "PositionZCurve", "RotationXCurve", "RotationYCurve", "RotationZCurve", "RotationWCurve", "MotionName", "PositionYCurve", "NoneRotation", "NonePostionXz", "NonePostionY", "IsLoop", "ScaleXCurve", "ScaleYCurve", "ScaleZCurve", "MotionType" }, new[]{ "Length", "MotionName", "NoneRotation", "NonePostionXz", "NonePostionY", "IsLoop", "MotionType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.BlendNode), global::Protocol.BlendNode.Parser, new[]{ "MoveSpeed", "AngleSpeed", "XPostion", "YPostion", "MoveDir", "Length", "IsAddtion", "Motion", "BoundCenter", "BoundSize", "HeadPosition", "HeadRotation" }, new[]{ "MoveSpeed", "AngleSpeed", "XPostion", "YPostion", "MoveDir", "Length", "IsAddtion", "Motion", "BoundCenter", "BoundSize", "HeadPosition", "HeadRotation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.Blender), global::Protocol.Blender.Parser, new[]{ "BlendType", "NodeList", "Length", "Name", "IsFixAngle" }, new[]{ "BlendType", "Length", "Name", "IsFixAngle" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.MoveControllerCfg), global::Protocol.MoveControllerCfg.Parser, new[]{ "ExportMotions", "ExportBlenders", "WeaponPath", "BoundPathList", "HeadPath", "HeadSize", "ModelPath" }, new[]{ "WeaponPath", "HeadPath", "HeadSize", "ModelPath" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.TimelineCfg), global::Protocol.TimelineCfg.Parser, new[]{ "AddTagList", "RequireTagList", "BlockTagList" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.PlayerTimelineCfg), global::Protocol.PlayerTimelineCfg.Parser, new[]{ "TimelineCfgDic" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.BattleCfgData), global::Protocol.BattleCfgData.Parser, new[]{ "BattleType", "TeamCount", "TeamMemberCount", "HideUi", "AddTags", "TwoVsTwo" }, new[]{ "BattleType", "TeamCount", "TeamMemberCount", "HideUi", "TwoVsTwo" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.WinPointData), global::Protocol.WinPointData.Parser, new[]{ "PointId", "TriggerType", "LinkId", "PickingTime", "WinScore", "Position", "Rotation", "DelayTime" }, new[]{ "PointId", "TriggerType", "LinkId", "PickingTime", "WinScore", "Position", "Rotation", "DelayTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.TwoVsTwoData), global::Protocol.TwoVsTwoData.Parser, new[]{ "RoundCount", "TotalSeconds", "WinScore", "ModelId", "WinPointList" }, new[]{ "RoundCount", "TotalSeconds", "WinScore", "ModelId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.AIMapData), global::Protocol.AIMapData.Parser, new[]{ "UpSide", "DownSide", "CountX", "CountY", "PointList", "LevelConfigName" }, new[]{ "UpSide", "DownSide", "CountX", "CountY", "LevelConfigName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Protocol.AIMapPointData), global::Protocol.AIMapPointData.Parser, new[]{ "Height", "IsHide" }, new[]{ "Height", "IsHide" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///混合模式，对应Unity 2D Blender
  /// </summary>
  public enum BlendType {
    [pbr::OriginalName("BT_None")] BtNone = 0,
    [pbr::OriginalName("Simple")] Simple = 1,
    [pbr::OriginalName("Polar")] Polar = 2,
    [pbr::OriginalName("Cartesian")] Cartesian = 3,
    /// <summary>
    ///1D混合器
    /// </summary>
    [pbr::OriginalName("Simple1D")] Simple1D = 4,
  }

  #endregion

  #region Messages
  public sealed partial class EffectCfg : pb::IMessage<EffectCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EffectCfg> _parser = new pb::MessageParser<EffectCfg>(() => new EffectCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EffectCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EffectCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EffectCfg(EffectCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      time_ = other.time_;
      bindType_ = other.bindType_;
      bindRootType_ = other.bindRootType_;
      onlyMyselfCanSee_ = other.onlyMyselfCanSee_;
      canSeeNormal_ = other.canSeeNormal_;
      canSeeInvisible_ = other.canSeeInvisible_;
      bindBoneType_ = other.bindBoneType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EffectCfg Clone() {
      return new EffectCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private float time_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { if ((_hasBits0 & 1) != 0) { return time_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        time_ = value;
      }
    }
    /// <summary>Gets whether the "time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTimeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTime() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "bind_type" field.</summary>
    public const int BindTypeFieldNumber = 2;
    private global::Protocol.EffectBindType bindType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EffectBindType BindType {
      get { if ((_hasBits0 & 2) != 0) { return bindType_; } else { return global::Protocol.EffectBindType.BindWorldPosition; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        bindType_ = value;
      }
    }
    /// <summary>Gets whether the "bind_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBindType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "bind_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBindTypeDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "bind_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBindType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "bind_root_type" field.</summary>
    public const int BindRootTypeFieldNumber = 3;
    private global::Protocol.EffectBindRootType bindRootType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EffectBindRootType BindRootType {
      get { if ((_hasBits0 & 4) != 0) { return bindRootType_; } else { return global::Protocol.EffectBindRootType.BindRootLogic; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        bindRootType_ = value;
      }
    }
    /// <summary>Gets whether the "bind_root_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBindRootType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "bind_root_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBindRootTypeDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "bind_root_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBindRootType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "only_myself_can_see" field.</summary>
    public const int OnlyMyselfCanSeeFieldNumber = 4;
    private bool onlyMyselfCanSee_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OnlyMyselfCanSee {
      get { if ((_hasBits0 & 8) != 0) { return onlyMyselfCanSee_; } else { return false; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        onlyMyselfCanSee_ = value;
      }
    }
    /// <summary>Gets whether the "only_myself_can_see" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOnlyMyselfCanSee {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "only_myself_can_see" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOnlyMyselfCanSeeDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "only_myself_can_see" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOnlyMyselfCanSee() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "can_see_normal" field.</summary>
    public const int CanSeeNormalFieldNumber = 5;
    private uint canSeeNormal_;
    /// <summary>
    ///通用状态下的可见性
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CanSeeNormal {
      get { if ((_hasBits0 & 16) != 0) { return canSeeNormal_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 16;
        canSeeNormal_ = value;
      }
    }
    /// <summary>Gets whether the "can_see_normal" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanSeeNormal {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "can_see_normal" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCanSeeNormalDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "can_see_normal" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanSeeNormal() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "can_see_invisible" field.</summary>
    public const int CanSeeInvisibleFieldNumber = 6;
    private uint canSeeInvisible_;
    /// <summary>
    ///隐身状态下的可见性
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CanSeeInvisible {
      get { if ((_hasBits0 & 32) != 0) { return canSeeInvisible_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 32;
        canSeeInvisible_ = value;
      }
    }
    /// <summary>Gets whether the "can_see_invisible" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanSeeInvisible {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "can_see_invisible" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCanSeeInvisibleDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "can_see_invisible" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanSeeInvisible() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "bind_bone_type" field.</summary>
    public const int BindBoneTypeFieldNumber = 7;
    private uint bindBoneType_;
    /// <summary>
    ///最新的绑定骨骼描述
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BindBoneType {
      get { if ((_hasBits0 & 64) != 0) { return bindBoneType_; } else { return 0; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 64;
        bindBoneType_ = value;
      }
    }
    /// <summary>Gets whether the "bind_bone_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBindBoneType {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "bind_bone_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBindBoneTypeDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "bind_bone_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBindBoneType() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EffectCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EffectCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Time, other.Time)) return false;
      if (BindType != other.BindType) return false;
      if (BindRootType != other.BindRootType) return false;
      if (OnlyMyselfCanSee != other.OnlyMyselfCanSee) return false;
      if (CanSeeNormal != other.CanSeeNormal) return false;
      if (CanSeeInvisible != other.CanSeeInvisible) return false;
      if (BindBoneType != other.BindBoneType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Time);
      if (HasBindType) hash ^= BindType.GetHashCode();
      if (HasBindRootType) hash ^= BindRootType.GetHashCode();
      if (HasOnlyMyselfCanSee) hash ^= OnlyMyselfCanSee.GetHashCode();
      if (HasCanSeeNormal) hash ^= CanSeeNormal.GetHashCode();
      if (HasCanSeeInvisible) hash ^= CanSeeInvisible.GetHashCode();
      if (HasBindBoneType) hash ^= BindBoneType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteEnum((int) BindType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindRootType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindRootTypeDirty)) {
        output.WriteRawTag(24);
        output.WriteEnum((int) BindRootType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOnlyMyselfCanSee)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOnlyMyselfCanSeeDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(OnlyMyselfCanSee);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeNormal)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeNormalDirty)) {
        output.WriteRawTag(40);
        output.WriteUInt32(CanSeeNormal);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeInvisible)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInvisibleDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(CanSeeInvisible);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindBoneType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindBoneTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(BindBoneType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteEnum((int) BindType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindRootType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindRootTypeDirty)) {
        output.WriteRawTag(24);
        output.WriteEnum((int) BindRootType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOnlyMyselfCanSee)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOnlyMyselfCanSeeDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(OnlyMyselfCanSee);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeNormal)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeNormalDirty)) {
        output.WriteRawTag(40);
        output.WriteUInt32(CanSeeNormal);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeInvisible)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInvisibleDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(CanSeeInvisible);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBindBoneType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBindBoneTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(BindBoneType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasBindType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBindTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BindType);
      }
      if ((scope == pb.WriteScope.FULL && HasBindRootType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBindRootTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BindRootType);
      }
      if ((scope == pb.WriteScope.FULL && HasOnlyMyselfCanSee)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOnlyMyselfCanSeeDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasCanSeeNormal)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeNormalDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CanSeeNormal);
      }
      if ((scope == pb.WriteScope.FULL && HasCanSeeInvisible)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInvisibleDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CanSeeInvisible);
      }
      if ((scope == pb.WriteScope.FULL && HasBindBoneType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBindBoneTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BindBoneType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EffectCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasTime) {
        Time = other.Time;
      }
      if (other.HasBindType) {
        BindType = other.BindType;
      }
      if (other.HasBindRootType) {
        BindRootType = other.BindRootType;
      }
      if (other.HasOnlyMyselfCanSee) {
        OnlyMyselfCanSee = other.OnlyMyselfCanSee;
      }
      if (other.HasCanSeeNormal) {
        CanSeeNormal = other.CanSeeNormal;
      }
      if (other.HasCanSeeInvisible) {
        CanSeeInvisible = other.CanSeeInvisible;
      }
      if (other.HasBindBoneType) {
        BindBoneType = other.BindBoneType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 16: {
            BindType = (global::Protocol.EffectBindType) input.ReadEnum();
            break;
          }
          case 24: {
            BindRootType = (global::Protocol.EffectBindRootType) input.ReadEnum();
            break;
          }
          case 32: {
            OnlyMyselfCanSee = input.ReadBool();
            break;
          }
          case 40: {
            CanSeeNormal = input.ReadUInt32();
            break;
          }
          case 48: {
            CanSeeInvisible = input.ReadUInt32();
            break;
          }
          case 56: {
            BindBoneType = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 16: {
            BindType = (global::Protocol.EffectBindType) input.ReadEnum();
            break;
          }
          case 24: {
            BindRootType = (global::Protocol.EffectBindRootType) input.ReadEnum();
            break;
          }
          case 32: {
            OnlyMyselfCanSee = input.ReadBool();
            break;
          }
          case 40: {
            CanSeeNormal = input.ReadUInt32();
            break;
          }
          case 48: {
            CanSeeInvisible = input.ReadUInt32();
            break;
          }
          case 56: {
            BindBoneType = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AreaCfg : pb::IMessage<AreaCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AreaCfg> _parser = new pb::MessageParser<AreaCfg>(() => new AreaCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AreaCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AreaCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AreaCfg(AreaCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      areaId_ = other.areaId_;
      centerPoint_ = other.HasCenterPoint ? other.centerPoint_.Clone() : null;
      sidePointList_ = other.sidePointList_.Clone();
      radius_ = other.radius_;
      areaActionType_ = other.areaActionType_;
      isHide_ = other.isHide_;
      maxNpc_ = other.maxNpc_;
      frequency_ = other.frequency_;
      powerRadius_ = other.powerRadius_;
      areaStandList_ = other.areaStandList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AreaCfg Clone() {
      return new AreaCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "area_Id" field.</summary>
    public const int AreaIdFieldNumber = 1;
    private uint areaId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AreaId {
      get { if ((_hasBits0 & 1) != 0) { return areaId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        areaId_ = value;
      }
    }
    /// <summary>Gets whether the "area_Id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAreaId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "area_Id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAreaIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "area_Id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAreaId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "center_point" field.</summary>
    public const int CenterPointFieldNumber = 2;
    private global::Protocol.Float3 centerPoint_;
    /// <summary>
    ///中心点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 CenterPoint {
      get { return centerPoint_; }
      set {
        centerPoint_ = value;
      }
    }
    /// <summary>Gets whether the center_point field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCenterPoint {
      get { return centerPoint_ != null; }
    }
    /// <summary>Clears the value of the center_point field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCenterPoint() {
      centerPoint_ = null;
    }
    /// <summary>Gets whether the "center_point" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCenterPointDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "side_point_list" field.</summary>
    public const int SidePointListFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Protocol.Float3> _repeated_sidePointList_codec
        = pb::FieldCodec.ForMessage(26, global::Protocol.Float3.Parser);
    private readonly pbc::RepeatedField<global::Protocol.Float3> sidePointList_ = new pbc::RepeatedField<global::Protocol.Float3>();
    /// <summary>
    ///外轮廓点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.Float3> SidePointList {
      get { return sidePointList_; }
    }

    /// <summary>Field number for the "radius" field.</summary>
    public const int RadiusFieldNumber = 4;
    private float radius_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Radius {
      get { if ((_hasBits0 & 2) != 0) { return radius_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        radius_ = value;
      }
    }
    /// <summary>Gets whether the "radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRadius {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRadiusDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRadius() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "area_action_type" field.</summary>
    public const int AreaActionTypeFieldNumber = 5;
    private global::Protocol.AreaActionType areaActionType_;
    /// <summary>
    ///藏匿区表现行为类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.AreaActionType AreaActionType {
      get { if ((_hasBits0 & 4) != 0) { return areaActionType_; } else { return global::Protocol.AreaActionType.Talk; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 16;
        areaActionType_ = value;
      }
    }
    /// <summary>Gets whether the "area_action_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAreaActionType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "area_action_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAreaActionTypeDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "area_action_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAreaActionType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "is_hide" field.</summary>
    public const int IsHideFieldNumber = 6;
    private bool isHide_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHide {
      get { if ((_hasBits0 & 8) != 0) { return isHide_; } else { return false; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 32;
        isHide_ = value;
      }
    }
    /// <summary>Gets whether the "is_hide" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsHide {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "is_hide" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsHideDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "is_hide" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsHide() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "max_npc" field.</summary>
    public const int MaxNpcFieldNumber = 7;
    private uint maxNpc_;
    /// <summary>
    ///最大NPC数量
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MaxNpc {
      get { if ((_hasBits0 & 16) != 0) { return maxNpc_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 64;
        maxNpc_ = value;
      }
    }
    /// <summary>Gets whether the "max_npc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaxNpc {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "max_npc" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMaxNpcDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "max_npc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaxNpc() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "frequency" field.</summary>
    public const int FrequencyFieldNumber = 8;
    private float frequency_;
    /// <summary>
    ///吸引概率
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Frequency {
      get { if ((_hasBits0 & 32) != 0) { return frequency_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 128;
        frequency_ = value;
      }
    }
    /// <summary>Gets whether the "frequency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFrequency {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "frequency" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFrequencyDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "frequency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFrequency() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "power_radius" field.</summary>
    public const int PowerRadiusFieldNumber = 9;
    private float powerRadius_;
    /// <summary>
    ///影响半径
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PowerRadius {
      get { if ((_hasBits0 & 64) != 0) { return powerRadius_; } else { return 0F; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 256;
        powerRadius_ = value;
      }
    }
    /// <summary>Gets whether the "power_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPowerRadius {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "power_radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPowerRadiusDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "power_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPowerRadius() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "area_stand_list" field.</summary>
    public const int AreaStandListFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Protocol.AreaStandPoint> _repeated_areaStandList_codec
        = pb::FieldCodec.ForMessage(82, global::Protocol.AreaStandPoint.Parser);
    private readonly pbc::RepeatedField<global::Protocol.AreaStandPoint> areaStandList_ = new pbc::RepeatedField<global::Protocol.AreaStandPoint>();
    /// <summary>
    ///藏匿区上的停留点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.AreaStandPoint> AreaStandList {
      get { return areaStandList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AreaCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AreaCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AreaId != other.AreaId) return false;
      if (!object.Equals(CenterPoint, other.CenterPoint)) return false;
      if(!sidePointList_.Equals(other.sidePointList_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Radius, other.Radius)) return false;
      if (AreaActionType != other.AreaActionType) return false;
      if (IsHide != other.IsHide) return false;
      if (MaxNpc != other.MaxNpc) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Frequency, other.Frequency)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PowerRadius, other.PowerRadius)) return false;
      if(!areaStandList_.Equals(other.areaStandList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAreaId) hash ^= AreaId.GetHashCode();
      if (HasCenterPoint) hash ^= CenterPoint.GetHashCode();
      hash ^= sidePointList_.GetHashCode();
      if (HasRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Radius);
      if (HasAreaActionType) hash ^= AreaActionType.GetHashCode();
      if (HasIsHide) hash ^= IsHide.GetHashCode();
      if (HasMaxNpc) hash ^= MaxNpc.GetHashCode();
      if (HasFrequency) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Frequency);
      if (HasPowerRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PowerRadius);
      hash ^= areaStandList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(AreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCenterPoint)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCenterPointDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(CenterPoint);
      }
      sidePointList_.WriteTo(output, _repeated_sidePointList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaActionType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaActionTypeDirty)) {
        output.WriteRawTag(40);
        output.WriteEnum((int) AreaActionType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsHide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        output.WriteRawTag(48);
        output.WriteBool(IsHide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxNpcDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(MaxNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFrequency)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFrequencyDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(Frequency);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPowerRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPowerRadiusDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(PowerRadius);
      }
      areaStandList_.WriteTo(output, _repeated_areaStandList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(AreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCenterPoint)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCenterPointDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(CenterPoint);
      }
      sidePointList_.WriteTo(ref output, _repeated_sidePointList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaActionType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaActionTypeDirty)) {
        output.WriteRawTag(40);
        output.WriteEnum((int) AreaActionType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsHide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        output.WriteRawTag(48);
        output.WriteBool(IsHide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxNpcDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(MaxNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFrequency)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFrequencyDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(Frequency);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPowerRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPowerRadiusDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(PowerRadius);
      }
      areaStandList_.WriteTo(ref output, _repeated_areaStandList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AreaId);
      }
      if (HasCenterPoint) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(CenterPoint, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      size += sidePointList_.CalculateSize(_repeated_sidePointList_codec);
      if ((scope == pb.WriteScope.FULL && HasRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasAreaActionType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsAreaActionTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AreaActionType);
      }
      if ((scope == pb.WriteScope.FULL && HasIsHide)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasMaxNpc)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMaxNpcDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxNpc);
      }
      if ((scope == pb.WriteScope.FULL && HasFrequency)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsFrequencyDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasPowerRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPowerRadiusDirty)) {
        size += 1 + 4;
      }
      size += areaStandList_.CalculateSize(_repeated_areaStandList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AreaCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasAreaId) {
        AreaId = other.AreaId;
      }
      if (other.HasCenterPoint) {
        if (!HasCenterPoint) {
          CenterPoint = new global::Protocol.Float3();
        }
        CenterPoint.MergeFrom(other.CenterPoint);
      }
      sidePointList_.Add(other.sidePointList_);
      if (other.HasRadius) {
        Radius = other.Radius;
      }
      if (other.HasAreaActionType) {
        AreaActionType = other.AreaActionType;
      }
      if (other.HasIsHide) {
        IsHide = other.IsHide;
      }
      if (other.HasMaxNpc) {
        MaxNpc = other.MaxNpc;
      }
      if (other.HasFrequency) {
        Frequency = other.Frequency;
      }
      if (other.HasPowerRadius) {
        PowerRadius = other.PowerRadius;
      }
      areaStandList_.Add(other.areaStandList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AreaId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasCenterPoint) {
              CenterPoint = new global::Protocol.Float3();
            }
            input.ReadMessage(CenterPoint);
            break;
          }
          case 26: {
            sidePointList_.AddEntriesFrom(input, _repeated_sidePointList_codec);
            break;
          }
          case 37: {
            Radius = input.ReadFloat();
            break;
          }
          case 40: {
            AreaActionType = (global::Protocol.AreaActionType) input.ReadEnum();
            break;
          }
          case 48: {
            IsHide = input.ReadBool();
            break;
          }
          case 56: {
            MaxNpc = input.ReadUInt32();
            break;
          }
          case 69: {
            Frequency = input.ReadFloat();
            break;
          }
          case 77: {
            PowerRadius = input.ReadFloat();
            break;
          }
          case 82: {
            areaStandList_.AddEntriesFrom(input, _repeated_areaStandList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AreaId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasCenterPoint) {
              CenterPoint = new global::Protocol.Float3();
            }
            input.ReadMessage(CenterPoint);
            break;
          }
          case 26: {
            sidePointList_.AddEntriesFrom(ref input, _repeated_sidePointList_codec);
            break;
          }
          case 37: {
            Radius = input.ReadFloat();
            break;
          }
          case 40: {
            AreaActionType = (global::Protocol.AreaActionType) input.ReadEnum();
            break;
          }
          case 48: {
            IsHide = input.ReadBool();
            break;
          }
          case 56: {
            MaxNpc = input.ReadUInt32();
            break;
          }
          case 69: {
            Frequency = input.ReadFloat();
            break;
          }
          case 77: {
            PowerRadius = input.ReadFloat();
            break;
          }
          case 82: {
            areaStandList_.AddEntriesFrom(ref input, _repeated_areaStandList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class LadderCfg : pb::IMessage<LadderCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LadderCfg> _parser = new pb::MessageParser<LadderCfg>(() => new LadderCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LadderCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LadderCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LadderCfg(LadderCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      ladderId_ = other.ladderId_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      startPostion_ = other.startPostion_.Clone();
      endPostion_ = other.endPostion_.Clone();
      during_ = other.during_;
      collider_ = other.HasCollider ? other.collider_.Clone() : null;
      type_ = other.type_;
      useTimes_ = other.useTimes_;
      needProp_ = other.needProp_.Clone();
      hotAreaId_ = other.hotAreaId_;
      hotAreaNpcId_ = other.hotAreaNpcId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LadderCfg Clone() {
      return new LadderCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "ladderId" field.</summary>
    public const int LadderIdFieldNumber = 1;
    private uint ladderId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint LadderId {
      get { if ((_hasBits0 & 1) != 0) { return ladderId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        ladderId_ = value;
      }
    }
    /// <summary>Gets whether the "ladderId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLadderId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "ladderId" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLadderIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "ladderId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLadderId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 3;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "start_postion" field.</summary>
    public const int StartPostionFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Protocol.Float4> _repeated_startPostion_codec
        = pb::FieldCodec.ForMessage(34, global::Protocol.Float4.Parser);
    private readonly pbc::RepeatedField<global::Protocol.Float4> startPostion_ = new pbc::RepeatedField<global::Protocol.Float4>();
    /// <summary>
    ///开始坐标（本地）
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.Float4> StartPostion {
      get { return startPostion_; }
    }

    /// <summary>Field number for the "end_postion" field.</summary>
    public const int EndPostionFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Protocol.Float4> _repeated_endPostion_codec
        = pb::FieldCodec.ForMessage(42, global::Protocol.Float4.Parser);
    private readonly pbc::RepeatedField<global::Protocol.Float4> endPostion_ = new pbc::RepeatedField<global::Protocol.Float4>();
    /// <summary>
    ///结束坐标（本地）
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.Float4> EndPostion {
      get { return endPostion_; }
    }

    /// <summary>Field number for the "during" field.</summary>
    public const int DuringFieldNumber = 6;
    private float during_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float During {
      get { if ((_hasBits0 & 2) != 0) { return during_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 32;
        during_ = value;
      }
    }
    /// <summary>Gets whether the "during" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDuring {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "during" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDuringDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "during" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDuring() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "collider" field.</summary>
    public const int ColliderFieldNumber = 7;
    private global::Protocol.BoxColliderData collider_;
    /// <summary>
    ///碰撞盒
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BoxColliderData Collider {
      get { return collider_; }
      set {
        collider_ = value;
      }
    }
    /// <summary>Gets whether the collider field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollider {
      get { return collider_ != null; }
    }
    /// <summary>Clears the value of the collider field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollider() {
      collider_ = null;
    }
    /// <summary>Gets whether the "collider" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsColliderDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 8;
    private global::Protocol.LadderSubType type_;
    /// <summary>
    ///子类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.LadderSubType Type {
      get { if ((_hasBits0 & 4) != 0) { return type_; } else { return global::Protocol.LadderSubType.LstUnknow; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 128;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTypeDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "use_times" field.</summary>
    public const int UseTimesFieldNumber = 9;
    private int useTimes_;
    /// <summary>
    ///使用次数
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int UseTimes {
      get { if ((_hasBits0 & 8) != 0) { return useTimes_; } else { return 0; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 256;
        useTimes_ = value;
      }
    }
    /// <summary>Gets whether the "use_times" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUseTimes {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "use_times" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsUseTimesDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "use_times" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUseTimes() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "need_prop" field.</summary>
    public const int NeedPropFieldNumber = 10;
    private static readonly pb::FieldCodec<uint> _repeated_needProp_codec
        = pb::FieldCodec.ForUInt32(82);
    private readonly pbc::RepeatedField<uint> needProp_ = new pbc::RepeatedField<uint>();
    /// <summary>
    ///所需物品
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> NeedProp {
      get { return needProp_; }
    }

    /// <summary>Field number for the "hot_area_id" field.</summary>
    public const int HotAreaIdFieldNumber = 11;
    private uint hotAreaId_;
    /// <summary>
    ///热点区域ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HotAreaId {
      get { if ((_hasBits0 & 16) != 0) { return hotAreaId_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 1024;
        hotAreaId_ = value;
      }
    }
    /// <summary>Gets whether the "hot_area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHotAreaId {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "hot_area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHotAreaIdDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "hot_area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHotAreaId() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "hot_area_npc_id" field.</summary>
    public const int HotAreaNpcIdFieldNumber = 12;
    private uint hotAreaNpcId_;
    /// <summary>
    ///热点区域 NPC ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HotAreaNpcId {
      get { if ((_hasBits0 & 32) != 0) { return hotAreaNpcId_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 2048;
        hotAreaNpcId_ = value;
      }
    }
    /// <summary>Gets whether the "hot_area_npc_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHotAreaNpcId {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "hot_area_npc_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHotAreaNpcIdDirty {
      get { return (_dirtyBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "hot_area_npc_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHotAreaNpcId() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LadderCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LadderCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LadderId != other.LadderId) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if(!startPostion_.Equals(other.startPostion_)) return false;
      if(!endPostion_.Equals(other.endPostion_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(During, other.During)) return false;
      if (!object.Equals(Collider, other.Collider)) return false;
      if (Type != other.Type) return false;
      if (UseTimes != other.UseTimes) return false;
      if(!needProp_.Equals(other.needProp_)) return false;
      if (HotAreaId != other.HotAreaId) return false;
      if (HotAreaNpcId != other.HotAreaNpcId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLadderId) hash ^= LadderId.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      hash ^= startPostion_.GetHashCode();
      hash ^= endPostion_.GetHashCode();
      if (HasDuring) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(During);
      if (HasCollider) hash ^= Collider.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasUseTimes) hash ^= UseTimes.GetHashCode();
      hash ^= needProp_.GetHashCode();
      if (HasHotAreaId) hash ^= HotAreaId.GetHashCode();
      if (HasHotAreaNpcId) hash ^= HotAreaNpcId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasLadderId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLadderIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(LadderId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      startPostion_.WriteTo(output, _repeated_startPostion_codec);
      endPostion_.WriteTo(output, _repeated_endPostion_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasDuring)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDuringDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(During);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(58);
        output.WriteMessage(Collider);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) Type);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUseTimes)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUseTimesDirty)) {
        output.WriteRawTag(72);
        output.WriteInt32(UseTimes);
      }
      needProp_.WriteTo(output, _repeated_needProp_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasHotAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaIdDirty)) {
        output.WriteRawTag(88);
        output.WriteUInt32(HotAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHotAreaNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaNpcIdDirty)) {
        output.WriteRawTag(96);
        output.WriteUInt32(HotAreaNpcId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasLadderId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLadderIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(LadderId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      startPostion_.WriteTo(ref output, _repeated_startPostion_codec);
      endPostion_.WriteTo(ref output, _repeated_endPostion_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasDuring)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDuringDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(During);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(58);
        output.WriteMessage(Collider);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) Type);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUseTimes)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUseTimesDirty)) {
        output.WriteRawTag(72);
        output.WriteInt32(UseTimes);
      }
      needProp_.WriteTo(ref output, _repeated_needProp_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasHotAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaIdDirty)) {
        output.WriteRawTag(88);
        output.WriteUInt32(HotAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHotAreaNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaNpcIdDirty)) {
        output.WriteRawTag(96);
        output.WriteUInt32(HotAreaNpcId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasLadderId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLadderIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LadderId);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      size += startPostion_.CalculateSize(_repeated_startPostion_codec);
      size += endPostion_.CalculateSize(_repeated_endPostion_codec);
      if ((scope == pb.WriteScope.FULL && HasDuring)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsDuringDirty)) {
        size += 1 + 4;
      }
      if (HasCollider) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Collider, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 64;
        } else {
          _dirtyBits0 &= ~64;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if ((scope == pb.WriteScope.FULL && HasUseTimes)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsUseTimesDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(UseTimes);
      }
      size += needProp_.CalculateSize(_repeated_needProp_codec);
      if ((scope == pb.WriteScope.FULL && HasHotAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HotAreaId);
      }
      if ((scope == pb.WriteScope.FULL && HasHotAreaNpcId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHotAreaNpcIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HotAreaNpcId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LadderCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasLadderId) {
        LadderId = other.LadderId;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      startPostion_.Add(other.startPostion_);
      endPostion_.Add(other.endPostion_);
      if (other.HasDuring) {
        During = other.During;
      }
      if (other.HasCollider) {
        if (!HasCollider) {
          Collider = new global::Protocol.BoxColliderData();
        }
        Collider.MergeFrom(other.Collider);
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasUseTimes) {
        UseTimes = other.UseTimes;
      }
      needProp_.Add(other.needProp_);
      if (other.HasHotAreaId) {
        HotAreaId = other.HotAreaId;
      }
      if (other.HasHotAreaNpcId) {
        HotAreaNpcId = other.HotAreaNpcId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LadderId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 34: {
            startPostion_.AddEntriesFrom(input, _repeated_startPostion_codec);
            break;
          }
          case 42: {
            endPostion_.AddEntriesFrom(input, _repeated_endPostion_codec);
            break;
          }
          case 53: {
            During = input.ReadFloat();
            break;
          }
          case 58: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
          case 64: {
            Type = (global::Protocol.LadderSubType) input.ReadEnum();
            break;
          }
          case 72: {
            UseTimes = input.ReadInt32();
            break;
          }
          case 82:
          case 80: {
            needProp_.AddEntriesFrom(input, _repeated_needProp_codec);
            break;
          }
          case 88: {
            HotAreaId = input.ReadUInt32();
            break;
          }
          case 96: {
            HotAreaNpcId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            LadderId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 34: {
            startPostion_.AddEntriesFrom(ref input, _repeated_startPostion_codec);
            break;
          }
          case 42: {
            endPostion_.AddEntriesFrom(ref input, _repeated_endPostion_codec);
            break;
          }
          case 53: {
            During = input.ReadFloat();
            break;
          }
          case 58: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
          case 64: {
            Type = (global::Protocol.LadderSubType) input.ReadEnum();
            break;
          }
          case 72: {
            UseTimes = input.ReadInt32();
            break;
          }
          case 82:
          case 80: {
            needProp_.AddEntriesFrom(ref input, _repeated_needProp_codec);
            break;
          }
          case 88: {
            HotAreaId = input.ReadUInt32();
            break;
          }
          case 96: {
            HotAreaNpcId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class PlayerCameraCfg : pb::IMessage<PlayerCameraCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PlayerCameraCfg> _parser = new pb::MessageParser<PlayerCameraCfg>(() => new PlayerCameraCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PlayerCameraCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerCameraCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerCameraCfg(PlayerCameraCfg other) : this() {
      _dirtyBits0 = other._dirtyBits0;
      cameraCfgList_ = other.cameraCfgList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerCameraCfg Clone() {
      return new PlayerCameraCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "cameraCfgList" field.</summary>
    public const int CameraCfgListFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protocol.CameraCfg> _repeated_cameraCfgList_codec
        = pb::FieldCodec.ForMessage(10, global::Protocol.CameraCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.CameraCfg> cameraCfgList_ = new pbc::RepeatedField<global::Protocol.CameraCfg>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.CameraCfg> CameraCfgList {
      get { return cameraCfgList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PlayerCameraCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PlayerCameraCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!cameraCfgList_.Equals(other.cameraCfgList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= cameraCfgList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      cameraCfgList_.WriteTo(output, _repeated_cameraCfgList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      cameraCfgList_.WriteTo(ref output, _repeated_cameraCfgList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      size += cameraCfgList_.CalculateSize(_repeated_cameraCfgList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PlayerCameraCfg other) {
      if (other == null) {
        return;
      }
      cameraCfgList_.Add(other.cameraCfgList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            cameraCfgList_.AddEntriesFrom(input, _repeated_cameraCfgList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            cameraCfgList_.AddEntriesFrom(ref input, _repeated_cameraCfgList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CameraCfg : pb::IMessage<CameraCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CameraCfg> _parser = new pb::MessageParser<CameraCfg>(() => new CameraCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CameraCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CameraCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CameraCfg(CameraCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      cameraId_ = other.cameraId_;
      cameraType_ = other.cameraType_;
      subState_ = other.subState_;
      keyBoardType_ = other.keyBoardType_;
      relativePostion_ = other.HasRelativePostion ? other.relativePostion_.Clone() : null;
      cameraPrefabPath_ = other.cameraPrefabPath_;
      fov_ = other.fov_;
      minFollowSpeed_ = other.minFollowSpeed_;
      maxFollowSpeed_ = other.maxFollowSpeed_;
      maxFollowDistance_ = other.maxFollowDistance_;
      speedCurve_ = other.speedCurve_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CameraCfg Clone() {
      return new CameraCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "camera_id" field.</summary>
    public const int CameraIdFieldNumber = 1;
    private uint cameraId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CameraId {
      get { if ((_hasBits0 & 1) != 0) { return cameraId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        cameraId_ = value;
      }
    }
    /// <summary>Gets whether the "camera_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCameraId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "camera_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCameraIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "camera_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCameraId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "camera_type" field.</summary>
    public const int CameraTypeFieldNumber = 2;
    private int cameraType_;
    /// <summary>
    ///1.人物状态  2.键盘   3.触发盒
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CameraType {
      get { if ((_hasBits0 & 2) != 0) { return cameraType_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        cameraType_ = value;
      }
    }
    /// <summary>Gets whether the "camera_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCameraType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "camera_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCameraTypeDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "camera_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCameraType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sub_state" field.</summary>
    public const int SubStateFieldNumber = 3;
    private int subState_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SubState {
      get { if ((_hasBits0 & 4) != 0) { return subState_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        subState_ = value;
      }
    }
    /// <summary>Gets whether the "sub_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubState {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "sub_state" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSubStateDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "sub_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubState() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "key_board_type" field.</summary>
    public const int KeyBoardTypeFieldNumber = 4;
    private int keyBoardType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int KeyBoardType {
      get { if ((_hasBits0 & 8) != 0) { return keyBoardType_; } else { return 0; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        keyBoardType_ = value;
      }
    }
    /// <summary>Gets whether the "key_board_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKeyBoardType {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "key_board_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsKeyBoardTypeDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "key_board_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKeyBoardType() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "relative_postion" field.</summary>
    public const int RelativePostionFieldNumber = 5;
    private global::Protocol.Float3 relativePostion_;
    /// <summary>
    ///  相对主相机的坐标
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 RelativePostion {
      get { return relativePostion_; }
      set {
        relativePostion_ = value;
      }
    }
    /// <summary>Gets whether the relative_postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRelativePostion {
      get { return relativePostion_ != null; }
    }
    /// <summary>Clears the value of the relative_postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRelativePostion() {
      relativePostion_ = null;
    }
    /// <summary>Gets whether the "relative_postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRelativePostionDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    /// <summary>Field number for the "camera_prefab_path" field.</summary>
    public const int CameraPrefabPathFieldNumber = 6;
    private string cameraPrefabPath_;
    /// <summary>
    ///  相机prefab路径
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CameraPrefabPath {
      get { return cameraPrefabPath_ ?? ""; }
      set {
        cameraPrefabPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "camera_prefab_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCameraPrefabPath {
      get { return cameraPrefabPath_ != null; }
    }
    /// <summary>Gets whether the "camera_prefab_path" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCameraPrefabPathDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "camera_prefab_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCameraPrefabPath() {
      cameraPrefabPath_ = null;
    }

    /// <summary>Field number for the "fov" field.</summary>
    public const int FovFieldNumber = 7;
    private float fov_;
    /// <summary>
    ///	相机fov
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Fov {
      get { if ((_hasBits0 & 16) != 0) { return fov_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 64;
        fov_ = value;
      }
    }
    /// <summary>Gets whether the "fov" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFov {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "fov" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFovDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "fov" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFov() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "min_follow_speed" field.</summary>
    public const int MinFollowSpeedFieldNumber = 8;
    private float minFollowSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinFollowSpeed {
      get { if ((_hasBits0 & 32) != 0) { return minFollowSpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 128;
        minFollowSpeed_ = value;
      }
    }
    /// <summary>Gets whether the "min_follow_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMinFollowSpeed {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "min_follow_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMinFollowSpeedDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "min_follow_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMinFollowSpeed() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "max_follow_speed" field.</summary>
    public const int MaxFollowSpeedFieldNumber = 9;
    private float maxFollowSpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxFollowSpeed {
      get { if ((_hasBits0 & 64) != 0) { return maxFollowSpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 256;
        maxFollowSpeed_ = value;
      }
    }
    /// <summary>Gets whether the "max_follow_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaxFollowSpeed {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "max_follow_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMaxFollowSpeedDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "max_follow_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaxFollowSpeed() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "max_follow_distance" field.</summary>
    public const int MaxFollowDistanceFieldNumber = 10;
    private float maxFollowDistance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxFollowDistance {
      get { if ((_hasBits0 & 128) != 0) { return maxFollowDistance_; } else { return 0F; } }
      set {
        _hasBits0 |= 128;
        _dirtyBits0 |= 512;
        maxFollowDistance_ = value;
      }
    }
    /// <summary>Gets whether the "max_follow_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaxFollowDistance {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Gets whether the "max_follow_distance" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMaxFollowDistanceDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "max_follow_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaxFollowDistance() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "speed_curve" field.</summary>
    public const int SpeedCurveFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_speedCurve_codec
        = pb::FieldCodec.ForMessage(90, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> speedCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> SpeedCurve {
      get { return speedCurve_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CameraCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CameraCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CameraId != other.CameraId) return false;
      if (CameraType != other.CameraType) return false;
      if (SubState != other.SubState) return false;
      if (KeyBoardType != other.KeyBoardType) return false;
      if (!object.Equals(RelativePostion, other.RelativePostion)) return false;
      if (CameraPrefabPath != other.CameraPrefabPath) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Fov, other.Fov)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinFollowSpeed, other.MinFollowSpeed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxFollowSpeed, other.MaxFollowSpeed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxFollowDistance, other.MaxFollowDistance)) return false;
      if(!speedCurve_.Equals(other.speedCurve_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCameraId) hash ^= CameraId.GetHashCode();
      if (HasCameraType) hash ^= CameraType.GetHashCode();
      if (HasSubState) hash ^= SubState.GetHashCode();
      if (HasKeyBoardType) hash ^= KeyBoardType.GetHashCode();
      if (HasRelativePostion) hash ^= RelativePostion.GetHashCode();
      if (HasCameraPrefabPath) hash ^= CameraPrefabPath.GetHashCode();
      if (HasFov) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Fov);
      if (HasMinFollowSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinFollowSpeed);
      if (HasMaxFollowSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxFollowSpeed);
      if (HasMaxFollowDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxFollowDistance);
      hash ^= speedCurve_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(CameraId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteInt32(CameraType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubState)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubStateDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(SubState);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasKeyBoardType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsKeyBoardTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteInt32(KeyBoardType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRelativePostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRelativePostionDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(RelativePostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraPrefabPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraPrefabPathDirty)) {
        output.WriteRawTag(50);
        output.WriteString(CameraPrefabPath);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFov)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFovDirty)) {
        output.WriteRawTag(61);
        output.WriteFloat(Fov);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMinFollowSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMinFollowSpeedDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(MinFollowSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxFollowSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowSpeedDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(MaxFollowSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxFollowDistance)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowDistanceDirty)) {
        output.WriteRawTag(85);
        output.WriteFloat(MaxFollowDistance);
      }
      speedCurve_.WriteTo(output, _repeated_speedCurve_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(CameraId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteInt32(CameraType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubState)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubStateDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(SubState);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasKeyBoardType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsKeyBoardTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteInt32(KeyBoardType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRelativePostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRelativePostionDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(RelativePostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCameraPrefabPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCameraPrefabPathDirty)) {
        output.WriteRawTag(50);
        output.WriteString(CameraPrefabPath);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFov)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFovDirty)) {
        output.WriteRawTag(61);
        output.WriteFloat(Fov);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMinFollowSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMinFollowSpeedDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(MinFollowSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxFollowSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowSpeedDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(MaxFollowSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxFollowDistance)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowDistanceDirty)) {
        output.WriteRawTag(85);
        output.WriteFloat(MaxFollowDistance);
      }
      speedCurve_.WriteTo(ref output, _repeated_speedCurve_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasCameraId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCameraIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CameraId);
      }
      if ((scope == pb.WriteScope.FULL && HasCameraType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCameraTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CameraType);
      }
      if ((scope == pb.WriteScope.FULL && HasSubState)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsSubStateDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SubState);
      }
      if ((scope == pb.WriteScope.FULL && HasKeyBoardType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsKeyBoardTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(KeyBoardType);
      }
      if (HasRelativePostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(RelativePostion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasCameraPrefabPath)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCameraPrefabPathDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CameraPrefabPath);
      }
      if ((scope == pb.WriteScope.FULL && HasFov)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsFovDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasMinFollowSpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMinFollowSpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasMaxFollowSpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowSpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasMaxFollowDistance)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMaxFollowDistanceDirty)) {
        size += 1 + 4;
      }
      size += speedCurve_.CalculateSize(_repeated_speedCurve_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CameraCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasCameraId) {
        CameraId = other.CameraId;
      }
      if (other.HasCameraType) {
        CameraType = other.CameraType;
      }
      if (other.HasSubState) {
        SubState = other.SubState;
      }
      if (other.HasKeyBoardType) {
        KeyBoardType = other.KeyBoardType;
      }
      if (other.HasRelativePostion) {
        if (!HasRelativePostion) {
          RelativePostion = new global::Protocol.Float3();
        }
        RelativePostion.MergeFrom(other.RelativePostion);
      }
      if (other.HasCameraPrefabPath) {
        CameraPrefabPath = other.CameraPrefabPath;
      }
      if (other.HasFov) {
        Fov = other.Fov;
      }
      if (other.HasMinFollowSpeed) {
        MinFollowSpeed = other.MinFollowSpeed;
      }
      if (other.HasMaxFollowSpeed) {
        MaxFollowSpeed = other.MaxFollowSpeed;
      }
      if (other.HasMaxFollowDistance) {
        MaxFollowDistance = other.MaxFollowDistance;
      }
      speedCurve_.Add(other.speedCurve_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CameraId = input.ReadUInt32();
            break;
          }
          case 16: {
            CameraType = input.ReadInt32();
            break;
          }
          case 24: {
            SubState = input.ReadInt32();
            break;
          }
          case 32: {
            KeyBoardType = input.ReadInt32();
            break;
          }
          case 42: {
            if (!HasRelativePostion) {
              RelativePostion = new global::Protocol.Float3();
            }
            input.ReadMessage(RelativePostion);
            break;
          }
          case 50: {
            CameraPrefabPath = input.ReadString();
            break;
          }
          case 61: {
            Fov = input.ReadFloat();
            break;
          }
          case 69: {
            MinFollowSpeed = input.ReadFloat();
            break;
          }
          case 77: {
            MaxFollowSpeed = input.ReadFloat();
            break;
          }
          case 85: {
            MaxFollowDistance = input.ReadFloat();
            break;
          }
          case 90: {
            speedCurve_.AddEntriesFrom(input, _repeated_speedCurve_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CameraId = input.ReadUInt32();
            break;
          }
          case 16: {
            CameraType = input.ReadInt32();
            break;
          }
          case 24: {
            SubState = input.ReadInt32();
            break;
          }
          case 32: {
            KeyBoardType = input.ReadInt32();
            break;
          }
          case 42: {
            if (!HasRelativePostion) {
              RelativePostion = new global::Protocol.Float3();
            }
            input.ReadMessage(RelativePostion);
            break;
          }
          case 50: {
            CameraPrefabPath = input.ReadString();
            break;
          }
          case 61: {
            Fov = input.ReadFloat();
            break;
          }
          case 69: {
            MinFollowSpeed = input.ReadFloat();
            break;
          }
          case 77: {
            MaxFollowSpeed = input.ReadFloat();
            break;
          }
          case 85: {
            MaxFollowDistance = input.ReadFloat();
            break;
          }
          case 90: {
            speedCurve_.AddEntriesFrom(ref input, _repeated_speedCurve_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class BornCfg : pb::IMessage<BornCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BornCfg> _parser = new pb::MessageParser<BornCfg>(() => new BornCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BornCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BornCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BornCfg(BornCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      eType_ = other.eType_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      camp_ = other.camp_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BornCfg Clone() {
      return new BornCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "e_type" field.</summary>
    public const int ETypeFieldNumber = 1;
    private global::Protocol.EntityType eType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EntityType EType {
      get { if ((_hasBits0 & 1) != 0) { return eType_; } else { return global::Protocol.EntityType.Empty; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        eType_ = value;
      }
    }
    /// <summary>Gets whether the "e_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "e_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsETypeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "e_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 3;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "camp" field.</summary>
    public const int CampFieldNumber = 4;
    private uint camp_;
    /// <summary>
    ///阵营信息
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Camp {
      get { if ((_hasBits0 & 2) != 0) { return camp_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        camp_ = value;
      }
    }
    /// <summary>Gets whether the "camp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCamp {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "camp" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCampDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "camp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCamp() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BornCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BornCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EType != other.EType) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (Camp != other.Camp) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEType) hash ^= EType.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasCamp) hash ^= Camp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCamp)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCampDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(Camp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCamp)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCampDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(Camp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasEType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EType);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasCamp)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCampDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Camp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BornCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasEType) {
        EType = other.EType;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasCamp) {
        Camp = other.Camp;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            Camp = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            Camp = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GoapTargetCfg : pb::IMessage<GoapTargetCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GoapTargetCfg> _parser = new pb::MessageParser<GoapTargetCfg>(() => new GoapTargetCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GoapTargetCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoapTargetCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoapTargetCfg(GoapTargetCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      architectureId_ = other.architectureId_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      npcId_ = other.npcId_;
      npcPos_ = other.HasNpcPos ? other.npcPos_.Clone() : null;
      npcRota_ = other.HasNpcRota ? other.npcRota_.Clone() : null;
      eType_ = other.eType_;
      subType_ = other.subType_;
      bornType_ = other.bornType_;
      goapAssetName_ = other.goapAssetName_;
      archGoapAssetName_ = other.archGoapAssetName_;
      lineUpInfo_ = other.lineUpInfo_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GoapTargetCfg Clone() {
      return new GoapTargetCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "architectureId" field.</summary>
    public const int ArchitectureIdFieldNumber = 1;
    private uint architectureId_;
    /// <summary>
    ///对应建筑配置表ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ArchitectureId {
      get { if ((_hasBits0 & 1) != 0) { return architectureId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        architectureId_ = value;
      }
    }
    /// <summary>Gets whether the "architectureId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasArchitectureId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "architectureId" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsArchitectureIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "architectureId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearArchitectureId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    /// <summary>
    ///建筑位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 3;
    private global::Protocol.Float3 rotation_;
    /// <summary>
    ///建筑欧拉旋转角度	
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "npcId" field.</summary>
    public const int NpcIdFieldNumber = 4;
    private uint npcId_;
    /// <summary>
    ///关联NpcId
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NpcId {
      get { if ((_hasBits0 & 2) != 0) { return npcId_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        npcId_ = value;
      }
    }
    /// <summary>Gets whether the "npcId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "npcId" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcIdDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "npcId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "npcPos" field.</summary>
    public const int NpcPosFieldNumber = 5;
    private global::Protocol.Float3 npcPos_;
    /// <summary>
    ///Npc位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 NpcPos {
      get { return npcPos_; }
      set {
        npcPos_ = value;
      }
    }
    /// <summary>Gets whether the npcPos field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcPos {
      get { return npcPos_ != null; }
    }
    /// <summary>Clears the value of the npcPos field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcPos() {
      npcPos_ = null;
    }
    /// <summary>Gets whether the "npcPos" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcPosDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    /// <summary>Field number for the "npcRota" field.</summary>
    public const int NpcRotaFieldNumber = 6;
    private global::Protocol.Float3 npcRota_;
    /// <summary>
    ///Npc旋转
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 NpcRota {
      get { return npcRota_; }
      set {
        npcRota_ = value;
      }
    }
    /// <summary>Gets whether the npcRota field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcRota {
      get { return npcRota_ != null; }
    }
    /// <summary>Clears the value of the npcRota field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcRota() {
      npcRota_ = null;
    }
    /// <summary>Gets whether the "npcRota" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcRotaDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }

    /// <summary>Field number for the "e_type" field.</summary>
    public const int ETypeFieldNumber = 7;
    private global::Protocol.EntityType eType_;
    /// <summary>
    ///Entity类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EntityType EType {
      get { if ((_hasBits0 & 4) != 0) { return eType_; } else { return global::Protocol.EntityType.Empty; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 64;
        eType_ = value;
      }
    }
    /// <summary>Gets whether the "e_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "e_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsETypeDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "e_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "subType" field.</summary>
    public const int SubTypeFieldNumber = 8;
    private global::Protocol.NpcSubType subType_;
    /// <summary>
    ///角色子类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.NpcSubType SubType {
      get { if ((_hasBits0 & 8) != 0) { return subType_; } else { return global::Protocol.NpcSubType.NstUnkown; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 128;
        subType_ = value;
      }
    }
    /// <summary>Gets whether the "subType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubType {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "subType" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSubTypeDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "subType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubType() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "born_type" field.</summary>
    public const int BornTypeFieldNumber = 9;
    private global::Protocol.BornType bornType_;
    /// <summary>
    ///出生类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BornType BornType {
      get { if ((_hasBits0 & 16) != 0) { return bornType_; } else { return global::Protocol.BornType.BtRightNow; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 256;
        bornType_ = value;
      }
    }
    /// <summary>Gets whether the "born_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornType {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "born_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornTypeDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "born_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornType() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "goap_asset_name" field.</summary>
    public const int GoapAssetNameFieldNumber = 10;
    private string goapAssetName_;
    /// <summary>
    ///Npc_Goap配置名称
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GoapAssetName {
      get { return goapAssetName_ ?? ""; }
      set {
        goapAssetName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "goap_asset_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGoapAssetName {
      get { return goapAssetName_ != null; }
    }
    /// <summary>Gets whether the "goap_asset_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGoapAssetNameDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "goap_asset_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGoapAssetName() {
      goapAssetName_ = null;
    }

    /// <summary>Field number for the "arch_goap_asset_name" field.</summary>
    public const int ArchGoapAssetNameFieldNumber = 12;
    private string archGoapAssetName_;
    /// <summary>
    ///建筑Goap配置名称
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ArchGoapAssetName {
      get { return archGoapAssetName_ ?? ""; }
      set {
        archGoapAssetName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "arch_goap_asset_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasArchGoapAssetName {
      get { return archGoapAssetName_ != null; }
    }
    /// <summary>Gets whether the "arch_goap_asset_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsArchGoapAssetNameDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "arch_goap_asset_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearArchGoapAssetName() {
      archGoapAssetName_ = null;
    }

    /// <summary>Field number for the "line_up_info" field.</summary>
    public const int LineUpInfoFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Protocol.NpcLineUpCfg> _repeated_lineUpInfo_codec
        = pb::FieldCodec.ForMessage(106, global::Protocol.NpcLineUpCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.NpcLineUpCfg> lineUpInfo_ = new pbc::RepeatedField<global::Protocol.NpcLineUpCfg>();
    /// <summary>
    ///建筑npc站位配置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.NpcLineUpCfg> LineUpInfo {
      get { return lineUpInfo_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GoapTargetCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GoapTargetCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ArchitectureId != other.ArchitectureId) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (NpcId != other.NpcId) return false;
      if (!object.Equals(NpcPos, other.NpcPos)) return false;
      if (!object.Equals(NpcRota, other.NpcRota)) return false;
      if (EType != other.EType) return false;
      if (SubType != other.SubType) return false;
      if (BornType != other.BornType) return false;
      if (GoapAssetName != other.GoapAssetName) return false;
      if (ArchGoapAssetName != other.ArchGoapAssetName) return false;
      if(!lineUpInfo_.Equals(other.lineUpInfo_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasArchitectureId) hash ^= ArchitectureId.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasNpcId) hash ^= NpcId.GetHashCode();
      if (HasNpcPos) hash ^= NpcPos.GetHashCode();
      if (HasNpcRota) hash ^= NpcRota.GetHashCode();
      if (HasEType) hash ^= EType.GetHashCode();
      if (HasSubType) hash ^= SubType.GetHashCode();
      if (HasBornType) hash ^= BornType.GetHashCode();
      if (HasGoapAssetName) hash ^= GoapAssetName.GetHashCode();
      if (HasArchGoapAssetName) hash ^= ArchGoapAssetName.GetHashCode();
      hash ^= lineUpInfo_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(ArchitectureId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(NpcId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcPos)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcPosDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(NpcPos);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcRota)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcRotaDirty)) {
        output.WriteRawTag(50);
        output.WriteMessage(NpcRota);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(56);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) SubType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(72);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(82);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchGoapAssetNameDirty)) {
        output.WriteRawTag(98);
        output.WriteString(ArchGoapAssetName);
      }
      lineUpInfo_.WriteTo(output, _repeated_lineUpInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(ArchitectureId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(NpcId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcPos)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcPosDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(NpcPos);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcRota)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcRotaDirty)) {
        output.WriteRawTag(50);
        output.WriteMessage(NpcRota);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(56);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) SubType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(72);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(82);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchGoapAssetNameDirty)) {
        output.WriteRawTag(98);
        output.WriteString(ArchGoapAssetName);
      }
      lineUpInfo_.WriteTo(ref output, _repeated_lineUpInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasArchitectureId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ArchitectureId);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasNpcId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NpcId);
      }
      if (HasNpcPos) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(NpcPos, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if (HasNpcRota) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(NpcRota, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 32;
        } else {
          _dirtyBits0 &= ~32;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasEType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EType);
      }
      if ((scope == pb.WriteScope.FULL && HasSubType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SubType);
      }
      if ((scope == pb.WriteScope.FULL && HasBornType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BornType);
      }
      if ((scope == pb.WriteScope.FULL && HasGoapAssetName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GoapAssetName);
      }
      if ((scope == pb.WriteScope.FULL && HasArchGoapAssetName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsArchGoapAssetNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ArchGoapAssetName);
      }
      size += lineUpInfo_.CalculateSize(_repeated_lineUpInfo_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GoapTargetCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasArchitectureId) {
        ArchitectureId = other.ArchitectureId;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasNpcId) {
        NpcId = other.NpcId;
      }
      if (other.HasNpcPos) {
        if (!HasNpcPos) {
          NpcPos = new global::Protocol.Float3();
        }
        NpcPos.MergeFrom(other.NpcPos);
      }
      if (other.HasNpcRota) {
        if (!HasNpcRota) {
          NpcRota = new global::Protocol.Float3();
        }
        NpcRota.MergeFrom(other.NpcRota);
      }
      if (other.HasEType) {
        EType = other.EType;
      }
      if (other.HasSubType) {
        SubType = other.SubType;
      }
      if (other.HasBornType) {
        BornType = other.BornType;
      }
      if (other.HasGoapAssetName) {
        GoapAssetName = other.GoapAssetName;
      }
      if (other.HasArchGoapAssetName) {
        ArchGoapAssetName = other.ArchGoapAssetName;
      }
      lineUpInfo_.Add(other.lineUpInfo_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ArchitectureId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            NpcId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasNpcPos) {
              NpcPos = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcPos);
            break;
          }
          case 50: {
            if (!HasNpcRota) {
              NpcRota = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcRota);
            break;
          }
          case 56: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 64: {
            SubType = (global::Protocol.NpcSubType) input.ReadEnum();
            break;
          }
          case 72: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 82: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 98: {
            ArchGoapAssetName = input.ReadString();
            break;
          }
          case 106: {
            lineUpInfo_.AddEntriesFrom(input, _repeated_lineUpInfo_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ArchitectureId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            NpcId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasNpcPos) {
              NpcPos = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcPos);
            break;
          }
          case 50: {
            if (!HasNpcRota) {
              NpcRota = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcRota);
            break;
          }
          case 56: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 64: {
            SubType = (global::Protocol.NpcSubType) input.ReadEnum();
            break;
          }
          case 72: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 82: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 98: {
            ArchGoapAssetName = input.ReadString();
            break;
          }
          case 106: {
            lineUpInfo_.AddEntriesFrom(ref input, _repeated_lineUpInfo_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NpcLineUpCfg : pb::IMessage<NpcLineUpCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NpcLineUpCfg> _parser = new pb::MessageParser<NpcLineUpCfg>(() => new NpcLineUpCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NpcLineUpCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcLineUpCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcLineUpCfg(NpcLineUpCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      lineId_ = other.lineId_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      used_ = other.used_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcLineUpCfg Clone() {
      return new NpcLineUpCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "line_Id" field.</summary>
    public const int LineIdFieldNumber = 1;
    private uint lineId_;
    /// <summary>
    ///顺序Id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint LineId {
      get { if ((_hasBits0 & 1) != 0) { return lineId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        lineId_ = value;
      }
    }
    /// <summary>Gets whether the "line_Id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLineId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "line_Id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLineIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "line_Id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLineId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 3;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "used" field.</summary>
    public const int UsedFieldNumber = 4;
    private bool used_;
    /// <summary>
    ///是否栏位已被占用
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Used {
      get { if ((_hasBits0 & 2) != 0) { return used_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        used_ = value;
      }
    }
    /// <summary>Gets whether the "used" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUsed {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "used" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsUsedDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "used" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUsed() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NpcLineUpCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NpcLineUpCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LineId != other.LineId) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (Used != other.Used) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLineId) hash ^= LineId.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasUsed) hash ^= Used.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasLineId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLineIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(LineId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUsed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUsedDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(Used);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasLineId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLineIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(LineId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUsed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUsedDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(Used);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasLineId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLineIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LineId);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasUsed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsUsedDirty)) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NpcLineUpCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasLineId) {
        LineId = other.LineId;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasUsed) {
        Used = other.Used;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LineId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            Used = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            LineId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            Used = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ClusterCfg : pb::IMessage<ClusterCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClusterCfg> _parser = new pb::MessageParser<ClusterCfg>(() => new ClusterCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ClusterCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterCfg(ClusterCfg other) : this() {
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      npcClusterCfg_ = other.npcClusterCfg_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterCfg Clone() {
      return new ClusterCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    /// <summary>
    ///建筑位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "npc_cluster_cfg" field.</summary>
    public const int NpcClusterCfgFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Protocol.NpcClusterCfg> _repeated_npcClusterCfg_codec
        = pb::FieldCodec.ForMessage(26, global::Protocol.NpcClusterCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.NpcClusterCfg> npcClusterCfg_ = new pbc::RepeatedField<global::Protocol.NpcClusterCfg>();
    /// <summary>
    ///集群npc配置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.NpcClusterCfg> NpcClusterCfg {
      get { return npcClusterCfg_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ClusterCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ClusterCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if(!npcClusterCfg_.Equals(other.npcClusterCfg_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      hash ^= npcClusterCfg_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      npcClusterCfg_.WriteTo(output, _repeated_npcClusterCfg_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      npcClusterCfg_.WriteTo(ref output, _repeated_npcClusterCfg_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      size += npcClusterCfg_.CalculateSize(_repeated_npcClusterCfg_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ClusterCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      npcClusterCfg_.Add(other.npcClusterCfg_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            npcClusterCfg_.AddEntriesFrom(input, _repeated_npcClusterCfg_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            npcClusterCfg_.AddEntriesFrom(ref input, _repeated_npcClusterCfg_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NpcClusterCfg : pb::IMessage<NpcClusterCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NpcClusterCfg> _parser = new pb::MessageParser<NpcClusterCfg>(() => new NpcClusterCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NpcClusterCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcClusterCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcClusterCfg(NpcClusterCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      npcId_ = other.npcId_;
      npcPos_ = other.HasNpcPos ? other.npcPos_.Clone() : null;
      npcRota_ = other.HasNpcRota ? other.npcRota_.Clone() : null;
      bornType_ = other.bornType_;
      goapAssetName_ = other.goapAssetName_;
      eType_ = other.eType_;
      openGazeFun_ = other.openGazeFun_;
      gazeMaxAngle_ = other.gazeMaxAngle_;
      gazeMaxRadius_ = other.gazeMaxRadius_;
      clusterId_ = other.clusterId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcClusterCfg Clone() {
      return new NpcClusterCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "npcId" field.</summary>
    public const int NpcIdFieldNumber = 1;
    private uint npcId_;
    /// <summary>
    ///关联NpcId。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NpcId {
      get { if ((_hasBits0 & 1) != 0) { return npcId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        npcId_ = value;
      }
    }
    /// <summary>Gets whether the "npcId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "npcId" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "npcId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "npcPos" field.</summary>
    public const int NpcPosFieldNumber = 2;
    private global::Protocol.Float3 npcPos_;
    /// <summary>
    ///Npc位置。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 NpcPos {
      get { return npcPos_; }
      set {
        npcPos_ = value;
      }
    }
    /// <summary>Gets whether the npcPos field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcPos {
      get { return npcPos_ != null; }
    }
    /// <summary>Clears the value of the npcPos field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcPos() {
      npcPos_ = null;
    }
    /// <summary>Gets whether the "npcPos" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcPosDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "npcRota" field.</summary>
    public const int NpcRotaFieldNumber = 3;
    private global::Protocol.Float3 npcRota_;
    /// <summary>
    ///Npc旋转。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 NpcRota {
      get { return npcRota_; }
      set {
        npcRota_ = value;
      }
    }
    /// <summary>Gets whether the npcRota field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcRota {
      get { return npcRota_ != null; }
    }
    /// <summary>Clears the value of the npcRota field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcRota() {
      npcRota_ = null;
    }
    /// <summary>Gets whether the "npcRota" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcRotaDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "born_type" field.</summary>
    public const int BornTypeFieldNumber = 4;
    private global::Protocol.BornType bornType_;
    /// <summary>
    ///出生类型。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BornType BornType {
      get { if ((_hasBits0 & 2) != 0) { return bornType_; } else { return global::Protocol.BornType.BtRightNow; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        bornType_ = value;
      }
    }
    /// <summary>Gets whether the "born_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "born_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornTypeDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "born_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "goap_asset_name" field.</summary>
    public const int GoapAssetNameFieldNumber = 5;
    private string goapAssetName_;
    /// <summary>
    ///Npc_Goap配置名称。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GoapAssetName {
      get { return goapAssetName_ ?? ""; }
      set {
        goapAssetName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "goap_asset_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGoapAssetName {
      get { return goapAssetName_ != null; }
    }
    /// <summary>Gets whether the "goap_asset_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGoapAssetNameDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "goap_asset_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGoapAssetName() {
      goapAssetName_ = null;
    }

    /// <summary>Field number for the "e_type" field.</summary>
    public const int ETypeFieldNumber = 6;
    private global::Protocol.EntityType eType_;
    /// <summary>
    ///Entity类型。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EntityType EType {
      get { if ((_hasBits0 & 4) != 0) { return eType_; } else { return global::Protocol.EntityType.Empty; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 32;
        eType_ = value;
      }
    }
    /// <summary>Gets whether the "e_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "e_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsETypeDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "e_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "open_gaze_fun" field.</summary>
    public const int OpenGazeFunFieldNumber = 7;
    private bool openGazeFun_;
    /// <summary>
    /// npc开启注视功能。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OpenGazeFun {
      get { if ((_hasBits0 & 8) != 0) { return openGazeFun_; } else { return false; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 64;
        openGazeFun_ = value;
      }
    }
    /// <summary>Gets whether the "open_gaze_fun" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOpenGazeFun {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "open_gaze_fun" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOpenGazeFunDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "open_gaze_fun" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOpenGazeFun() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "gaze_max_angle" field.</summary>
    public const int GazeMaxAngleFieldNumber = 8;
    private float gazeMaxAngle_;
    /// <summary>
    /// npc注视最大角度 默认100度。默认正前方。 根据策划需求。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GazeMaxAngle {
      get { if ((_hasBits0 & 16) != 0) { return gazeMaxAngle_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 128;
        gazeMaxAngle_ = value;
      }
    }
    /// <summary>Gets whether the "gaze_max_angle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGazeMaxAngle {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "gaze_max_angle" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGazeMaxAngleDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "gaze_max_angle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGazeMaxAngle() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "gaze_max_radius" field.</summary>
    public const int GazeMaxRadiusFieldNumber = 9;
    private float gazeMaxRadius_;
    /// <summary>
    /// npc注视扇形最大半径 默认距离为5。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GazeMaxRadius {
      get { if ((_hasBits0 & 32) != 0) { return gazeMaxRadius_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 256;
        gazeMaxRadius_ = value;
      }
    }
    /// <summary>Gets whether the "gaze_max_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGazeMaxRadius {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "gaze_max_radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGazeMaxRadiusDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "gaze_max_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGazeMaxRadius() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "cluster_id" field.</summary>
    public const int ClusterIdFieldNumber = 10;
    private uint clusterId_;
    /// <summary>
    ///关联集群Id，针对集群做表现需求。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClusterId {
      get { if ((_hasBits0 & 64) != 0) { return clusterId_; } else { return 0; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 512;
        clusterId_ = value;
      }
    }
    /// <summary>Gets whether the "cluster_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClusterId {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "cluster_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsClusterIdDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "cluster_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterId() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NpcClusterCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NpcClusterCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NpcId != other.NpcId) return false;
      if (!object.Equals(NpcPos, other.NpcPos)) return false;
      if (!object.Equals(NpcRota, other.NpcRota)) return false;
      if (BornType != other.BornType) return false;
      if (GoapAssetName != other.GoapAssetName) return false;
      if (EType != other.EType) return false;
      if (OpenGazeFun != other.OpenGazeFun) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GazeMaxAngle, other.GazeMaxAngle)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GazeMaxRadius, other.GazeMaxRadius)) return false;
      if (ClusterId != other.ClusterId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNpcId) hash ^= NpcId.GetHashCode();
      if (HasNpcPos) hash ^= NpcPos.GetHashCode();
      if (HasNpcRota) hash ^= NpcRota.GetHashCode();
      if (HasBornType) hash ^= BornType.GetHashCode();
      if (HasGoapAssetName) hash ^= GoapAssetName.GetHashCode();
      if (HasEType) hash ^= EType.GetHashCode();
      if (HasOpenGazeFun) hash ^= OpenGazeFun.GetHashCode();
      if (HasGazeMaxAngle) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GazeMaxAngle);
      if (HasGazeMaxRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GazeMaxRadius);
      if (HasClusterId) hash ^= ClusterId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(NpcId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcPos)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcPosDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(NpcPos);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcRota)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcRotaDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(NpcRota);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(42);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(48);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOpenGazeFun)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        output.WriteRawTag(56);
        output.WriteBool(OpenGazeFun);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(GazeMaxAngle);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(GazeMaxRadius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClusterId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        output.WriteRawTag(80);
        output.WriteUInt32(ClusterId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(NpcId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcPos)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcPosDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(NpcPos);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcRota)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcRotaDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(NpcRota);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(42);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(48);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOpenGazeFun)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        output.WriteRawTag(56);
        output.WriteBool(OpenGazeFun);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(GazeMaxAngle);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(GazeMaxRadius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClusterId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        output.WriteRawTag(80);
        output.WriteUInt32(ClusterId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasNpcId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNpcIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NpcId);
      }
      if (HasNpcPos) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(NpcPos, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasNpcRota) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(NpcRota, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasBornType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BornType);
      }
      if ((scope == pb.WriteScope.FULL && HasGoapAssetName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GoapAssetName);
      }
      if ((scope == pb.WriteScope.FULL && HasEType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EType);
      }
      if ((scope == pb.WriteScope.FULL && HasOpenGazeFun)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasGazeMaxAngle)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasGazeMaxRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasClusterId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClusterId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NpcClusterCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasNpcId) {
        NpcId = other.NpcId;
      }
      if (other.HasNpcPos) {
        if (!HasNpcPos) {
          NpcPos = new global::Protocol.Float3();
        }
        NpcPos.MergeFrom(other.NpcPos);
      }
      if (other.HasNpcRota) {
        if (!HasNpcRota) {
          NpcRota = new global::Protocol.Float3();
        }
        NpcRota.MergeFrom(other.NpcRota);
      }
      if (other.HasBornType) {
        BornType = other.BornType;
      }
      if (other.HasGoapAssetName) {
        GoapAssetName = other.GoapAssetName;
      }
      if (other.HasEType) {
        EType = other.EType;
      }
      if (other.HasOpenGazeFun) {
        OpenGazeFun = other.OpenGazeFun;
      }
      if (other.HasGazeMaxAngle) {
        GazeMaxAngle = other.GazeMaxAngle;
      }
      if (other.HasGazeMaxRadius) {
        GazeMaxRadius = other.GazeMaxRadius;
      }
      if (other.HasClusterId) {
        ClusterId = other.ClusterId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NpcId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasNpcPos) {
              NpcPos = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcPos);
            break;
          }
          case 26: {
            if (!HasNpcRota) {
              NpcRota = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcRota);
            break;
          }
          case 32: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 42: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 48: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 56: {
            OpenGazeFun = input.ReadBool();
            break;
          }
          case 69: {
            GazeMaxAngle = input.ReadFloat();
            break;
          }
          case 77: {
            GazeMaxRadius = input.ReadFloat();
            break;
          }
          case 80: {
            ClusterId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            NpcId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasNpcPos) {
              NpcPos = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcPos);
            break;
          }
          case 26: {
            if (!HasNpcRota) {
              NpcRota = new global::Protocol.Float3();
            }
            input.ReadMessage(NpcRota);
            break;
          }
          case 32: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 42: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 48: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 56: {
            OpenGazeFun = input.ReadBool();
            break;
          }
          case 69: {
            GazeMaxAngle = input.ReadFloat();
            break;
          }
          case 77: {
            GazeMaxRadius = input.ReadFloat();
            break;
          }
          case 80: {
            ClusterId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///npc注视点配置
  /// </summary>
  public sealed partial class NpcGazePoint : pb::IMessage<NpcGazePoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NpcGazePoint> _parser = new pb::MessageParser<NpcGazePoint>(() => new NpcGazePoint());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NpcGazePoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcGazePoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcGazePoint(NpcGazePoint other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      lookPriority_ = other.lookPriority_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcGazePoint Clone() {
      return new NpcGazePoint(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 1;
    private global::Protocol.Float3 postion_;
    /// <summary>
    ///注视点位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 2;
    private global::Protocol.Float3 rotation_;
    /// <summary>
    ///注视点旋转角度
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "look_priority" field.</summary>
    public const int LookPriorityFieldNumber = 3;
    private uint lookPriority_;
    /// <summary>
    ///注视点被注视优先级
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint LookPriority {
      get { if ((_hasBits0 & 1) != 0) { return lookPriority_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        lookPriority_ = value;
      }
    }
    /// <summary>Gets whether the "look_priority" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLookPriority {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "look_priority" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLookPriorityDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "look_priority" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLookPriority() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NpcGazePoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NpcGazePoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (LookPriority != other.LookPriority) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasLookPriority) hash ^= LookPriority.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLookPriority)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLookPriorityDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(LookPriority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLookPriority)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLookPriorityDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(LookPriority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasLookPriority)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLookPriorityDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LookPriority);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NpcGazePoint other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasLookPriority) {
        LookPriority = other.LookPriority;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            LookPriority = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            LookPriority = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///npc出生配置
  /// </summary>
  public sealed partial class NpcBornCfg : pb::IMessage<NpcBornCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NpcBornCfg> _parser = new pb::MessageParser<NpcBornCfg>(() => new NpcBornCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NpcBornCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcBornCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcBornCfg(NpcBornCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      eType_ = other.eType_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      bornType_ = other.bornType_;
      clueAreaId_ = other.clueAreaId_;
      wayMapId_ = other.wayMapId_;
      focusAreaId_ = other.focusAreaId_;
      guardAreaId_ = other.guardAreaId_;
      isTempClueNpc_ = other.isTempClueNpc_;
      npcCfgId_ = other.npcCfgId_;
      subType_ = other.subType_;
      wayPointType_ = other.wayPointType_;
      npcMoveSpeed_ = other.npcMoveSpeed_;
      useBtAgent_ = other.useBtAgent_;
      preMinStandTime_ = other.preMinStandTime_;
      preMaxStandTime_ = other.preMaxStandTime_;
      bornLinkId_ = other.bornLinkId_;
      groupId_ = other.groupId_;
      delayBornTime_ = other.delayBornTime_;
      goapAssetName_ = other.goapAssetName_;
      architectureNpc_ = other.architectureNpc_;
      architectureBindId_ = other.architectureBindId_;
      openGazeFun_ = other.openGazeFun_;
      gazeMaxAngle_ = other.gazeMaxAngle_;
      gazeMaxRadius_ = other.gazeMaxRadius_;
      clusterId_ = other.clusterId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NpcBornCfg Clone() {
      return new NpcBornCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "e_type" field.</summary>
    public const int ETypeFieldNumber = 1;
    private global::Protocol.EntityType eType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.EntityType EType {
      get { if ((_hasBits0 & 1) != 0) { return eType_; } else { return global::Protocol.EntityType.Empty; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        eType_ = value;
      }
    }
    /// <summary>Gets whether the "e_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "e_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsETypeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "e_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 3;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "born_type" field.</summary>
    public const int BornTypeFieldNumber = 4;
    private global::Protocol.BornType bornType_;
    /// <summary>
    ///出生类型，是否是动态出生、立即出生
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BornType BornType {
      get { if ((_hasBits0 & 2) != 0) { return bornType_; } else { return global::Protocol.BornType.BtRightNow; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        bornType_ = value;
      }
    }
    /// <summary>Gets whether the "born_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "born_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornTypeDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "born_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "clue_area_id" field.</summary>
    public const int ClueAreaIdFieldNumber = 5;
    private uint clueAreaId_;
    /// <summary>
    ///所属区域Id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClueAreaId {
      get { if ((_hasBits0 & 4) != 0) { return clueAreaId_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 16;
        clueAreaId_ = value;
      }
    }
    /// <summary>Gets whether the "clue_area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClueAreaId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "clue_area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsClueAreaIdDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "clue_area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClueAreaId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "way_map_id" field.</summary>
    public const int WayMapIdFieldNumber = 6;
    private uint wayMapId_;
    /// <summary>
    ///所属路点类型 0表示所有，TODO：其他可配置组合
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint WayMapId {
      get { if ((_hasBits0 & 8) != 0) { return wayMapId_; } else { return 0; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 32;
        wayMapId_ = value;
      }
    }
    /// <summary>Gets whether the "way_map_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWayMapId {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "way_map_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWayMapIdDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "way_map_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWayMapId() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "focus_area_id" field.</summary>
    public const int FocusAreaIdFieldNumber = 7;
    private uint focusAreaId_;
    /// <summary>
    ///摊贩关联的藏匿区Id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint FocusAreaId {
      get { if ((_hasBits0 & 16) != 0) { return focusAreaId_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 64;
        focusAreaId_ = value;
      }
    }
    /// <summary>Gets whether the "focus_area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFocusAreaId {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "focus_area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFocusAreaIdDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "focus_area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFocusAreaId() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "guard_area_id" field.</summary>
    public const int GuardAreaIdFieldNumber = 8;
    private uint guardAreaId_;
    /// <summary>
    ///警卫关联的巡逻区域id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint GuardAreaId {
      get { if ((_hasBits0 & 32) != 0) { return guardAreaId_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 128;
        guardAreaId_ = value;
      }
    }
    /// <summary>Gets whether the "guard_area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGuardAreaId {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "guard_area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGuardAreaIdDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "guard_area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGuardAreaId() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "is_temp_clue_npc" field.</summary>
    public const int IsTempClueNpcFieldNumber = 9;
    private bool isTempClueNpc_;
    /// <summary>
    ///是否是临时线索npc
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTempClueNpc {
      get { if ((_hasBits0 & 64) != 0) { return isTempClueNpc_; } else { return false; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 256;
        isTempClueNpc_ = value;
      }
    }
    /// <summary>Gets whether the "is_temp_clue_npc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsTempClueNpc {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "is_temp_clue_npc" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsTempClueNpcDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "is_temp_clue_npc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsTempClueNpc() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "npc_cfg_id" field.</summary>
    public const int NpcCfgIdFieldNumber = 10;
    private uint npcCfgId_;
    /// <summary>
    ///npc配置id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NpcCfgId {
      get { if ((_hasBits0 & 128) != 0) { return npcCfgId_; } else { return 0; } }
      set {
        _hasBits0 |= 128;
        _dirtyBits0 |= 512;
        npcCfgId_ = value;
      }
    }
    /// <summary>Gets whether the "npc_cfg_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcCfgId {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Gets whether the "npc_cfg_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcCfgIdDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "npc_cfg_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcCfgId() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "sub_type" field.</summary>
    public const int SubTypeFieldNumber = 11;
    private global::Protocol.NpcSubType subType_;
    /// <summary>
    ///角色子类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.NpcSubType SubType {
      get { if ((_hasBits0 & 256) != 0) { return subType_; } else { return global::Protocol.NpcSubType.NstUnkown; } }
      set {
        _hasBits0 |= 256;
        _dirtyBits0 |= 1024;
        subType_ = value;
      }
    }
    /// <summary>Gets whether the "sub_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubType {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Gets whether the "sub_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSubTypeDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "sub_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubType() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "way_point_type" field.</summary>
    public const int WayPointTypeFieldNumber = 12;
    private uint wayPointType_;
    /// <summary>
    ///路点类型 0表示人，1代表船
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint WayPointType {
      get { if ((_hasBits0 & 512) != 0) { return wayPointType_; } else { return 0; } }
      set {
        _hasBits0 |= 512;
        _dirtyBits0 |= 2048;
        wayPointType_ = value;
      }
    }
    /// <summary>Gets whether the "way_point_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWayPointType {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Gets whether the "way_point_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWayPointTypeDirty {
      get { return (_dirtyBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "way_point_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWayPointType() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "npc_move_speed" field.</summary>
    public const int NpcMoveSpeedFieldNumber = 13;
    private float npcMoveSpeed_;
    /// <summary>
    ///npc移动速度
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float NpcMoveSpeed {
      get { if ((_hasBits0 & 1024) != 0) { return npcMoveSpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 1024;
        _dirtyBits0 |= 4096;
        npcMoveSpeed_ = value;
      }
    }
    /// <summary>Gets whether the "npc_move_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNpcMoveSpeed {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Gets whether the "npc_move_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNpcMoveSpeedDirty {
      get { return (_dirtyBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "npc_move_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNpcMoveSpeed() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "use_bt_agent" field.</summary>
    public const int UseBtAgentFieldNumber = 14;
    private bool useBtAgent_;
    /// <summary>
    ///是否使用行为树
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseBtAgent {
      get { if ((_hasBits0 & 2048) != 0) { return useBtAgent_; } else { return false; } }
      set {
        _hasBits0 |= 2048;
        _dirtyBits0 |= 8192;
        useBtAgent_ = value;
      }
    }
    /// <summary>Gets whether the "use_bt_agent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUseBtAgent {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Gets whether the "use_bt_agent" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsUseBtAgentDirty {
      get { return (_dirtyBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "use_bt_agent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUseBtAgent() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "pre_min_stand_time" field.</summary>
    public const int PreMinStandTimeFieldNumber = 15;
    private float preMinStandTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PreMinStandTime {
      get { if ((_hasBits0 & 4096) != 0) { return preMinStandTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 4096;
        _dirtyBits0 |= 16384;
        preMinStandTime_ = value;
      }
    }
    /// <summary>Gets whether the "pre_min_stand_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPreMinStandTime {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Gets whether the "pre_min_stand_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPreMinStandTimeDirty {
      get { return (_dirtyBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "pre_min_stand_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPreMinStandTime() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "pre_max_stand_time" field.</summary>
    public const int PreMaxStandTimeFieldNumber = 16;
    private float preMaxStandTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PreMaxStandTime {
      get { if ((_hasBits0 & 8192) != 0) { return preMaxStandTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 8192;
        _dirtyBits0 |= 32768;
        preMaxStandTime_ = value;
      }
    }
    /// <summary>Gets whether the "pre_max_stand_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPreMaxStandTime {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Gets whether the "pre_max_stand_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPreMaxStandTimeDirty {
      get { return (_dirtyBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "pre_max_stand_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPreMaxStandTime() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "born_link_id" field.</summary>
    public const int BornLinkIdFieldNumber = 17;
    private uint bornLinkId_;
    /// <summary>
    ///出生相关ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BornLinkId {
      get { if ((_hasBits0 & 16384) != 0) { return bornLinkId_; } else { return 0; } }
      set {
        _hasBits0 |= 16384;
        _dirtyBits0 |= 65536;
        bornLinkId_ = value;
      }
    }
    /// <summary>Gets whether the "born_link_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornLinkId {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Gets whether the "born_link_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornLinkIdDirty {
      get { return (_dirtyBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "born_link_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornLinkId() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "group_id" field.</summary>
    public const int GroupIdFieldNumber = 18;
    private uint groupId_;
    /// <summary>
    ///所属组Id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint GroupId {
      get { if ((_hasBits0 & 32768) != 0) { return groupId_; } else { return 0; } }
      set {
        _hasBits0 |= 32768;
        _dirtyBits0 |= 131072;
        groupId_ = value;
      }
    }
    /// <summary>Gets whether the "group_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGroupId {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Gets whether the "group_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGroupIdDirty {
      get { return (_dirtyBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "group_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGroupId() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "delay_born_time" field.</summary>
    public const int DelayBornTimeFieldNumber = 19;
    private float delayBornTime_;
    /// <summary>
    ///延迟出生时间
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DelayBornTime {
      get { if ((_hasBits0 & 65536) != 0) { return delayBornTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 65536;
        _dirtyBits0 |= 262144;
        delayBornTime_ = value;
      }
    }
    /// <summary>Gets whether the "delay_born_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDelayBornTime {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Gets whether the "delay_born_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDelayBornTimeDirty {
      get { return (_dirtyBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "delay_born_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDelayBornTime() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "goap_asset_name" field.</summary>
    public const int GoapAssetNameFieldNumber = 20;
    private string goapAssetName_;
    /// <summary>
    ///Goap配置名称
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GoapAssetName {
      get { return goapAssetName_ ?? ""; }
      set {
        goapAssetName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "goap_asset_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGoapAssetName {
      get { return goapAssetName_ != null; }
    }
    /// <summary>Gets whether the "goap_asset_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGoapAssetNameDirty {
      get { return (_dirtyBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "goap_asset_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGoapAssetName() {
      goapAssetName_ = null;
    }

    /// <summary>Field number for the "architecture_npc" field.</summary>
    public const int ArchitectureNpcFieldNumber = 21;
    private bool architectureNpc_;
    /// <summary>
    ///是否建筑Npc，摊贩等 无需寻路Npc
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ArchitectureNpc {
      get { if ((_hasBits0 & 131072) != 0) { return architectureNpc_; } else { return false; } }
      set {
        _hasBits0 |= 131072;
        _dirtyBits0 |= 1048576;
        architectureNpc_ = value;
      }
    }
    /// <summary>Gets whether the "architecture_npc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasArchitectureNpc {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Gets whether the "architecture_npc" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsArchitectureNpcDirty {
      get { return (_dirtyBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "architecture_npc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearArchitectureNpc() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "architecture_bind_id" field.</summary>
    public const int ArchitectureBindIdFieldNumber = 22;
    private uint architectureBindId_;
    /// <summary>
    ///建筑Npc， 关联绑定的建筑Logic Id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ArchitectureBindId {
      get { if ((_hasBits0 & 262144) != 0) { return architectureBindId_; } else { return 0; } }
      set {
        _hasBits0 |= 262144;
        _dirtyBits0 |= 2097152;
        architectureBindId_ = value;
      }
    }
    /// <summary>Gets whether the "architecture_bind_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasArchitectureBindId {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Gets whether the "architecture_bind_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsArchitectureBindIdDirty {
      get { return (_dirtyBits0 & 2097152) != 0; }
    }
    /// <summary>Clears the value of the "architecture_bind_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearArchitectureBindId() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "open_gaze_fun" field.</summary>
    public const int OpenGazeFunFieldNumber = 23;
    private bool openGazeFun_;
    /// <summary>
    /// npc开启注视功能
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OpenGazeFun {
      get { if ((_hasBits0 & 524288) != 0) { return openGazeFun_; } else { return false; } }
      set {
        _hasBits0 |= 524288;
        _dirtyBits0 |= 4194304;
        openGazeFun_ = value;
      }
    }
    /// <summary>Gets whether the "open_gaze_fun" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOpenGazeFun {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Gets whether the "open_gaze_fun" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOpenGazeFunDirty {
      get { return (_dirtyBits0 & 4194304) != 0; }
    }
    /// <summary>Clears the value of the "open_gaze_fun" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOpenGazeFun() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "gaze_max_angle" field.</summary>
    public const int GazeMaxAngleFieldNumber = 24;
    private float gazeMaxAngle_;
    /// <summary>
    /// npc注视最大角度 默认100度。默认正前方。 根据策划需求。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GazeMaxAngle {
      get { if ((_hasBits0 & 1048576) != 0) { return gazeMaxAngle_; } else { return 0F; } }
      set {
        _hasBits0 |= 1048576;
        _dirtyBits0 |= 8388608;
        gazeMaxAngle_ = value;
      }
    }
    /// <summary>Gets whether the "gaze_max_angle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGazeMaxAngle {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Gets whether the "gaze_max_angle" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGazeMaxAngleDirty {
      get { return (_dirtyBits0 & 8388608) != 0; }
    }
    /// <summary>Clears the value of the "gaze_max_angle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGazeMaxAngle() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "gaze_max_radius" field.</summary>
    public const int GazeMaxRadiusFieldNumber = 25;
    private float gazeMaxRadius_;
    /// <summary>
    /// npc注视扇形最大半径 默认距离为5.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GazeMaxRadius {
      get { if ((_hasBits0 & 2097152) != 0) { return gazeMaxRadius_; } else { return 0F; } }
      set {
        _hasBits0 |= 2097152;
        _dirtyBits0 |= 16777216;
        gazeMaxRadius_ = value;
      }
    }
    /// <summary>Gets whether the "gaze_max_radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGazeMaxRadius {
      get { return (_hasBits0 & 2097152) != 0; }
    }
    /// <summary>Gets whether the "gaze_max_radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGazeMaxRadiusDirty {
      get { return (_dirtyBits0 & 16777216) != 0; }
    }
    /// <summary>Clears the value of the "gaze_max_radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGazeMaxRadius() {
      _hasBits0 &= ~2097152;
    }

    /// <summary>Field number for the "cluster_id" field.</summary>
    public const int ClusterIdFieldNumber = 26;
    private uint clusterId_;
    /// <summary>
    /// npc集群Id，0默认不属于集群。针对集群做表现需求。
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClusterId {
      get { if ((_hasBits0 & 4194304) != 0) { return clusterId_; } else { return 0; } }
      set {
        _hasBits0 |= 4194304;
        _dirtyBits0 |= 33554432;
        clusterId_ = value;
      }
    }
    /// <summary>Gets whether the "cluster_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClusterId {
      get { return (_hasBits0 & 4194304) != 0; }
    }
    /// <summary>Gets whether the "cluster_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsClusterIdDirty {
      get { return (_dirtyBits0 & 33554432) != 0; }
    }
    /// <summary>Clears the value of the "cluster_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterId() {
      _hasBits0 &= ~4194304;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NpcBornCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NpcBornCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EType != other.EType) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (BornType != other.BornType) return false;
      if (ClueAreaId != other.ClueAreaId) return false;
      if (WayMapId != other.WayMapId) return false;
      if (FocusAreaId != other.FocusAreaId) return false;
      if (GuardAreaId != other.GuardAreaId) return false;
      if (IsTempClueNpc != other.IsTempClueNpc) return false;
      if (NpcCfgId != other.NpcCfgId) return false;
      if (SubType != other.SubType) return false;
      if (WayPointType != other.WayPointType) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(NpcMoveSpeed, other.NpcMoveSpeed)) return false;
      if (UseBtAgent != other.UseBtAgent) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PreMinStandTime, other.PreMinStandTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PreMaxStandTime, other.PreMaxStandTime)) return false;
      if (BornLinkId != other.BornLinkId) return false;
      if (GroupId != other.GroupId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DelayBornTime, other.DelayBornTime)) return false;
      if (GoapAssetName != other.GoapAssetName) return false;
      if (ArchitectureNpc != other.ArchitectureNpc) return false;
      if (ArchitectureBindId != other.ArchitectureBindId) return false;
      if (OpenGazeFun != other.OpenGazeFun) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GazeMaxAngle, other.GazeMaxAngle)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GazeMaxRadius, other.GazeMaxRadius)) return false;
      if (ClusterId != other.ClusterId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEType) hash ^= EType.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasBornType) hash ^= BornType.GetHashCode();
      if (HasClueAreaId) hash ^= ClueAreaId.GetHashCode();
      if (HasWayMapId) hash ^= WayMapId.GetHashCode();
      if (HasFocusAreaId) hash ^= FocusAreaId.GetHashCode();
      if (HasGuardAreaId) hash ^= GuardAreaId.GetHashCode();
      if (HasIsTempClueNpc) hash ^= IsTempClueNpc.GetHashCode();
      if (HasNpcCfgId) hash ^= NpcCfgId.GetHashCode();
      if (HasSubType) hash ^= SubType.GetHashCode();
      if (HasWayPointType) hash ^= WayPointType.GetHashCode();
      if (HasNpcMoveSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(NpcMoveSpeed);
      if (HasUseBtAgent) hash ^= UseBtAgent.GetHashCode();
      if (HasPreMinStandTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PreMinStandTime);
      if (HasPreMaxStandTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PreMaxStandTime);
      if (HasBornLinkId) hash ^= BornLinkId.GetHashCode();
      if (HasGroupId) hash ^= GroupId.GetHashCode();
      if (HasDelayBornTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DelayBornTime);
      if (HasGoapAssetName) hash ^= GoapAssetName.GetHashCode();
      if (HasArchitectureNpc) hash ^= ArchitectureNpc.GetHashCode();
      if (HasArchitectureBindId) hash ^= ArchitectureBindId.GetHashCode();
      if (HasOpenGazeFun) hash ^= OpenGazeFun.GetHashCode();
      if (HasGazeMaxAngle) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GazeMaxAngle);
      if (HasGazeMaxRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GazeMaxRadius);
      if (HasClusterId) hash ^= ClusterId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClueAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClueAreaIdDirty)) {
        output.WriteRawTag(40);
        output.WriteUInt32(ClueAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(WayMapId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFocusAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFocusAreaIdDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(FocusAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGuardAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        output.WriteRawTag(64);
        output.WriteUInt32(GuardAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsTempClueNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsTempClueNpcDirty)) {
        output.WriteRawTag(72);
        output.WriteBool(IsTempClueNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcCfgId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcCfgIdDirty)) {
        output.WriteRawTag(80);
        output.WriteUInt32(NpcCfgId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(88);
        output.WriteEnum((int) SubType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayPointType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayPointTypeDirty)) {
        output.WriteRawTag(96);
        output.WriteUInt32(WayPointType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcMoveSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcMoveSpeedDirty)) {
        output.WriteRawTag(109);
        output.WriteFloat(NpcMoveSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUseBtAgent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUseBtAgentDirty)) {
        output.WriteRawTag(112);
        output.WriteBool(UseBtAgent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPreMinStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPreMinStandTimeDirty)) {
        output.WriteRawTag(125);
        output.WriteFloat(PreMinStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPreMaxStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPreMaxStandTimeDirty)) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(PreMaxStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornLinkId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornLinkIdDirty)) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(BornLinkId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGroupId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGroupIdDirty)) {
        output.WriteRawTag(144, 1);
        output.WriteUInt32(GroupId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDelayBornTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDelayBornTimeDirty)) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(DelayBornTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(162, 1);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureNpcDirty)) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ArchitectureNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureBindId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureBindIdDirty)) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(ArchitectureBindId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOpenGazeFun)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        output.WriteRawTag(184, 1);
        output.WriteBool(OpenGazeFun);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(GazeMaxAngle);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(GazeMaxRadius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClusterId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        output.WriteRawTag(208, 1);
        output.WriteUInt32(ClusterId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasEType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) EType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(32);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClueAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClueAreaIdDirty)) {
        output.WriteRawTag(40);
        output.WriteUInt32(ClueAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(WayMapId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasFocusAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsFocusAreaIdDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(FocusAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGuardAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        output.WriteRawTag(64);
        output.WriteUInt32(GuardAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsTempClueNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsTempClueNpcDirty)) {
        output.WriteRawTag(72);
        output.WriteBool(IsTempClueNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcCfgId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcCfgIdDirty)) {
        output.WriteRawTag(80);
        output.WriteUInt32(NpcCfgId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(88);
        output.WriteEnum((int) SubType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayPointType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayPointTypeDirty)) {
        output.WriteRawTag(96);
        output.WriteUInt32(WayPointType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNpcMoveSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNpcMoveSpeedDirty)) {
        output.WriteRawTag(109);
        output.WriteFloat(NpcMoveSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasUseBtAgent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUseBtAgentDirty)) {
        output.WriteRawTag(112);
        output.WriteBool(UseBtAgent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPreMinStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPreMinStandTimeDirty)) {
        output.WriteRawTag(125);
        output.WriteFloat(PreMinStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPreMaxStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPreMaxStandTimeDirty)) {
        output.WriteRawTag(133, 1);
        output.WriteFloat(PreMaxStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornLinkId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornLinkIdDirty)) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(BornLinkId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGroupId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGroupIdDirty)) {
        output.WriteRawTag(144, 1);
        output.WriteUInt32(GroupId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDelayBornTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDelayBornTimeDirty)) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(DelayBornTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGoapAssetName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        output.WriteRawTag(162, 1);
        output.WriteString(GoapAssetName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureNpc)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureNpcDirty)) {
        output.WriteRawTag(168, 1);
        output.WriteBool(ArchitectureNpc);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasArchitectureBindId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureBindIdDirty)) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(ArchitectureBindId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOpenGazeFun)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        output.WriteRawTag(184, 1);
        output.WriteBool(OpenGazeFun);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        output.WriteRawTag(197, 1);
        output.WriteFloat(GazeMaxAngle);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGazeMaxRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        output.WriteRawTag(205, 1);
        output.WriteFloat(GazeMaxRadius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClusterId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        output.WriteRawTag(208, 1);
        output.WriteUInt32(ClusterId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasEType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsETypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EType);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasBornType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BornType);
      }
      if ((scope == pb.WriteScope.FULL && HasClueAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsClueAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClueAreaId);
      }
      if ((scope == pb.WriteScope.FULL && HasWayMapId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WayMapId);
      }
      if ((scope == pb.WriteScope.FULL && HasFocusAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsFocusAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FocusAreaId);
      }
      if ((scope == pb.WriteScope.FULL && HasGuardAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GuardAreaId);
      }
      if ((scope == pb.WriteScope.FULL && HasIsTempClueNpc)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsTempClueNpcDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasNpcCfgId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNpcCfgIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NpcCfgId);
      }
      if ((scope == pb.WriteScope.FULL && HasSubType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SubType);
      }
      if ((scope == pb.WriteScope.FULL && HasWayPointType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWayPointTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WayPointType);
      }
      if ((scope == pb.WriteScope.FULL && HasNpcMoveSpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNpcMoveSpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasUseBtAgent)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsUseBtAgentDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasPreMinStandTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPreMinStandTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasPreMaxStandTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPreMaxStandTimeDirty)) {
        size += 2 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasBornLinkId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornLinkIdDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(BornLinkId);
      }
      if ((scope == pb.WriteScope.FULL && HasGroupId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGroupIdDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(GroupId);
      }
      if ((scope == pb.WriteScope.FULL && HasDelayBornTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsDelayBornTimeDirty)) {
        size += 2 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasGoapAssetName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGoapAssetNameDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(GoapAssetName);
      }
      if ((scope == pb.WriteScope.FULL && HasArchitectureNpc)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureNpcDirty)) {
        size += 2 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasArchitectureBindId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsArchitectureBindIdDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(ArchitectureBindId);
      }
      if ((scope == pb.WriteScope.FULL && HasOpenGazeFun)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOpenGazeFunDirty)) {
        size += 2 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasGazeMaxAngle)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxAngleDirty)) {
        size += 2 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasGazeMaxRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGazeMaxRadiusDirty)) {
        size += 2 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasClusterId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsClusterIdDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(ClusterId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NpcBornCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasEType) {
        EType = other.EType;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasBornType) {
        BornType = other.BornType;
      }
      if (other.HasClueAreaId) {
        ClueAreaId = other.ClueAreaId;
      }
      if (other.HasWayMapId) {
        WayMapId = other.WayMapId;
      }
      if (other.HasFocusAreaId) {
        FocusAreaId = other.FocusAreaId;
      }
      if (other.HasGuardAreaId) {
        GuardAreaId = other.GuardAreaId;
      }
      if (other.HasIsTempClueNpc) {
        IsTempClueNpc = other.IsTempClueNpc;
      }
      if (other.HasNpcCfgId) {
        NpcCfgId = other.NpcCfgId;
      }
      if (other.HasSubType) {
        SubType = other.SubType;
      }
      if (other.HasWayPointType) {
        WayPointType = other.WayPointType;
      }
      if (other.HasNpcMoveSpeed) {
        NpcMoveSpeed = other.NpcMoveSpeed;
      }
      if (other.HasUseBtAgent) {
        UseBtAgent = other.UseBtAgent;
      }
      if (other.HasPreMinStandTime) {
        PreMinStandTime = other.PreMinStandTime;
      }
      if (other.HasPreMaxStandTime) {
        PreMaxStandTime = other.PreMaxStandTime;
      }
      if (other.HasBornLinkId) {
        BornLinkId = other.BornLinkId;
      }
      if (other.HasGroupId) {
        GroupId = other.GroupId;
      }
      if (other.HasDelayBornTime) {
        DelayBornTime = other.DelayBornTime;
      }
      if (other.HasGoapAssetName) {
        GoapAssetName = other.GoapAssetName;
      }
      if (other.HasArchitectureNpc) {
        ArchitectureNpc = other.ArchitectureNpc;
      }
      if (other.HasArchitectureBindId) {
        ArchitectureBindId = other.ArchitectureBindId;
      }
      if (other.HasOpenGazeFun) {
        OpenGazeFun = other.OpenGazeFun;
      }
      if (other.HasGazeMaxAngle) {
        GazeMaxAngle = other.GazeMaxAngle;
      }
      if (other.HasGazeMaxRadius) {
        GazeMaxRadius = other.GazeMaxRadius;
      }
      if (other.HasClusterId) {
        ClusterId = other.ClusterId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 40: {
            ClueAreaId = input.ReadUInt32();
            break;
          }
          case 48: {
            WayMapId = input.ReadUInt32();
            break;
          }
          case 56: {
            FocusAreaId = input.ReadUInt32();
            break;
          }
          case 64: {
            GuardAreaId = input.ReadUInt32();
            break;
          }
          case 72: {
            IsTempClueNpc = input.ReadBool();
            break;
          }
          case 80: {
            NpcCfgId = input.ReadUInt32();
            break;
          }
          case 88: {
            SubType = (global::Protocol.NpcSubType) input.ReadEnum();
            break;
          }
          case 96: {
            WayPointType = input.ReadUInt32();
            break;
          }
          case 109: {
            NpcMoveSpeed = input.ReadFloat();
            break;
          }
          case 112: {
            UseBtAgent = input.ReadBool();
            break;
          }
          case 125: {
            PreMinStandTime = input.ReadFloat();
            break;
          }
          case 133: {
            PreMaxStandTime = input.ReadFloat();
            break;
          }
          case 136: {
            BornLinkId = input.ReadUInt32();
            break;
          }
          case 144: {
            GroupId = input.ReadUInt32();
            break;
          }
          case 157: {
            DelayBornTime = input.ReadFloat();
            break;
          }
          case 162: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 168: {
            ArchitectureNpc = input.ReadBool();
            break;
          }
          case 176: {
            ArchitectureBindId = input.ReadUInt32();
            break;
          }
          case 184: {
            OpenGazeFun = input.ReadBool();
            break;
          }
          case 197: {
            GazeMaxAngle = input.ReadFloat();
            break;
          }
          case 205: {
            GazeMaxRadius = input.ReadFloat();
            break;
          }
          case 208: {
            ClusterId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EType = (global::Protocol.EntityType) input.ReadEnum();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 26: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 32: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 40: {
            ClueAreaId = input.ReadUInt32();
            break;
          }
          case 48: {
            WayMapId = input.ReadUInt32();
            break;
          }
          case 56: {
            FocusAreaId = input.ReadUInt32();
            break;
          }
          case 64: {
            GuardAreaId = input.ReadUInt32();
            break;
          }
          case 72: {
            IsTempClueNpc = input.ReadBool();
            break;
          }
          case 80: {
            NpcCfgId = input.ReadUInt32();
            break;
          }
          case 88: {
            SubType = (global::Protocol.NpcSubType) input.ReadEnum();
            break;
          }
          case 96: {
            WayPointType = input.ReadUInt32();
            break;
          }
          case 109: {
            NpcMoveSpeed = input.ReadFloat();
            break;
          }
          case 112: {
            UseBtAgent = input.ReadBool();
            break;
          }
          case 125: {
            PreMinStandTime = input.ReadFloat();
            break;
          }
          case 133: {
            PreMaxStandTime = input.ReadFloat();
            break;
          }
          case 136: {
            BornLinkId = input.ReadUInt32();
            break;
          }
          case 144: {
            GroupId = input.ReadUInt32();
            break;
          }
          case 157: {
            DelayBornTime = input.ReadFloat();
            break;
          }
          case 162: {
            GoapAssetName = input.ReadString();
            break;
          }
          case 168: {
            ArchitectureNpc = input.ReadBool();
            break;
          }
          case 176: {
            ArchitectureBindId = input.ReadUInt32();
            break;
          }
          case 184: {
            OpenGazeFun = input.ReadBool();
            break;
          }
          case 197: {
            GazeMaxAngle = input.ReadFloat();
            break;
          }
          case 205: {
            GazeMaxRadius = input.ReadFloat();
            break;
          }
          case 208: {
            ClusterId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///路点配置
  /// </summary>
  public sealed partial class WayMapCfg : pb::IMessage<WayMapCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WayMapCfg> _parser = new pb::MessageParser<WayMapCfg>(() => new WayMapCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WayMapCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayMapCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayMapCfg(WayMapCfg other) : this() {
      _dirtyBits0 = other._dirtyBits0;
      points_ = other.points_.Clone();
      lines_ = other.lines_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayMapCfg Clone() {
      return new WayMapCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protocol.WayPointCfg> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Protocol.WayPointCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.WayPointCfg> points_ = new pbc::RepeatedField<global::Protocol.WayPointCfg>();
    /// <summary>
    ///点集合
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.WayPointCfg> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "lines" field.</summary>
    public const int LinesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Protocol.WayLineCfg> _repeated_lines_codec
        = pb::FieldCodec.ForMessage(18, global::Protocol.WayLineCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.WayLineCfg> lines_ = new pbc::RepeatedField<global::Protocol.WayLineCfg>();
    /// <summary>
    ///线集合
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.WayLineCfg> Lines {
      get { return lines_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WayMapCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WayMapCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if(!lines_.Equals(other.lines_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      hash ^= lines_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      points_.WriteTo(output, _repeated_points_codec);
      lines_.WriteTo(output, _repeated_lines_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      points_.WriteTo(ref output, _repeated_points_codec);
      lines_.WriteTo(ref output, _repeated_lines_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      size += lines_.CalculateSize(_repeated_lines_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WayMapCfg other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      lines_.Add(other.lines_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 18: {
            lines_.AddEntriesFrom(input, _repeated_lines_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            points_.AddEntriesFrom(ref input, _repeated_points_codec);
            break;
          }
          case 18: {
            lines_.AddEntriesFrom(ref input, _repeated_lines_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///图  点配置
  /// </summary>
  public sealed partial class WayPointCfg : pb::IMessage<WayPointCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WayPointCfg> _parser = new pb::MessageParser<WayPointCfg>(() => new WayPointCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WayPointCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayPointCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayPointCfg(WayPointCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      id_ = other.id_;
      mapId_ = other.mapId_;
      position_ = other.HasPosition ? other.position_.Clone() : null;
      forward_ = other.HasForward ? other.forward_.Clone() : null;
      minStandTime_ = other.minStandTime_;
      maxStandTime_ = other.maxStandTime_;
      type_ = other.type_;
      lineCount_ = other.lineCount_;
      passLineTime_ = other.passLineTime_;
      needOffset_ = other.needOffset_;
      offsetValue_ = other.offsetValue_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayPointCfg Clone() {
      return new WayPointCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "map_id" field.</summary>
    public const int MapIdFieldNumber = 2;
    private uint mapId_;
    /// <summary>
    ///所属类型ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MapId {
      get { if ((_hasBits0 & 2) != 0) { return mapId_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        mapId_ = value;
      }
    }
    /// <summary>Gets whether the "map_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMapId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "map_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMapIdDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "map_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMapId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 3;
    private global::Protocol.Float3 position_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }
    /// <summary>Gets whether the position field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPosition {
      get { return position_ != null; }
    }
    /// <summary>Clears the value of the position field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPosition() {
      position_ = null;
    }
    /// <summary>Gets whether the "position" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPositionDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "forward" field.</summary>
    public const int ForwardFieldNumber = 4;
    private global::Protocol.Float3 forward_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Forward {
      get { return forward_; }
      set {
        forward_ = value;
      }
    }
    /// <summary>Gets whether the forward field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasForward {
      get { return forward_ != null; }
    }
    /// <summary>Clears the value of the forward field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearForward() {
      forward_ = null;
    }
    /// <summary>Gets whether the "forward" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsForwardDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }

    /// <summary>Field number for the "min_stand_time" field.</summary>
    public const int MinStandTimeFieldNumber = 5;
    private float minStandTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinStandTime {
      get { if ((_hasBits0 & 4) != 0) { return minStandTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 16;
        minStandTime_ = value;
      }
    }
    /// <summary>Gets whether the "min_stand_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMinStandTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "min_stand_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMinStandTimeDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "min_stand_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMinStandTime() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "max_stand_time" field.</summary>
    public const int MaxStandTimeFieldNumber = 6;
    private float maxStandTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxStandTime {
      get { if ((_hasBits0 & 8) != 0) { return maxStandTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 32;
        maxStandTime_ = value;
      }
    }
    /// <summary>Gets whether the "max_stand_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaxStandTime {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "max_stand_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMaxStandTimeDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "max_stand_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaxStandTime() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 7;
    private uint type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Type {
      get { if ((_hasBits0 & 16) != 0) { return type_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 64;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTypeDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "line_count" field.</summary>
    public const int LineCountFieldNumber = 8;
    private uint lineCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint LineCount {
      get { if ((_hasBits0 & 32) != 0) { return lineCount_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 128;
        lineCount_ = value;
      }
    }
    /// <summary>Gets whether the "line_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLineCount {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "line_count" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLineCountDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "line_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLineCount() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "pass_line_time" field.</summary>
    public const int PassLineTimeFieldNumber = 9;
    private float passLineTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PassLineTime {
      get { if ((_hasBits0 & 64) != 0) { return passLineTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 256;
        passLineTime_ = value;
      }
    }
    /// <summary>Gets whether the "pass_line_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPassLineTime {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "pass_line_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPassLineTimeDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "pass_line_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPassLineTime() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "need_offset" field.</summary>
    public const int NeedOffsetFieldNumber = 10;
    private bool needOffset_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NeedOffset {
      get { if ((_hasBits0 & 128) != 0) { return needOffset_; } else { return false; } }
      set {
        _hasBits0 |= 128;
        _dirtyBits0 |= 512;
        needOffset_ = value;
      }
    }
    /// <summary>Gets whether the "need_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNeedOffset {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Gets whether the "need_offset" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNeedOffsetDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "need_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNeedOffset() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "offset_value" field.</summary>
    public const int OffsetValueFieldNumber = 11;
    private float offsetValue_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OffsetValue {
      get { if ((_hasBits0 & 256) != 0) { return offsetValue_; } else { return 0F; } }
      set {
        _hasBits0 |= 256;
        _dirtyBits0 |= 1024;
        offsetValue_ = value;
      }
    }
    /// <summary>Gets whether the "offset_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOffsetValue {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Gets whether the "offset_value" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOffsetValueDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "offset_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOffsetValue() {
      _hasBits0 &= ~256;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WayPointCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WayPointCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (MapId != other.MapId) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Forward, other.Forward)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinStandTime, other.MinStandTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxStandTime, other.MaxStandTime)) return false;
      if (Type != other.Type) return false;
      if (LineCount != other.LineCount) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PassLineTime, other.PassLineTime)) return false;
      if (NeedOffset != other.NeedOffset) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OffsetValue, other.OffsetValue)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasMapId) hash ^= MapId.GetHashCode();
      if (HasPosition) hash ^= Position.GetHashCode();
      if (HasForward) hash ^= Forward.GetHashCode();
      if (HasMinStandTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinStandTime);
      if (HasMaxStandTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxStandTime);
      if (HasType) hash ^= Type.GetHashCode();
      if (HasLineCount) hash ^= LineCount.GetHashCode();
      if (HasPassLineTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PassLineTime);
      if (HasNeedOffset) hash ^= NeedOffset.GetHashCode();
      if (HasOffsetValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OffsetValue);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMapId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMapIdDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(MapId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPositionDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Position);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasForward)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsForwardDirty)) {
        output.WriteRawTag(34);
        output.WriteMessage(Forward);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMinStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMinStandTimeDirty)) {
        output.WriteRawTag(45);
        output.WriteFloat(MinStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxStandTimeDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(MaxStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(Type);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLineCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLineCountDirty)) {
        output.WriteRawTag(64);
        output.WriteUInt32(LineCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPassLineTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPassLineTimeDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(PassLineTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNeedOffset)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNeedOffsetDirty)) {
        output.WriteRawTag(80);
        output.WriteBool(NeedOffset);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOffsetValue)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOffsetValueDirty)) {
        output.WriteRawTag(93);
        output.WriteFloat(OffsetValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMapId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMapIdDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(MapId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPositionDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Position);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasForward)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsForwardDirty)) {
        output.WriteRawTag(34);
        output.WriteMessage(Forward);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMinStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMinStandTimeDirty)) {
        output.WriteRawTag(45);
        output.WriteFloat(MinStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMaxStandTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMaxStandTimeDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(MaxStandTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteUInt32(Type);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLineCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLineCountDirty)) {
        output.WriteRawTag(64);
        output.WriteUInt32(LineCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPassLineTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPassLineTimeDirty)) {
        output.WriteRawTag(77);
        output.WriteFloat(PassLineTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNeedOffset)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNeedOffsetDirty)) {
        output.WriteRawTag(80);
        output.WriteBool(NeedOffset);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOffsetValue)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOffsetValueDirty)) {
        output.WriteRawTag(93);
        output.WriteFloat(OffsetValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if ((scope == pb.WriteScope.FULL && HasMapId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMapIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MapId);
      }
      if (HasPosition) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Position, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if (HasForward) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Forward, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 8;
        } else {
          _dirtyBits0 &= ~8;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasMinStandTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMinStandTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasMaxStandTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMaxStandTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Type);
      }
      if ((scope == pb.WriteScope.FULL && HasLineCount)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLineCountDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LineCount);
      }
      if ((scope == pb.WriteScope.FULL && HasPassLineTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPassLineTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasNeedOffset)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNeedOffsetDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasOffsetValue)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOffsetValueDirty)) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WayPointCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasMapId) {
        MapId = other.MapId;
      }
      if (other.HasPosition) {
        if (!HasPosition) {
          Position = new global::Protocol.Float3();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.HasForward) {
        if (!HasForward) {
          Forward = new global::Protocol.Float3();
        }
        Forward.MergeFrom(other.Forward);
      }
      if (other.HasMinStandTime) {
        MinStandTime = other.MinStandTime;
      }
      if (other.HasMaxStandTime) {
        MaxStandTime = other.MaxStandTime;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLineCount) {
        LineCount = other.LineCount;
      }
      if (other.HasPassLineTime) {
        PassLineTime = other.PassLineTime;
      }
      if (other.HasNeedOffset) {
        NeedOffset = other.NeedOffset;
      }
      if (other.HasOffsetValue) {
        OffsetValue = other.OffsetValue;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            MapId = input.ReadUInt32();
            break;
          }
          case 26: {
            if (!HasPosition) {
              Position = new global::Protocol.Float3();
            }
            input.ReadMessage(Position);
            break;
          }
          case 34: {
            if (!HasForward) {
              Forward = new global::Protocol.Float3();
            }
            input.ReadMessage(Forward);
            break;
          }
          case 45: {
            MinStandTime = input.ReadFloat();
            break;
          }
          case 53: {
            MaxStandTime = input.ReadFloat();
            break;
          }
          case 56: {
            Type = input.ReadUInt32();
            break;
          }
          case 64: {
            LineCount = input.ReadUInt32();
            break;
          }
          case 77: {
            PassLineTime = input.ReadFloat();
            break;
          }
          case 80: {
            NeedOffset = input.ReadBool();
            break;
          }
          case 93: {
            OffsetValue = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            MapId = input.ReadUInt32();
            break;
          }
          case 26: {
            if (!HasPosition) {
              Position = new global::Protocol.Float3();
            }
            input.ReadMessage(Position);
            break;
          }
          case 34: {
            if (!HasForward) {
              Forward = new global::Protocol.Float3();
            }
            input.ReadMessage(Forward);
            break;
          }
          case 45: {
            MinStandTime = input.ReadFloat();
            break;
          }
          case 53: {
            MaxStandTime = input.ReadFloat();
            break;
          }
          case 56: {
            Type = input.ReadUInt32();
            break;
          }
          case 64: {
            LineCount = input.ReadUInt32();
            break;
          }
          case 77: {
            PassLineTime = input.ReadFloat();
            break;
          }
          case 80: {
            NeedOffset = input.ReadBool();
            break;
          }
          case 93: {
            OffsetValue = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///图  线配置
  /// </summary>
  public sealed partial class WayLineCfg : pb::IMessage<WayLineCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WayLineCfg> _parser = new pb::MessageParser<WayLineCfg>(() => new WayLineCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WayLineCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayLineCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayLineCfg(WayLineCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      head_ = other.HasHead ? other.head_.Clone() : null;
      last_ = other.HasLast ? other.last_.Clone() : null;
      cost_ = other.cost_;
      isOneWay_ = other.isOneWay_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WayLineCfg Clone() {
      return new WayLineCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "head" field.</summary>
    public const int HeadFieldNumber = 1;
    private global::Protocol.WayPointCfg head_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.WayPointCfg Head {
      get { return head_; }
      set {
        head_ = value;
      }
    }
    /// <summary>Gets whether the head field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHead {
      get { return head_ != null; }
    }
    /// <summary>Clears the value of the head field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHead() {
      head_ = null;
    }
    /// <summary>Gets whether the "head" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeadDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "last" field.</summary>
    public const int LastFieldNumber = 2;
    private global::Protocol.WayPointCfg last_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.WayPointCfg Last {
      get { return last_; }
      set {
        last_ = value;
      }
    }
    /// <summary>Gets whether the last field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLast {
      get { return last_ != null; }
    }
    /// <summary>Clears the value of the last field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLast() {
      last_ = null;
    }
    /// <summary>Gets whether the "last" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLastDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "cost" field.</summary>
    public const int CostFieldNumber = 3;
    private float cost_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Cost {
      get { if ((_hasBits0 & 1) != 0) { return cost_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        cost_ = value;
      }
    }
    /// <summary>Gets whether the "cost" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCost {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "cost" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCostDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "cost" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCost() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "is_one_way" field.</summary>
    public const int IsOneWayFieldNumber = 4;
    private bool isOneWay_;
    /// <summary>
    ///是否单方向代价
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOneWay {
      get { if ((_hasBits0 & 2) != 0) { return isOneWay_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        isOneWay_ = value;
      }
    }
    /// <summary>Gets whether the "is_one_way" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsOneWay {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "is_one_way" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsOneWayDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "is_one_way" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsOneWay() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WayLineCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WayLineCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Head, other.Head)) return false;
      if (!object.Equals(Last, other.Last)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Cost, other.Cost)) return false;
      if (IsOneWay != other.IsOneWay) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHead) hash ^= Head.GetHashCode();
      if (HasLast) hash ^= Last.GetHashCode();
      if (HasCost) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Cost);
      if (HasIsOneWay) hash ^= IsOneWay.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasHead)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Head);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLast)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLastDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Last);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCost)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCostDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Cost);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsOneWay)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsOneWayDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(IsOneWay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasHead)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Head);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLast)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLastDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Last);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCost)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCostDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Cost);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsOneWay)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsOneWayDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(IsOneWay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasHead) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Head, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasLast) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Last, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasCost)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCostDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasIsOneWay)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsOneWayDirty)) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WayLineCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasHead) {
        if (!HasHead) {
          Head = new global::Protocol.WayPointCfg();
        }
        Head.MergeFrom(other.Head);
      }
      if (other.HasLast) {
        if (!HasLast) {
          Last = new global::Protocol.WayPointCfg();
        }
        Last.MergeFrom(other.Last);
      }
      if (other.HasCost) {
        Cost = other.Cost;
      }
      if (other.HasIsOneWay) {
        IsOneWay = other.IsOneWay;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasHead) {
              Head = new global::Protocol.WayPointCfg();
            }
            input.ReadMessage(Head);
            break;
          }
          case 18: {
            if (!HasLast) {
              Last = new global::Protocol.WayPointCfg();
            }
            input.ReadMessage(Last);
            break;
          }
          case 29: {
            Cost = input.ReadFloat();
            break;
          }
          case 32: {
            IsOneWay = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasHead) {
              Head = new global::Protocol.WayPointCfg();
            }
            input.ReadMessage(Head);
            break;
          }
          case 18: {
            if (!HasLast) {
              Last = new global::Protocol.WayPointCfg();
            }
            input.ReadMessage(Last);
            break;
          }
          case 29: {
            Cost = input.ReadFloat();
            break;
          }
          case 32: {
            IsOneWay = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ThingCfg : pb::IMessage<ThingCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThingCfg> _parser = new pb::MessageParser<ThingCfg>(() => new ThingCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ThingCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingCfg(ThingCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      cfgId_ = other.cfgId_;
      thingType_ = other.thingType_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      collider_ = other.HasCollider ? other.collider_.Clone() : null;
      clueId_ = other.clueId_;
      bornType_ = other.bornType_;
      subType_ = other.subType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingCfg Clone() {
      return new ThingCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "cfg_id" field.</summary>
    public const int CfgIdFieldNumber = 1;
    private uint cfgId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CfgId {
      get { if ((_hasBits0 & 1) != 0) { return cfgId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        cfgId_ = value;
      }
    }
    /// <summary>Gets whether the "cfg_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCfgId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "cfg_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCfgIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "cfg_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCfgId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "thing_type" field.</summary>
    public const int ThingTypeFieldNumber = 2;
    private global::Protocol.ThingType thingType_;
    /// <summary>
    ///物件类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.ThingType ThingType {
      get { if ((_hasBits0 & 2) != 0) { return thingType_; } else { return global::Protocol.ThingType.ThingNone; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        thingType_ = value;
      }
    }
    /// <summary>Gets whether the "thing_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasThingType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "thing_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsThingTypeDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "thing_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearThingType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 3;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 4;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }

    /// <summary>Field number for the "collider" field.</summary>
    public const int ColliderFieldNumber = 5;
    private global::Protocol.BoxColliderData collider_;
    /// <summary>
    ///碰撞盒
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BoxColliderData Collider {
      get { return collider_; }
      set {
        collider_ = value;
      }
    }
    /// <summary>Gets whether the collider field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollider {
      get { return collider_ != null; }
    }
    /// <summary>Clears the value of the collider field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollider() {
      collider_ = null;
    }
    /// <summary>Gets whether the "collider" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsColliderDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    /// <summary>Field number for the "clue_id" field.</summary>
    public const int ClueIdFieldNumber = 6;
    private uint clueId_;
    /// <summary>
    ///大宝箱编号
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClueId {
      get { if ((_hasBits0 & 4) != 0) { return clueId_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 32;
        clueId_ = value;
      }
    }
    /// <summary>Gets whether the "clue_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClueId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "clue_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsClueIdDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "clue_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClueId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "born_type" field.</summary>
    public const int BornTypeFieldNumber = 7;
    private global::Protocol.BornType bornType_;
    /// <summary>
    ///出生类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BornType BornType {
      get { if ((_hasBits0 & 8) != 0) { return bornType_; } else { return global::Protocol.BornType.BtRightNow; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 64;
        bornType_ = value;
      }
    }
    /// <summary>Gets whether the "born_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornType {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "born_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornTypeDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "born_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornType() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "sub_type" field.</summary>
    public const int SubTypeFieldNumber = 8;
    private global::Protocol.ThingSubType subType_;
    /// <summary>
    ///物件子类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.ThingSubType SubType {
      get { if ((_hasBits0 & 16) != 0) { return subType_; } else { return global::Protocol.ThingSubType.ThingUnkown; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 128;
        subType_ = value;
      }
    }
    /// <summary>Gets whether the "sub_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubType {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "sub_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSubTypeDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "sub_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubType() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ThingCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ThingCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CfgId != other.CfgId) return false;
      if (ThingType != other.ThingType) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (!object.Equals(Collider, other.Collider)) return false;
      if (ClueId != other.ClueId) return false;
      if (BornType != other.BornType) return false;
      if (SubType != other.SubType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCfgId) hash ^= CfgId.GetHashCode();
      if (HasThingType) hash ^= ThingType.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasCollider) hash ^= Collider.GetHashCode();
      if (HasClueId) hash ^= ClueId.GetHashCode();
      if (HasBornType) hash ^= BornType.GetHashCode();
      if (HasSubType) hash ^= SubType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasCfgId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCfgIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(CfgId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasThingType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsThingTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ThingType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(34);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Collider);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClueId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClueIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(ClueId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) SubType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasCfgId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCfgIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(CfgId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasThingType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsThingTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ThingType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(26);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(34);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Collider);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasClueId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsClueIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(ClueId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(56);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasSubType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        output.WriteRawTag(64);
        output.WriteEnum((int) SubType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasCfgId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCfgIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CfgId);
      }
      if ((scope == pb.WriteScope.FULL && HasThingType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsThingTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ThingType);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 4;
        } else {
          _dirtyBits0 &= ~4;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 8;
        } else {
          _dirtyBits0 &= ~8;
        }
      }
      if (HasCollider) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Collider, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasClueId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsClueIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClueId);
      }
      if ((scope == pb.WriteScope.FULL && HasBornType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BornType);
      }
      if ((scope == pb.WriteScope.FULL && HasSubType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsSubTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SubType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ThingCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasCfgId) {
        CfgId = other.CfgId;
      }
      if (other.HasThingType) {
        ThingType = other.ThingType;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasCollider) {
        if (!HasCollider) {
          Collider = new global::Protocol.BoxColliderData();
        }
        Collider.MergeFrom(other.Collider);
      }
      if (other.HasClueId) {
        ClueId = other.ClueId;
      }
      if (other.HasBornType) {
        BornType = other.BornType;
      }
      if (other.HasSubType) {
        SubType = other.SubType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CfgId = input.ReadUInt32();
            break;
          }
          case 16: {
            ThingType = (global::Protocol.ThingType) input.ReadEnum();
            break;
          }
          case 26: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 34: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 42: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
          case 48: {
            ClueId = input.ReadUInt32();
            break;
          }
          case 56: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 64: {
            SubType = (global::Protocol.ThingSubType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CfgId = input.ReadUInt32();
            break;
          }
          case 16: {
            ThingType = (global::Protocol.ThingType) input.ReadEnum();
            break;
          }
          case 26: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 34: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 42: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
          case 48: {
            ClueId = input.ReadUInt32();
            break;
          }
          case 56: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 64: {
            SubType = (global::Protocol.ThingSubType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class DropCfg : pb::IMessage<DropCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DropCfg> _parser = new pb::MessageParser<DropCfg>(() => new DropCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DropCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropCfg(DropCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      id_ = other.id_;
      areaId_ = other.areaId_;
      groupSelected_ = other.groupSelected_.Clone();
      dropGroupId_ = other.dropGroupId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropCfg Clone() {
      return new DropCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 1;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 2;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 3;
    private uint id_;
    /// <summary>
    /// ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIdDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "area_id" field.</summary>
    public const int AreaIdFieldNumber = 4;
    private uint areaId_;
    /// <summary>
    /// 区域ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AreaId {
      get { if ((_hasBits0 & 2) != 0) { return areaId_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        areaId_ = value;
      }
    }
    /// <summary>Gets whether the "area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAreaId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAreaIdDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAreaId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "group_selected" field.</summary>
    public const int GroupSelectedFieldNumber = 5;
    private static readonly pb::FieldCodec<uint> _repeated_groupSelected_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> groupSelected_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// 掉落组选择
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> GroupSelected {
      get { return groupSelected_; }
    }

    /// <summary>Field number for the "drop_group_id" field.</summary>
    public const int DropGroupIdFieldNumber = 6;
    private uint dropGroupId_;
    /// <summary>
    /// 区域ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DropGroupId {
      get { if ((_hasBits0 & 4) != 0) { return dropGroupId_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 32;
        dropGroupId_ = value;
      }
    }
    /// <summary>Gets whether the "drop_group_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDropGroupId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "drop_group_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDropGroupIdDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "drop_group_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDropGroupId() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DropCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DropCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (Id != other.Id) return false;
      if (AreaId != other.AreaId) return false;
      if(!groupSelected_.Equals(other.groupSelected_)) return false;
      if (DropGroupId != other.DropGroupId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasId) hash ^= Id.GetHashCode();
      if (HasAreaId) hash ^= AreaId.GetHashCode();
      hash ^= groupSelected_.GetHashCode();
      if (HasDropGroupId) hash ^= DropGroupId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(AreaId);
      }
      groupSelected_.WriteTo(output, _repeated_groupSelected_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasDropGroupId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDropGroupIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(DropGroupId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(AreaId);
      }
      groupSelected_.WriteTo(ref output, _repeated_groupSelected_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasDropGroupId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDropGroupIdDirty)) {
        output.WriteRawTag(48);
        output.WriteUInt32(DropGroupId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if ((scope == pb.WriteScope.FULL && HasAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AreaId);
      }
      size += groupSelected_.CalculateSize(_repeated_groupSelected_codec);
      if ((scope == pb.WriteScope.FULL && HasDropGroupId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsDropGroupIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DropGroupId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DropCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasAreaId) {
        AreaId = other.AreaId;
      }
      groupSelected_.Add(other.groupSelected_);
      if (other.HasDropGroupId) {
        DropGroupId = other.DropGroupId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            Id = input.ReadUInt32();
            break;
          }
          case 32: {
            AreaId = input.ReadUInt32();
            break;
          }
          case 42:
          case 40: {
            groupSelected_.AddEntriesFrom(input, _repeated_groupSelected_codec);
            break;
          }
          case 48: {
            DropGroupId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            Id = input.ReadUInt32();
            break;
          }
          case 32: {
            AreaId = input.ReadUInt32();
            break;
          }
          case 42:
          case 40: {
            groupSelected_.AddEntriesFrom(ref input, _repeated_groupSelected_codec);
            break;
          }
          case 48: {
            DropGroupId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AntidoteScatterCfg : pb::IMessage<AntidoteScatterCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AntidoteScatterCfg> _parser = new pb::MessageParser<AntidoteScatterCfg>(() => new AntidoteScatterCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AntidoteScatterCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AntidoteScatterCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AntidoteScatterCfg(AntidoteScatterCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      bornType_ = other.bornType_;
      modelId_ = other.modelId_;
      collider_ = other.HasCollider ? other.collider_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AntidoteScatterCfg Clone() {
      return new AntidoteScatterCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 1;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 2;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "born_type" field.</summary>
    public const int BornTypeFieldNumber = 3;
    private global::Protocol.BornType bornType_;
    /// <summary>
    /// 出生类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BornType BornType {
      get { if ((_hasBits0 & 1) != 0) { return bornType_; } else { return global::Protocol.BornType.BtRightNow; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        bornType_ = value;
      }
    }
    /// <summary>Gets whether the "born_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBornType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "born_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBornTypeDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "born_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBornType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "model_id" field.</summary>
    public const int ModelIdFieldNumber = 4;
    private uint modelId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ModelId {
      get { if ((_hasBits0 & 2) != 0) { return modelId_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        modelId_ = value;
      }
    }
    /// <summary>Gets whether the "model_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "model_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelIdDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "model_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "collider" field.</summary>
    public const int ColliderFieldNumber = 5;
    private global::Protocol.BoxColliderData collider_;
    /// <summary>
    /// 碰撞盒
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BoxColliderData Collider {
      get { return collider_; }
      set {
        collider_ = value;
      }
    }
    /// <summary>Gets whether the collider field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollider {
      get { return collider_ != null; }
    }
    /// <summary>Clears the value of the collider field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollider() {
      collider_ = null;
    }
    /// <summary>Gets whether the "collider" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsColliderDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AntidoteScatterCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AntidoteScatterCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (BornType != other.BornType) return false;
      if (ModelId != other.ModelId) return false;
      if (!object.Equals(Collider, other.Collider)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasBornType) hash ^= BornType.GetHashCode();
      if (HasModelId) hash ^= ModelId.GetHashCode();
      if (HasCollider) hash ^= Collider.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(24);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(ModelId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Collider);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBornType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        output.WriteRawTag(24);
        output.WriteEnum((int) BornType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(ModelId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCollider)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Collider);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasBornType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBornTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BornType);
      }
      if ((scope == pb.WriteScope.FULL && HasModelId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ModelId);
      }
      if (HasCollider) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Collider, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AntidoteScatterCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasBornType) {
        BornType = other.BornType;
      }
      if (other.HasModelId) {
        ModelId = other.ModelId;
      }
      if (other.HasCollider) {
        if (!HasCollider) {
          Collider = new global::Protocol.BoxColliderData();
        }
        Collider.MergeFrom(other.Collider);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 32: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 24: {
            BornType = (global::Protocol.BornType) input.ReadEnum();
            break;
          }
          case 32: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasCollider) {
              Collider = new global::Protocol.BoxColliderData();
            }
            input.ReadMessage(Collider);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GuardTargetAreaCfg : pb::IMessage<GuardTargetAreaCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GuardTargetAreaCfg> _parser = new pb::MessageParser<GuardTargetAreaCfg>(() => new GuardTargetAreaCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GuardTargetAreaCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GuardTargetAreaCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GuardTargetAreaCfg(GuardTargetAreaCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      id_ = other.id_;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      radius_ = other.radius_;
      guardAreaId_ = other.guardAreaId_;
      forward_ = other.HasForward ? other.forward_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GuardTargetAreaCfg Clone() {
      return new GuardTargetAreaCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 2;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "radius" field.</summary>
    public const int RadiusFieldNumber = 3;
    private float radius_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Radius {
      get { if ((_hasBits0 & 2) != 0) { return radius_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 4;
        radius_ = value;
      }
    }
    /// <summary>Gets whether the "radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRadius {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRadiusDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRadius() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "guard_area_id" field.</summary>
    public const int GuardAreaIdFieldNumber = 4;
    private uint guardAreaId_;
    /// <summary>
    ///警卫关联的巡逻区域id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint GuardAreaId {
      get { if ((_hasBits0 & 4) != 0) { return guardAreaId_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 8;
        guardAreaId_ = value;
      }
    }
    /// <summary>Gets whether the "guard_area_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGuardAreaId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "guard_area_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsGuardAreaIdDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "guard_area_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGuardAreaId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "forward" field.</summary>
    public const int ForwardFieldNumber = 5;
    private global::Protocol.Float3 forward_;
    /// <summary>
    ///警卫朝向
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Forward {
      get { return forward_; }
      set {
        forward_ = value;
      }
    }
    /// <summary>Gets whether the forward field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasForward {
      get { return forward_ != null; }
    }
    /// <summary>Clears the value of the forward field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearForward() {
      forward_ = null;
    }
    /// <summary>Gets whether the "forward" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsForwardDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GuardTargetAreaCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GuardTargetAreaCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Radius, other.Radius)) return false;
      if (GuardAreaId != other.GuardAreaId) return false;
      if (!object.Equals(Forward, other.Forward)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Radius);
      if (HasGuardAreaId) hash ^= GuardAreaId.GetHashCode();
      if (HasForward) hash ^= Forward.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGuardAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(GuardAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasForward)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsForwardDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Forward);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasGuardAreaId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(GuardAreaId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasForward)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsForwardDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(Forward);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasGuardAreaId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsGuardAreaIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GuardAreaId);
      }
      if (HasForward) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Forward, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GuardTargetAreaCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRadius) {
        Radius = other.Radius;
      }
      if (other.HasGuardAreaId) {
        GuardAreaId = other.GuardAreaId;
      }
      if (other.HasForward) {
        if (!HasForward) {
          Forward = new global::Protocol.Float3();
        }
        Forward.MergeFrom(other.Forward);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 29: {
            Radius = input.ReadFloat();
            break;
          }
          case 32: {
            GuardAreaId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasForward) {
              Forward = new global::Protocol.Float3();
            }
            input.ReadMessage(Forward);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 29: {
            Radius = input.ReadFloat();
            break;
          }
          case 32: {
            GuardAreaId = input.ReadUInt32();
            break;
          }
          case 42: {
            if (!HasForward) {
              Forward = new global::Protocol.Float3();
            }
            input.ReadMessage(Forward);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class HookPointCfg : pb::IMessage<HookPointCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HookPointCfg> _parser = new pb::MessageParser<HookPointCfg>(() => new HookPointCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HookPointCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HookPointCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HookPointCfg(HookPointCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      radius_ = other.radius_;
      repulsionDistance_ = other.repulsionDistance_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HookPointCfg Clone() {
      return new HookPointCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 1;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "radius" field.</summary>
    public const int RadiusFieldNumber = 2;
    private float radius_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Radius {
      get { if ((_hasBits0 & 1) != 0) { return radius_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 2;
        radius_ = value;
      }
    }
    /// <summary>Gets whether the "radius" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRadius {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "radius" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRadiusDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "radius" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRadius() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "repulsion_distance" field.</summary>
    public const int RepulsionDistanceFieldNumber = 3;
    private float repulsionDistance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RepulsionDistance {
      get { if ((_hasBits0 & 2) != 0) { return repulsionDistance_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 4;
        repulsionDistance_ = value;
      }
    }
    /// <summary>Gets whether the "repulsion_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRepulsionDistance {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "repulsion_distance" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRepulsionDistanceDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "repulsion_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRepulsionDistance() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HookPointCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HookPointCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Radius, other.Radius)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RepulsionDistance, other.RepulsionDistance)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRadius) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Radius);
      if (HasRepulsionDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RepulsionDistance);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRepulsionDistance)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRepulsionDistanceDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(RepulsionDistance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRadius)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(Radius);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRepulsionDistance)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRepulsionDistanceDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(RepulsionDistance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasRadius)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsRadiusDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasRepulsionDistance)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsRepulsionDistanceDirty)) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HookPointCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRadius) {
        Radius = other.Radius;
      }
      if (other.HasRepulsionDistance) {
        RepulsionDistance = other.RepulsionDistance;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 21: {
            Radius = input.ReadFloat();
            break;
          }
          case 29: {
            RepulsionDistance = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 21: {
            Radius = input.ReadFloat();
            break;
          }
          case 29: {
            RepulsionDistance = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class JumpPointCfg : pb::IMessage<JumpPointCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<JumpPointCfg> _parser = new pb::MessageParser<JumpPointCfg>(() => new JumpPointCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<JumpPointCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JumpPointCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JumpPointCfg(JumpPointCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      postion_ = other.HasPostion ? other.postion_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      width_ = other.width_;
      height_ = other.height_;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JumpPointCfg Clone() {
      return new JumpPointCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "postion" field.</summary>
    public const int PostionFieldNumber = 1;
    private global::Protocol.Float3 postion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set {
        postion_ = value;
      }
    }
    /// <summary>Gets whether the postion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostion {
      get { return postion_ != null; }
    }
    /// <summary>Clears the value of the postion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostion() {
      postion_ = null;
    }
    /// <summary>Gets whether the "postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPostionDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 2;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "width" field.</summary>
    public const int WidthFieldNumber = 3;
    private float width_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Width {
      get { if ((_hasBits0 & 1) != 0) { return width_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        width_ = value;
      }
    }
    /// <summary>Gets whether the "width" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWidth {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "width" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWidthDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "width" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWidth() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "height" field.</summary>
    public const int HeightFieldNumber = 4;
    private float height_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Height {
      get { if ((_hasBits0 & 2) != 0) { return height_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        height_ = value;
      }
    }
    /// <summary>Gets whether the "height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeight {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "height" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeightDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeight() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 5;
    private int type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Type {
      get { if ((_hasBits0 & 4) != 0) { return type_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 16;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTypeDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as JumpPointCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(JumpPointCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Postion, other.Postion)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Width, other.Width)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Height, other.Height)) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPostion) hash ^= Postion.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasWidth) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Width);
      if (HasHeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Height);
      if (HasType) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWidth)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWidthDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Width);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(Height);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(40);
        output.WriteInt32(Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPostionDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(Postion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWidth)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWidthDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Width);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(Height);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        output.WriteRawTag(40);
        output.WriteInt32(Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasPostion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Postion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasWidth)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWidthDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasHeight)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(JumpPointCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasPostion) {
        if (!HasPostion) {
          Postion = new global::Protocol.Float3();
        }
        Postion.MergeFrom(other.Postion);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasWidth) {
        Width = other.Width;
      }
      if (other.HasHeight) {
        Height = other.Height;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 29: {
            Width = input.ReadFloat();
            break;
          }
          case 37: {
            Height = input.ReadFloat();
            break;
          }
          case 40: {
            Type = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasPostion) {
              Postion = new global::Protocol.Float3();
            }
            input.ReadMessage(Postion);
            break;
          }
          case 18: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 29: {
            Width = input.ReadFloat();
            break;
          }
          case 37: {
            Height = input.ReadFloat();
            break;
          }
          case 40: {
            Type = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class HideAreaCfg : pb::IMessage<HideAreaCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HideAreaCfg> _parser = new pb::MessageParser<HideAreaCfg>(() => new HideAreaCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HideAreaCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HideAreaCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HideAreaCfg(HideAreaCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      id_ = other.id_;
      invisible_ = other.invisible_;
      entityTypeList_ = other.entityTypeList_.Clone();
      requireTagList_ = other.requireTagList_.Clone();
      blockTagList_ = other.blockTagList_.Clone();
      canSeeInArea_ = other.canSeeInArea_;
      visibleValRecoverySpeed_ = other.visibleValRecoverySpeed_;
      stayInvisibleTime_ = other.stayInvisibleTime_;
      centerPosition_ = other.HasCenterPosition ? other.centerPosition_.Clone() : null;
      colliderSize_ = other.HasColliderSize ? other.colliderSize_.Clone() : null;
      modelId_ = other.modelId_;
      hideAreaType_ = other.hideAreaType_;
      modelOcclude_ = other.modelOcclude_;
      modelSize_ = other.HasModelSize ? other.modelSize_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HideAreaCfg Clone() {
      return new HideAreaCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "invisible" field.</summary>
    public const int InvisibleFieldNumber = 2;
    private bool invisible_;
    /// <summary>
    ///进入区域是否能隐身
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Invisible {
      get { if ((_hasBits0 & 2) != 0) { return invisible_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        invisible_ = value;
      }
    }
    /// <summary>Gets whether the "invisible" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInvisible {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "invisible" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInvisibleDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "invisible" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInvisible() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "entity_type_list" field.</summary>
    public const int EntityTypeListFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Protocol.EntityType> _repeated_entityTypeList_codec
        = pb::FieldCodec.ForEnum(26, x => (int) x, x => (global::Protocol.EntityType) x);
    private readonly pbc::RepeatedField<global::Protocol.EntityType> entityTypeList_ = new pbc::RepeatedField<global::Protocol.EntityType>();
    /// <summary>
    ///生效的类型
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.EntityType> EntityTypeList {
      get { return entityTypeList_; }
    }

    /// <summary>Field number for the "require_tag_list" field.</summary>
    public const int RequireTagListFieldNumber = 4;
    private static readonly pb::FieldCodec<uint> _repeated_requireTagList_codec
        = pb::FieldCodec.ForUInt32(34);
    private readonly pbc::RepeatedField<uint> requireTagList_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> RequireTagList {
      get { return requireTagList_; }
    }

    /// <summary>Field number for the "block_tag_list" field.</summary>
    public const int BlockTagListFieldNumber = 5;
    private static readonly pb::FieldCodec<uint> _repeated_blockTagList_codec
        = pb::FieldCodec.ForUInt32(42);
    private readonly pbc::RepeatedField<uint> blockTagList_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> BlockTagList {
      get { return blockTagList_; }
    }

    /// <summary>Field number for the "can_see_in_area" field.</summary>
    public const int CanSeeInAreaFieldNumber = 6;
    private bool canSeeInArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool CanSeeInArea {
      get { if ((_hasBits0 & 4) != 0) { return canSeeInArea_; } else { return false; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 32;
        canSeeInArea_ = value;
      }
    }
    /// <summary>Gets whether the "can_see_in_area" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanSeeInArea {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "can_see_in_area" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCanSeeInAreaDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "can_see_in_area" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanSeeInArea() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "visible_val_recovery_speed" field.</summary>
    public const int VisibleValRecoverySpeedFieldNumber = 7;
    private float visibleValRecoverySpeed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float VisibleValRecoverySpeed {
      get { if ((_hasBits0 & 8) != 0) { return visibleValRecoverySpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 64;
        visibleValRecoverySpeed_ = value;
      }
    }
    /// <summary>Gets whether the "visible_val_recovery_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVisibleValRecoverySpeed {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "visible_val_recovery_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsVisibleValRecoverySpeedDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "visible_val_recovery_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVisibleValRecoverySpeed() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "stay_invisible_time" field.</summary>
    public const int StayInvisibleTimeFieldNumber = 8;
    private float stayInvisibleTime_;
    /// <summary>
    ///离开藏匿区域后，保持隐身的时间
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float StayInvisibleTime {
      get { if ((_hasBits0 & 16) != 0) { return stayInvisibleTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 128;
        stayInvisibleTime_ = value;
      }
    }
    /// <summary>Gets whether the "stay_invisible_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStayInvisibleTime {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "stay_invisible_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsStayInvisibleTimeDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "stay_invisible_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStayInvisibleTime() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "center_position" field.</summary>
    public const int CenterPositionFieldNumber = 9;
    private global::Protocol.Float3 centerPosition_;
    /// <summary>
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 CenterPosition {
      get { return centerPosition_; }
      set {
        centerPosition_ = value;
      }
    }
    /// <summary>Gets whether the center_position field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCenterPosition {
      get { return centerPosition_ != null; }
    }
    /// <summary>Clears the value of the center_position field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCenterPosition() {
      centerPosition_ = null;
    }
    /// <summary>Gets whether the "center_position" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCenterPositionDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }

    /// <summary>Field number for the "collider_size" field.</summary>
    public const int ColliderSizeFieldNumber = 10;
    private global::Protocol.Float3 colliderSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 ColliderSize {
      get { return colliderSize_; }
      set {
        colliderSize_ = value;
      }
    }
    /// <summary>Gets whether the collider_size field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasColliderSize {
      get { return colliderSize_ != null; }
    }
    /// <summary>Clears the value of the collider_size field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearColliderSize() {
      colliderSize_ = null;
    }
    /// <summary>Gets whether the "collider_size" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsColliderSizeDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }

    /// <summary>Field number for the "model_id" field.</summary>
    public const int ModelIdFieldNumber = 11;
    private uint modelId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ModelId {
      get { if ((_hasBits0 & 32) != 0) { return modelId_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 1024;
        modelId_ = value;
      }
    }
    /// <summary>Gets whether the "model_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelId {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "model_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelIdDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "model_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelId() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "hide_area_type" field.</summary>
    public const int HideAreaTypeFieldNumber = 12;
    private global::Protocol.HideAreaType hideAreaType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.HideAreaType HideAreaType {
      get { if ((_hasBits0 & 64) != 0) { return hideAreaType_; } else { return global::Protocol.HideAreaType.Cube; } }
      set {
        _hasBits0 |= 64;
        _dirtyBits0 |= 2048;
        hideAreaType_ = value;
      }
    }
    /// <summary>Gets whether the "hide_area_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHideAreaType {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Gets whether the "hide_area_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHideAreaTypeDirty {
      get { return (_dirtyBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "hide_area_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHideAreaType() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "model_occlude" field.</summary>
    public const int ModelOccludeFieldNumber = 13;
    private bool modelOcclude_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ModelOcclude {
      get { if ((_hasBits0 & 128) != 0) { return modelOcclude_; } else { return false; } }
      set {
        _hasBits0 |= 128;
        _dirtyBits0 |= 4096;
        modelOcclude_ = value;
      }
    }
    /// <summary>Gets whether the "model_occlude" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelOcclude {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Gets whether the "model_occlude" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelOccludeDirty {
      get { return (_dirtyBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "model_occlude" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelOcclude() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "model_size" field.</summary>
    public const int ModelSizeFieldNumber = 14;
    private global::Protocol.Float3 modelSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 ModelSize {
      get { return modelSize_; }
      set {
        modelSize_ = value;
      }
    }
    /// <summary>Gets whether the model_size field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelSize {
      get { return modelSize_ != null; }
    }
    /// <summary>Clears the value of the model_size field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelSize() {
      modelSize_ = null;
    }
    /// <summary>Gets whether the "model_size" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelSizeDirty {
      get { return (_dirtyBits0 & 8192) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 15;
    private global::Protocol.Float3 rotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 16384) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HideAreaCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HideAreaCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Invisible != other.Invisible) return false;
      if(!entityTypeList_.Equals(other.entityTypeList_)) return false;
      if(!requireTagList_.Equals(other.requireTagList_)) return false;
      if(!blockTagList_.Equals(other.blockTagList_)) return false;
      if (CanSeeInArea != other.CanSeeInArea) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(VisibleValRecoverySpeed, other.VisibleValRecoverySpeed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(StayInvisibleTime, other.StayInvisibleTime)) return false;
      if (!object.Equals(CenterPosition, other.CenterPosition)) return false;
      if (!object.Equals(ColliderSize, other.ColliderSize)) return false;
      if (ModelId != other.ModelId) return false;
      if (HideAreaType != other.HideAreaType) return false;
      if (ModelOcclude != other.ModelOcclude) return false;
      if (!object.Equals(ModelSize, other.ModelSize)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasInvisible) hash ^= Invisible.GetHashCode();
      hash ^= entityTypeList_.GetHashCode();
      hash ^= requireTagList_.GetHashCode();
      hash ^= blockTagList_.GetHashCode();
      if (HasCanSeeInArea) hash ^= CanSeeInArea.GetHashCode();
      if (HasVisibleValRecoverySpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(VisibleValRecoverySpeed);
      if (HasStayInvisibleTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(StayInvisibleTime);
      if (HasCenterPosition) hash ^= CenterPosition.GetHashCode();
      if (HasColliderSize) hash ^= ColliderSize.GetHashCode();
      if (HasModelId) hash ^= ModelId.GetHashCode();
      if (HasHideAreaType) hash ^= HideAreaType.GetHashCode();
      if (HasModelOcclude) hash ^= ModelOcclude.GetHashCode();
      if (HasModelSize) hash ^= ModelSize.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInvisible)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInvisibleDirty)) {
        output.WriteRawTag(16);
        output.WriteBool(Invisible);
      }
      entityTypeList_.WriteTo(output, _repeated_entityTypeList_codec);
      requireTagList_.WriteTo(output, _repeated_requireTagList_codec);
      blockTagList_.WriteTo(output, _repeated_blockTagList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeInArea)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInAreaDirty)) {
        output.WriteRawTag(48);
        output.WriteBool(CanSeeInArea);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasVisibleValRecoverySpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsVisibleValRecoverySpeedDirty)) {
        output.WriteRawTag(61);
        output.WriteFloat(VisibleValRecoverySpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasStayInvisibleTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsStayInvisibleTimeDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(StayInvisibleTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCenterPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCenterPositionDirty)) {
        output.WriteRawTag(74);
        output.WriteMessage(CenterPosition);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasColliderSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderSizeDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(ColliderSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(88);
        output.WriteUInt32(ModelId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHideAreaType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHideAreaTypeDirty)) {
        output.WriteRawTag(96);
        output.WriteEnum((int) HideAreaType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelOcclude)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelOccludeDirty)) {
        output.WriteRawTag(104);
        output.WriteBool(ModelOcclude);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelSizeDirty)) {
        output.WriteRawTag(114);
        output.WriteMessage(ModelSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(122);
        output.WriteMessage(Rotation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInvisible)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInvisibleDirty)) {
        output.WriteRawTag(16);
        output.WriteBool(Invisible);
      }
      entityTypeList_.WriteTo(ref output, _repeated_entityTypeList_codec);
      requireTagList_.WriteTo(ref output, _repeated_requireTagList_codec);
      blockTagList_.WriteTo(ref output, _repeated_blockTagList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasCanSeeInArea)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInAreaDirty)) {
        output.WriteRawTag(48);
        output.WriteBool(CanSeeInArea);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasVisibleValRecoverySpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsVisibleValRecoverySpeedDirty)) {
        output.WriteRawTag(61);
        output.WriteFloat(VisibleValRecoverySpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasStayInvisibleTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsStayInvisibleTimeDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(StayInvisibleTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCenterPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCenterPositionDirty)) {
        output.WriteRawTag(74);
        output.WriteMessage(CenterPosition);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasColliderSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsColliderSizeDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(ColliderSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(88);
        output.WriteUInt32(ModelId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHideAreaType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHideAreaTypeDirty)) {
        output.WriteRawTag(96);
        output.WriteEnum((int) HideAreaType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelOcclude)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelOccludeDirty)) {
        output.WriteRawTag(104);
        output.WriteBool(ModelOcclude);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelSizeDirty)) {
        output.WriteRawTag(114);
        output.WriteMessage(ModelSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(122);
        output.WriteMessage(Rotation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if ((scope == pb.WriteScope.FULL && HasInvisible)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsInvisibleDirty)) {
        size += 1 + 1;
      }
      size += entityTypeList_.CalculateSize(_repeated_entityTypeList_codec);
      size += requireTagList_.CalculateSize(_repeated_requireTagList_codec);
      size += blockTagList_.CalculateSize(_repeated_blockTagList_codec);
      if ((scope == pb.WriteScope.FULL && HasCanSeeInArea)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCanSeeInAreaDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasVisibleValRecoverySpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsVisibleValRecoverySpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasStayInvisibleTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsStayInvisibleTimeDirty)) {
        size += 1 + 4;
      }
      if (HasCenterPosition) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(CenterPosition, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 256;
        } else {
          _dirtyBits0 &= ~256;
        }
      }
      if (HasColliderSize) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(ColliderSize, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 512;
        } else {
          _dirtyBits0 &= ~512;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasModelId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ModelId);
      }
      if ((scope == pb.WriteScope.FULL && HasHideAreaType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHideAreaTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HideAreaType);
      }
      if ((scope == pb.WriteScope.FULL && HasModelOcclude)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsModelOccludeDirty)) {
        size += 1 + 1;
      }
      if (HasModelSize) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(ModelSize, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 8192;
        } else {
          _dirtyBits0 &= ~8192;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16384;
        } else {
          _dirtyBits0 &= ~16384;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HideAreaCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasInvisible) {
        Invisible = other.Invisible;
      }
      entityTypeList_.Add(other.entityTypeList_);
      requireTagList_.Add(other.requireTagList_);
      blockTagList_.Add(other.blockTagList_);
      if (other.HasCanSeeInArea) {
        CanSeeInArea = other.CanSeeInArea;
      }
      if (other.HasVisibleValRecoverySpeed) {
        VisibleValRecoverySpeed = other.VisibleValRecoverySpeed;
      }
      if (other.HasStayInvisibleTime) {
        StayInvisibleTime = other.StayInvisibleTime;
      }
      if (other.HasCenterPosition) {
        if (!HasCenterPosition) {
          CenterPosition = new global::Protocol.Float3();
        }
        CenterPosition.MergeFrom(other.CenterPosition);
      }
      if (other.HasColliderSize) {
        if (!HasColliderSize) {
          ColliderSize = new global::Protocol.Float3();
        }
        ColliderSize.MergeFrom(other.ColliderSize);
      }
      if (other.HasModelId) {
        ModelId = other.ModelId;
      }
      if (other.HasHideAreaType) {
        HideAreaType = other.HideAreaType;
      }
      if (other.HasModelOcclude) {
        ModelOcclude = other.ModelOcclude;
      }
      if (other.HasModelSize) {
        if (!HasModelSize) {
          ModelSize = new global::Protocol.Float3();
        }
        ModelSize.MergeFrom(other.ModelSize);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Invisible = input.ReadBool();
            break;
          }
          case 26:
          case 24: {
            entityTypeList_.AddEntriesFrom(input, _repeated_entityTypeList_codec);
            break;
          }
          case 34:
          case 32: {
            requireTagList_.AddEntriesFrom(input, _repeated_requireTagList_codec);
            break;
          }
          case 42:
          case 40: {
            blockTagList_.AddEntriesFrom(input, _repeated_blockTagList_codec);
            break;
          }
          case 48: {
            CanSeeInArea = input.ReadBool();
            break;
          }
          case 61: {
            VisibleValRecoverySpeed = input.ReadFloat();
            break;
          }
          case 69: {
            StayInvisibleTime = input.ReadFloat();
            break;
          }
          case 74: {
            if (!HasCenterPosition) {
              CenterPosition = new global::Protocol.Float3();
            }
            input.ReadMessage(CenterPosition);
            break;
          }
          case 82: {
            if (!HasColliderSize) {
              ColliderSize = new global::Protocol.Float3();
            }
            input.ReadMessage(ColliderSize);
            break;
          }
          case 88: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 96: {
            HideAreaType = (global::Protocol.HideAreaType) input.ReadEnum();
            break;
          }
          case 104: {
            ModelOcclude = input.ReadBool();
            break;
          }
          case 114: {
            if (!HasModelSize) {
              ModelSize = new global::Protocol.Float3();
            }
            input.ReadMessage(ModelSize);
            break;
          }
          case 122: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            Invisible = input.ReadBool();
            break;
          }
          case 26:
          case 24: {
            entityTypeList_.AddEntriesFrom(ref input, _repeated_entityTypeList_codec);
            break;
          }
          case 34:
          case 32: {
            requireTagList_.AddEntriesFrom(ref input, _repeated_requireTagList_codec);
            break;
          }
          case 42:
          case 40: {
            blockTagList_.AddEntriesFrom(ref input, _repeated_blockTagList_codec);
            break;
          }
          case 48: {
            CanSeeInArea = input.ReadBool();
            break;
          }
          case 61: {
            VisibleValRecoverySpeed = input.ReadFloat();
            break;
          }
          case 69: {
            StayInvisibleTime = input.ReadFloat();
            break;
          }
          case 74: {
            if (!HasCenterPosition) {
              CenterPosition = new global::Protocol.Float3();
            }
            input.ReadMessage(CenterPosition);
            break;
          }
          case 82: {
            if (!HasColliderSize) {
              ColliderSize = new global::Protocol.Float3();
            }
            input.ReadMessage(ColliderSize);
            break;
          }
          case 88: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 96: {
            HideAreaType = (global::Protocol.HideAreaType) input.ReadEnum();
            break;
          }
          case 104: {
            ModelOcclude = input.ReadBool();
            break;
          }
          case 114: {
            if (!HasModelSize) {
              ModelSize = new global::Protocol.Float3();
            }
            input.ReadMessage(ModelSize);
            break;
          }
          case 122: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class LevelCfg : pb::IMessage<LevelCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LevelCfg> _parser = new pb::MessageParser<LevelCfg>(() => new LevelCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LevelCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LevelCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LevelCfg(LevelCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      mapName_ = other.mapName_;
      battleData_ = other.HasBattleData ? other.battleData_.Clone() : null;
      bornList_ = other.bornList_.Clone();
      areaList_ = other.areaList_.Clone();
      thingList_ = other.thingList_.Clone();
      ladderList_ = other.ladderList_.Clone();
      cameraList_ = other.cameraList_.Clone();
      guardTargetList_ = other.guardTargetList_.Clone();
      npcBornList_ = other.npcBornList_.Clone();
      wayMapCfg_ = other.HasWayMapCfg ? other.wayMapCfg_.Clone() : null;
      needDebugUi_ = other.needDebugUi_;
      thingWayMapList_ = other.thingWayMapList_.Clone();
      dropList_ = other.dropList_.Clone();
      hookPointList_ = other.hookPointList_.Clone();
      jumpPointList_ = other.jumpPointList_.Clone();
      antidoteScatterList_ = other.antidoteScatterList_.Clone();
      hideAreaList_ = other.hideAreaList_.Clone();
      goapTargetList_ = other.goapTargetList_.Clone();
      clusterTargetList_ = other.clusterTargetList_.Clone();
      npcGazePointList_ = other.npcGazePointList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LevelCfg Clone() {
      return new LevelCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "map_name" field.</summary>
    public const int MapNameFieldNumber = 1;
    private string mapName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MapName {
      get { return mapName_ ?? ""; }
      set {
        mapName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "map_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMapName {
      get { return mapName_ != null; }
    }
    /// <summary>Gets whether the "map_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMapNameDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "map_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMapName() {
      mapName_ = null;
    }

    /// <summary>Field number for the "battle_data" field.</summary>
    public const int BattleDataFieldNumber = 2;
    private global::Protocol.BattleCfgData battleData_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BattleCfgData BattleData {
      get { return battleData_; }
      set {
        battleData_ = value;
      }
    }
    /// <summary>Gets whether the battle_data field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBattleData {
      get { return battleData_ != null; }
    }
    /// <summary>Clears the value of the battle_data field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBattleData() {
      battleData_ = null;
    }
    /// <summary>Gets whether the "battle_data" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBattleDataDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "born_list" field.</summary>
    public const int BornListFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Protocol.BornCfg> _repeated_bornList_codec
        = pb::FieldCodec.ForMessage(58, global::Protocol.BornCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.BornCfg> bornList_ = new pbc::RepeatedField<global::Protocol.BornCfg>();
    /// <summary>
    ///出生位置列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.BornCfg> BornList {
      get { return bornList_; }
    }

    /// <summary>Field number for the "area_list" field.</summary>
    public const int AreaListFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Protocol.AreaCfg> _repeated_areaList_codec
        = pb::FieldCodec.ForMessage(66, global::Protocol.AreaCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.AreaCfg> areaList_ = new pbc::RepeatedField<global::Protocol.AreaCfg>();
    /// <summary>
    ///藏匿区列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.AreaCfg> AreaList {
      get { return areaList_; }
    }

    /// <summary>Field number for the "thing_list" field.</summary>
    public const int ThingListFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Protocol.ThingCfg> _repeated_thingList_codec
        = pb::FieldCodec.ForMessage(74, global::Protocol.ThingCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.ThingCfg> thingList_ = new pbc::RepeatedField<global::Protocol.ThingCfg>();
    /// <summary>
    ///物件列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.ThingCfg> ThingList {
      get { return thingList_; }
    }

    /// <summary>Field number for the "ladder_list" field.</summary>
    public const int LadderListFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Protocol.LadderCfg> _repeated_ladderList_codec
        = pb::FieldCodec.ForMessage(82, global::Protocol.LadderCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.LadderCfg> ladderList_ = new pbc::RepeatedField<global::Protocol.LadderCfg>();
    /// <summary>
    ///联通点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.LadderCfg> LadderList {
      get { return ladderList_; }
    }

    /// <summary>Field number for the "camera_list" field.</summary>
    public const int CameraListFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Protocol.CameraCfg> _repeated_cameraList_codec
        = pb::FieldCodec.ForMessage(90, global::Protocol.CameraCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.CameraCfg> cameraList_ = new pbc::RepeatedField<global::Protocol.CameraCfg>();
    /// <summary>
    ///虚拟相机列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.CameraCfg> CameraList {
      get { return cameraList_; }
    }

    /// <summary>Field number for the "guard_target_list" field.</summary>
    public const int GuardTargetListFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Protocol.GuardTargetAreaCfg> _repeated_guardTargetList_codec
        = pb::FieldCodec.ForMessage(106, global::Protocol.GuardTargetAreaCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.GuardTargetAreaCfg> guardTargetList_ = new pbc::RepeatedField<global::Protocol.GuardTargetAreaCfg>();
    /// <summary>
    ///警卫巡逻区域
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.GuardTargetAreaCfg> GuardTargetList {
      get { return guardTargetList_; }
    }

    /// <summary>Field number for the "npc_born_list" field.</summary>
    public const int NpcBornListFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Protocol.NpcBornCfg> _repeated_npcBornList_codec
        = pb::FieldCodec.ForMessage(114, global::Protocol.NpcBornCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.NpcBornCfg> npcBornList_ = new pbc::RepeatedField<global::Protocol.NpcBornCfg>();
    /// <summary>
    ///多种npc出生点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.NpcBornCfg> NpcBornList {
      get { return npcBornList_; }
    }

    /// <summary>Field number for the "way_map_cfg" field.</summary>
    public const int WayMapCfgFieldNumber = 15;
    private global::Protocol.WayMapCfg wayMapCfg_;
    /// <summary>
    ///路点系统
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.WayMapCfg WayMapCfg {
      get { return wayMapCfg_; }
      set {
        wayMapCfg_ = value;
      }
    }
    /// <summary>Gets whether the way_map_cfg field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWayMapCfg {
      get { return wayMapCfg_ != null; }
    }
    /// <summary>Clears the value of the way_map_cfg field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWayMapCfg() {
      wayMapCfg_ = null;
    }
    /// <summary>Gets whether the "way_map_cfg" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWayMapCfgDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }

    /// <summary>Field number for the "need_debug_ui" field.</summary>
    public const int NeedDebugUiFieldNumber = 16;
    private bool needDebugUi_;
    /// <summary>
    ///是否需要头顶的调试UI
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NeedDebugUi {
      get { if ((_hasBits0 & 1) != 0) { return needDebugUi_; } else { return false; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1024;
        needDebugUi_ = value;
      }
    }
    /// <summary>Gets whether the "need_debug_ui" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNeedDebugUi {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "need_debug_ui" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNeedDebugUiDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "need_debug_ui" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNeedDebugUi() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "thing_way_map_list" field.</summary>
    public const int ThingWayMapListFieldNumber = 17;
    private static readonly pb::FieldCodec<global::Protocol.ThingWayMap> _repeated_thingWayMapList_codec
        = pb::FieldCodec.ForMessage(138, global::Protocol.ThingWayMap.Parser);
    private readonly pbc::RepeatedField<global::Protocol.ThingWayMap> thingWayMapList_ = new pbc::RepeatedField<global::Protocol.ThingWayMap>();
    /// <summary>
    ///物品所需要的路点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.ThingWayMap> ThingWayMapList {
      get { return thingWayMapList_; }
    }

    /// <summary>Field number for the "drop_list" field.</summary>
    public const int DropListFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Protocol.DropCfg> _repeated_dropList_codec
        = pb::FieldCodec.ForMessage(154, global::Protocol.DropCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.DropCfg> dropList_ = new pbc::RepeatedField<global::Protocol.DropCfg>();
    /// <summary>
    ///掉落列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.DropCfg> DropList {
      get { return dropList_; }
    }

    /// <summary>Field number for the "hook_point_list" field.</summary>
    public const int HookPointListFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Protocol.HookPointCfg> _repeated_hookPointList_codec
        = pb::FieldCodec.ForMessage(162, global::Protocol.HookPointCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.HookPointCfg> hookPointList_ = new pbc::RepeatedField<global::Protocol.HookPointCfg>();
    /// <summary>
    ///勾爪点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.HookPointCfg> HookPointList {
      get { return hookPointList_; }
    }

    /// <summary>Field number for the "jump_point_list" field.</summary>
    public const int JumpPointListFieldNumber = 21;
    private static readonly pb::FieldCodec<global::Protocol.JumpPointCfg> _repeated_jumpPointList_codec
        = pb::FieldCodec.ForMessage(170, global::Protocol.JumpPointCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.JumpPointCfg> jumpPointList_ = new pbc::RepeatedField<global::Protocol.JumpPointCfg>();
    /// <summary>
    ///跳跃点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.JumpPointCfg> JumpPointList {
      get { return jumpPointList_; }
    }

    /// <summary>Field number for the "antidote_scatter_list" field.</summary>
    public const int AntidoteScatterListFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Protocol.AntidoteScatterCfg> _repeated_antidoteScatterList_codec
        = pb::FieldCodec.ForMessage(178, global::Protocol.AntidoteScatterCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.AntidoteScatterCfg> antidoteScatterList_ = new pbc::RepeatedField<global::Protocol.AntidoteScatterCfg>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.AntidoteScatterCfg> AntidoteScatterList {
      get { return antidoteScatterList_; }
    }

    /// <summary>Field number for the "hide_area_list" field.</summary>
    public const int HideAreaListFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Protocol.HideAreaCfg> _repeated_hideAreaList_codec
        = pb::FieldCodec.ForMessage(186, global::Protocol.HideAreaCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.HideAreaCfg> hideAreaList_ = new pbc::RepeatedField<global::Protocol.HideAreaCfg>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.HideAreaCfg> HideAreaList {
      get { return hideAreaList_; }
    }

    /// <summary>Field number for the "goap_target_list" field.</summary>
    public const int GoapTargetListFieldNumber = 24;
    private static readonly pb::FieldCodec<global::Protocol.GoapTargetCfg> _repeated_goapTargetList_codec
        = pb::FieldCodec.ForMessage(194, global::Protocol.GoapTargetCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.GoapTargetCfg> goapTargetList_ = new pbc::RepeatedField<global::Protocol.GoapTargetCfg>();
    /// <summary>
    ///NPC_Goap_寻路终点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.GoapTargetCfg> GoapTargetList {
      get { return goapTargetList_; }
    }

    /// <summary>Field number for the "cluster_target_list" field.</summary>
    public const int ClusterTargetListFieldNumber = 25;
    private static readonly pb::FieldCodec<global::Protocol.ClusterCfg> _repeated_clusterTargetList_codec
        = pb::FieldCodec.ForMessage(202, global::Protocol.ClusterCfg.Parser);
    private readonly pbc::RepeatedField<global::Protocol.ClusterCfg> clusterTargetList_ = new pbc::RepeatedField<global::Protocol.ClusterCfg>();
    /// <summary>
    ///Npc 站位集群列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.ClusterCfg> ClusterTargetList {
      get { return clusterTargetList_; }
    }

    /// <summary>Field number for the "npc_gaze_point_list" field.</summary>
    public const int NpcGazePointListFieldNumber = 26;
    private static readonly pb::FieldCodec<global::Protocol.NpcGazePoint> _repeated_npcGazePointList_codec
        = pb::FieldCodec.ForMessage(210, global::Protocol.NpcGazePoint.Parser);
    private readonly pbc::RepeatedField<global::Protocol.NpcGazePoint> npcGazePointList_ = new pbc::RepeatedField<global::Protocol.NpcGazePoint>();
    /// <summary>
    ///Npc 注视点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.NpcGazePoint> NpcGazePointList {
      get { return npcGazePointList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LevelCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LevelCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MapName != other.MapName) return false;
      if (!object.Equals(BattleData, other.BattleData)) return false;
      if(!bornList_.Equals(other.bornList_)) return false;
      if(!areaList_.Equals(other.areaList_)) return false;
      if(!thingList_.Equals(other.thingList_)) return false;
      if(!ladderList_.Equals(other.ladderList_)) return false;
      if(!cameraList_.Equals(other.cameraList_)) return false;
      if(!guardTargetList_.Equals(other.guardTargetList_)) return false;
      if(!npcBornList_.Equals(other.npcBornList_)) return false;
      if (!object.Equals(WayMapCfg, other.WayMapCfg)) return false;
      if (NeedDebugUi != other.NeedDebugUi) return false;
      if(!thingWayMapList_.Equals(other.thingWayMapList_)) return false;
      if(!dropList_.Equals(other.dropList_)) return false;
      if(!hookPointList_.Equals(other.hookPointList_)) return false;
      if(!jumpPointList_.Equals(other.jumpPointList_)) return false;
      if(!antidoteScatterList_.Equals(other.antidoteScatterList_)) return false;
      if(!hideAreaList_.Equals(other.hideAreaList_)) return false;
      if(!goapTargetList_.Equals(other.goapTargetList_)) return false;
      if(!clusterTargetList_.Equals(other.clusterTargetList_)) return false;
      if(!npcGazePointList_.Equals(other.npcGazePointList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMapName) hash ^= MapName.GetHashCode();
      if (HasBattleData) hash ^= BattleData.GetHashCode();
      hash ^= bornList_.GetHashCode();
      hash ^= areaList_.GetHashCode();
      hash ^= thingList_.GetHashCode();
      hash ^= ladderList_.GetHashCode();
      hash ^= cameraList_.GetHashCode();
      hash ^= guardTargetList_.GetHashCode();
      hash ^= npcBornList_.GetHashCode();
      if (HasWayMapCfg) hash ^= WayMapCfg.GetHashCode();
      if (HasNeedDebugUi) hash ^= NeedDebugUi.GetHashCode();
      hash ^= thingWayMapList_.GetHashCode();
      hash ^= dropList_.GetHashCode();
      hash ^= hookPointList_.GetHashCode();
      hash ^= jumpPointList_.GetHashCode();
      hash ^= antidoteScatterList_.GetHashCode();
      hash ^= hideAreaList_.GetHashCode();
      hash ^= goapTargetList_.GetHashCode();
      hash ^= clusterTargetList_.GetHashCode();
      hash ^= npcGazePointList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasMapName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMapNameDirty)) {
        output.WriteRawTag(10);
        output.WriteString(MapName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBattleData)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBattleDataDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(BattleData);
      }
      bornList_.WriteTo(output, _repeated_bornList_codec);
      areaList_.WriteTo(output, _repeated_areaList_codec);
      thingList_.WriteTo(output, _repeated_thingList_codec);
      ladderList_.WriteTo(output, _repeated_ladderList_codec);
      cameraList_.WriteTo(output, _repeated_cameraList_codec);
      guardTargetList_.WriteTo(output, _repeated_guardTargetList_codec);
      npcBornList_.WriteTo(output, _repeated_npcBornList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapCfg)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapCfgDirty)) {
        output.WriteRawTag(122);
        output.WriteMessage(WayMapCfg);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNeedDebugUi)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNeedDebugUiDirty)) {
        output.WriteRawTag(128, 1);
        output.WriteBool(NeedDebugUi);
      }
      thingWayMapList_.WriteTo(output, _repeated_thingWayMapList_codec);
      dropList_.WriteTo(output, _repeated_dropList_codec);
      hookPointList_.WriteTo(output, _repeated_hookPointList_codec);
      jumpPointList_.WriteTo(output, _repeated_jumpPointList_codec);
      antidoteScatterList_.WriteTo(output, _repeated_antidoteScatterList_codec);
      hideAreaList_.WriteTo(output, _repeated_hideAreaList_codec);
      goapTargetList_.WriteTo(output, _repeated_goapTargetList_codec);
      clusterTargetList_.WriteTo(output, _repeated_clusterTargetList_codec);
      npcGazePointList_.WriteTo(output, _repeated_npcGazePointList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasMapName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMapNameDirty)) {
        output.WriteRawTag(10);
        output.WriteString(MapName);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBattleData)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBattleDataDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(BattleData);
      }
      bornList_.WriteTo(ref output, _repeated_bornList_codec);
      areaList_.WriteTo(ref output, _repeated_areaList_codec);
      thingList_.WriteTo(ref output, _repeated_thingList_codec);
      ladderList_.WriteTo(ref output, _repeated_ladderList_codec);
      cameraList_.WriteTo(ref output, _repeated_cameraList_codec);
      guardTargetList_.WriteTo(ref output, _repeated_guardTargetList_codec);
      npcBornList_.WriteTo(ref output, _repeated_npcBornList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapCfg)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapCfgDirty)) {
        output.WriteRawTag(122);
        output.WriteMessage(WayMapCfg);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNeedDebugUi)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNeedDebugUiDirty)) {
        output.WriteRawTag(128, 1);
        output.WriteBool(NeedDebugUi);
      }
      thingWayMapList_.WriteTo(ref output, _repeated_thingWayMapList_codec);
      dropList_.WriteTo(ref output, _repeated_dropList_codec);
      hookPointList_.WriteTo(ref output, _repeated_hookPointList_codec);
      jumpPointList_.WriteTo(ref output, _repeated_jumpPointList_codec);
      antidoteScatterList_.WriteTo(ref output, _repeated_antidoteScatterList_codec);
      hideAreaList_.WriteTo(ref output, _repeated_hideAreaList_codec);
      goapTargetList_.WriteTo(ref output, _repeated_goapTargetList_codec);
      clusterTargetList_.WriteTo(ref output, _repeated_clusterTargetList_codec);
      npcGazePointList_.WriteTo(ref output, _repeated_npcGazePointList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasMapName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMapNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MapName);
      }
      if (HasBattleData) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(BattleData, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      size += bornList_.CalculateSize(_repeated_bornList_codec);
      size += areaList_.CalculateSize(_repeated_areaList_codec);
      size += thingList_.CalculateSize(_repeated_thingList_codec);
      size += ladderList_.CalculateSize(_repeated_ladderList_codec);
      size += cameraList_.CalculateSize(_repeated_cameraList_codec);
      size += guardTargetList_.CalculateSize(_repeated_guardTargetList_codec);
      size += npcBornList_.CalculateSize(_repeated_npcBornList_codec);
      if (HasWayMapCfg) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(WayMapCfg, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 512;
        } else {
          _dirtyBits0 &= ~512;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasNeedDebugUi)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNeedDebugUiDirty)) {
        size += 2 + 1;
      }
      size += thingWayMapList_.CalculateSize(_repeated_thingWayMapList_codec);
      size += dropList_.CalculateSize(_repeated_dropList_codec);
      size += hookPointList_.CalculateSize(_repeated_hookPointList_codec);
      size += jumpPointList_.CalculateSize(_repeated_jumpPointList_codec);
      size += antidoteScatterList_.CalculateSize(_repeated_antidoteScatterList_codec);
      size += hideAreaList_.CalculateSize(_repeated_hideAreaList_codec);
      size += goapTargetList_.CalculateSize(_repeated_goapTargetList_codec);
      size += clusterTargetList_.CalculateSize(_repeated_clusterTargetList_codec);
      size += npcGazePointList_.CalculateSize(_repeated_npcGazePointList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LevelCfg other) {
      if (other == null) {
        return;
      }
      if (other.HasMapName) {
        MapName = other.MapName;
      }
      if (other.HasBattleData) {
        if (!HasBattleData) {
          BattleData = new global::Protocol.BattleCfgData();
        }
        BattleData.MergeFrom(other.BattleData);
      }
      bornList_.Add(other.bornList_);
      areaList_.Add(other.areaList_);
      thingList_.Add(other.thingList_);
      ladderList_.Add(other.ladderList_);
      cameraList_.Add(other.cameraList_);
      guardTargetList_.Add(other.guardTargetList_);
      npcBornList_.Add(other.npcBornList_);
      if (other.HasWayMapCfg) {
        if (!HasWayMapCfg) {
          WayMapCfg = new global::Protocol.WayMapCfg();
        }
        WayMapCfg.MergeFrom(other.WayMapCfg);
      }
      if (other.HasNeedDebugUi) {
        NeedDebugUi = other.NeedDebugUi;
      }
      thingWayMapList_.Add(other.thingWayMapList_);
      dropList_.Add(other.dropList_);
      hookPointList_.Add(other.hookPointList_);
      jumpPointList_.Add(other.jumpPointList_);
      antidoteScatterList_.Add(other.antidoteScatterList_);
      hideAreaList_.Add(other.hideAreaList_);
      goapTargetList_.Add(other.goapTargetList_);
      clusterTargetList_.Add(other.clusterTargetList_);
      npcGazePointList_.Add(other.npcGazePointList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MapName = input.ReadString();
            break;
          }
          case 18: {
            if (!HasBattleData) {
              BattleData = new global::Protocol.BattleCfgData();
            }
            input.ReadMessage(BattleData);
            break;
          }
          case 58: {
            bornList_.AddEntriesFrom(input, _repeated_bornList_codec);
            break;
          }
          case 66: {
            areaList_.AddEntriesFrom(input, _repeated_areaList_codec);
            break;
          }
          case 74: {
            thingList_.AddEntriesFrom(input, _repeated_thingList_codec);
            break;
          }
          case 82: {
            ladderList_.AddEntriesFrom(input, _repeated_ladderList_codec);
            break;
          }
          case 90: {
            cameraList_.AddEntriesFrom(input, _repeated_cameraList_codec);
            break;
          }
          case 106: {
            guardTargetList_.AddEntriesFrom(input, _repeated_guardTargetList_codec);
            break;
          }
          case 114: {
            npcBornList_.AddEntriesFrom(input, _repeated_npcBornList_codec);
            break;
          }
          case 122: {
            if (!HasWayMapCfg) {
              WayMapCfg = new global::Protocol.WayMapCfg();
            }
            input.ReadMessage(WayMapCfg);
            break;
          }
          case 128: {
            NeedDebugUi = input.ReadBool();
            break;
          }
          case 138: {
            thingWayMapList_.AddEntriesFrom(input, _repeated_thingWayMapList_codec);
            break;
          }
          case 154: {
            dropList_.AddEntriesFrom(input, _repeated_dropList_codec);
            break;
          }
          case 162: {
            hookPointList_.AddEntriesFrom(input, _repeated_hookPointList_codec);
            break;
          }
          case 170: {
            jumpPointList_.AddEntriesFrom(input, _repeated_jumpPointList_codec);
            break;
          }
          case 178: {
            antidoteScatterList_.AddEntriesFrom(input, _repeated_antidoteScatterList_codec);
            break;
          }
          case 186: {
            hideAreaList_.AddEntriesFrom(input, _repeated_hideAreaList_codec);
            break;
          }
          case 194: {
            goapTargetList_.AddEntriesFrom(input, _repeated_goapTargetList_codec);
            break;
          }
          case 202: {
            clusterTargetList_.AddEntriesFrom(input, _repeated_clusterTargetList_codec);
            break;
          }
          case 210: {
            npcGazePointList_.AddEntriesFrom(input, _repeated_npcGazePointList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MapName = input.ReadString();
            break;
          }
          case 18: {
            if (!HasBattleData) {
              BattleData = new global::Protocol.BattleCfgData();
            }
            input.ReadMessage(BattleData);
            break;
          }
          case 58: {
            bornList_.AddEntriesFrom(ref input, _repeated_bornList_codec);
            break;
          }
          case 66: {
            areaList_.AddEntriesFrom(ref input, _repeated_areaList_codec);
            break;
          }
          case 74: {
            thingList_.AddEntriesFrom(ref input, _repeated_thingList_codec);
            break;
          }
          case 82: {
            ladderList_.AddEntriesFrom(ref input, _repeated_ladderList_codec);
            break;
          }
          case 90: {
            cameraList_.AddEntriesFrom(ref input, _repeated_cameraList_codec);
            break;
          }
          case 106: {
            guardTargetList_.AddEntriesFrom(ref input, _repeated_guardTargetList_codec);
            break;
          }
          case 114: {
            npcBornList_.AddEntriesFrom(ref input, _repeated_npcBornList_codec);
            break;
          }
          case 122: {
            if (!HasWayMapCfg) {
              WayMapCfg = new global::Protocol.WayMapCfg();
            }
            input.ReadMessage(WayMapCfg);
            break;
          }
          case 128: {
            NeedDebugUi = input.ReadBool();
            break;
          }
          case 138: {
            thingWayMapList_.AddEntriesFrom(ref input, _repeated_thingWayMapList_codec);
            break;
          }
          case 154: {
            dropList_.AddEntriesFrom(ref input, _repeated_dropList_codec);
            break;
          }
          case 162: {
            hookPointList_.AddEntriesFrom(ref input, _repeated_hookPointList_codec);
            break;
          }
          case 170: {
            jumpPointList_.AddEntriesFrom(ref input, _repeated_jumpPointList_codec);
            break;
          }
          case 178: {
            antidoteScatterList_.AddEntriesFrom(ref input, _repeated_antidoteScatterList_codec);
            break;
          }
          case 186: {
            hideAreaList_.AddEntriesFrom(ref input, _repeated_hideAreaList_codec);
            break;
          }
          case 194: {
            goapTargetList_.AddEntriesFrom(ref input, _repeated_goapTargetList_codec);
            break;
          }
          case 202: {
            clusterTargetList_.AddEntriesFrom(ref input, _repeated_clusterTargetList_codec);
            break;
          }
          case 210: {
            npcGazePointList_.AddEntriesFrom(ref input, _repeated_npcGazePointList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ThingWayMap : pb::IMessage<ThingWayMap>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ThingWayMap> _parser = new pb::MessageParser<ThingWayMap>(() => new ThingWayMap());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ThingWayMap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingWayMap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingWayMap(ThingWayMap other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      id_ = other.id_;
      wayMapCfg_ = other.HasWayMapCfg ? other.wayMapCfg_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ThingWayMap Clone() {
      return new ThingWayMap(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private uint id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "way_map_cfg" field.</summary>
    public const int WayMapCfgFieldNumber = 2;
    private global::Protocol.WayMapCfg wayMapCfg_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.WayMapCfg WayMapCfg {
      get { return wayMapCfg_; }
      set {
        wayMapCfg_ = value;
      }
    }
    /// <summary>Gets whether the way_map_cfg field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWayMapCfg {
      get { return wayMapCfg_ != null; }
    }
    /// <summary>Clears the value of the way_map_cfg field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWayMapCfg() {
      wayMapCfg_ = null;
    }
    /// <summary>Gets whether the "way_map_cfg" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWayMapCfgDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ThingWayMap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ThingWayMap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!object.Equals(WayMapCfg, other.WayMapCfg)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasWayMapCfg) hash ^= WayMapCfg.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapCfg)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapCfgDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(WayMapCfg);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWayMapCfg)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWayMapCfgDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(WayMapCfg);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasWayMapCfg) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(WayMapCfg, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ThingWayMap other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasWayMapCfg) {
        if (!HasWayMapCfg) {
          WayMapCfg = new global::Protocol.WayMapCfg();
        }
        WayMapCfg.MergeFrom(other.WayMapCfg);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasWayMapCfg) {
              WayMapCfg = new global::Protocol.WayMapCfg();
            }
            input.ReadMessage(WayMapCfg);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18: {
            if (!HasWayMapCfg) {
              WayMapCfg = new global::Protocol.WayMapCfg();
            }
            input.ReadMessage(WayMapCfg);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///移动关键帧
  /// </summary>
  public sealed partial class MoveKeyFrame : pb::IMessage<MoveKeyFrame>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MoveKeyFrame> _parser = new pb::MessageParser<MoveKeyFrame>(() => new MoveKeyFrame());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MoveKeyFrame> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveKeyFrame() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveKeyFrame(MoveKeyFrame other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      time_ = other.time_;
      value_ = other.value_;
      inTangent_ = other.inTangent_;
      outTangent_ = other.outTangent_;
      inWeight_ = other.inWeight_;
      outWeight_ = other.outWeight_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveKeyFrame Clone() {
      return new MoveKeyFrame(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private float time_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Time {
      get { if ((_hasBits0 & 1) != 0) { return time_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        time_ = value;
      }
    }
    /// <summary>Gets whether the "time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTimeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTime() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private float value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Value {
      get { if ((_hasBits0 & 2) != 0) { return value_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        value_ = value;
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasValue {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "value" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsValueDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "in_tangent" field.</summary>
    public const int InTangentFieldNumber = 3;
    private float inTangent_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InTangent {
      get { if ((_hasBits0 & 4) != 0) { return inTangent_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        inTangent_ = value;
      }
    }
    /// <summary>Gets whether the "in_tangent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInTangent {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "in_tangent" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInTangentDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "in_tangent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInTangent() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "out_tangent" field.</summary>
    public const int OutTangentFieldNumber = 4;
    private float outTangent_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OutTangent {
      get { if ((_hasBits0 & 8) != 0) { return outTangent_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        outTangent_ = value;
      }
    }
    /// <summary>Gets whether the "out_tangent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOutTangent {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "out_tangent" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOutTangentDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "out_tangent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOutTangent() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "in_weight" field.</summary>
    public const int InWeightFieldNumber = 5;
    private float inWeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InWeight {
      get { if ((_hasBits0 & 16) != 0) { return inWeight_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 16;
        inWeight_ = value;
      }
    }
    /// <summary>Gets whether the "in_weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInWeight {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "in_weight" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInWeightDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "in_weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInWeight() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "out_weight" field.</summary>
    public const int OutWeightFieldNumber = 6;
    private float outWeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OutWeight {
      get { if ((_hasBits0 & 32) != 0) { return outWeight_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 32;
        outWeight_ = value;
      }
    }
    /// <summary>Gets whether the "out_weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOutWeight {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "out_weight" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsOutWeightDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "out_weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOutWeight() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MoveKeyFrame);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MoveKeyFrame other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Time, other.Time)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Value, other.Value)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InTangent, other.InTangent)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OutTangent, other.OutTangent)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InWeight, other.InWeight)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OutWeight, other.OutWeight)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Time);
      if (HasValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Value);
      if (HasInTangent) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InTangent);
      if (HasOutTangent) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OutTangent);
      if (HasInWeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InWeight);
      if (HasOutWeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OutWeight);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasValue)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsValueDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(Value);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInTangent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInTangentDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(InTangent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOutTangent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOutTangentDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(OutTangent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInWeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInWeightDirty)) {
        output.WriteRawTag(45);
        output.WriteFloat(InWeight);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOutWeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOutWeightDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(OutWeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Time);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasValue)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsValueDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(Value);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInTangent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInTangentDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(InTangent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOutTangent)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOutTangentDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(OutTangent);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasInWeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsInWeightDirty)) {
        output.WriteRawTag(45);
        output.WriteFloat(InWeight);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasOutWeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsOutWeightDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(OutWeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasValue)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsValueDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasInTangent)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsInTangentDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasOutTangent)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOutTangentDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasInWeight)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsInWeightDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasOutWeight)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsOutWeightDirty)) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MoveKeyFrame other) {
      if (other == null) {
        return;
      }
      if (other.HasTime) {
        Time = other.Time;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasInTangent) {
        InTangent = other.InTangent;
      }
      if (other.HasOutTangent) {
        OutTangent = other.OutTangent;
      }
      if (other.HasInWeight) {
        InWeight = other.InWeight;
      }
      if (other.HasOutWeight) {
        OutWeight = other.OutWeight;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 21: {
            Value = input.ReadFloat();
            break;
          }
          case 29: {
            InTangent = input.ReadFloat();
            break;
          }
          case 37: {
            OutTangent = input.ReadFloat();
            break;
          }
          case 45: {
            InWeight = input.ReadFloat();
            break;
          }
          case 53: {
            OutWeight = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Time = input.ReadFloat();
            break;
          }
          case 21: {
            Value = input.ReadFloat();
            break;
          }
          case 29: {
            InTangent = input.ReadFloat();
            break;
          }
          case 37: {
            OutTangent = input.ReadFloat();
            break;
          }
          case 45: {
            InWeight = input.ReadFloat();
            break;
          }
          case 53: {
            OutWeight = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MoveMotion : pb::IMessage<MoveMotion>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MoveMotion> _parser = new pb::MessageParser<MoveMotion>(() => new MoveMotion());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MoveMotion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveMotion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveMotion(MoveMotion other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      length_ = other.length_;
      positionXCurve_ = other.positionXCurve_.Clone();
      positionZCurve_ = other.positionZCurve_.Clone();
      rotationXCurve_ = other.rotationXCurve_.Clone();
      rotationYCurve_ = other.rotationYCurve_.Clone();
      rotationZCurve_ = other.rotationZCurve_.Clone();
      rotationWCurve_ = other.rotationWCurve_.Clone();
      motionName_ = other.motionName_;
      positionYCurve_ = other.positionYCurve_.Clone();
      noneRotation_ = other.noneRotation_;
      nonePostionXz_ = other.nonePostionXz_;
      nonePostionY_ = other.nonePostionY_;
      isLoop_ = other.isLoop_;
      scaleXCurve_ = other.scaleXCurve_.Clone();
      scaleYCurve_ = other.scaleYCurve_.Clone();
      scaleZCurve_ = other.scaleZCurve_.Clone();
      motionType_ = other.motionType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveMotion Clone() {
      return new MoveMotion(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 1;
    private float length_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Length {
      get { if ((_hasBits0 & 1) != 0) { return length_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        length_ = value;
      }
    }
    /// <summary>Gets whether the "length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLength {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "length" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLengthDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLength() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "position_x_curve" field.</summary>
    public const int PositionXCurveFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_positionXCurve_codec
        = pb::FieldCodec.ForMessage(18, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> positionXCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> PositionXCurve {
      get { return positionXCurve_; }
    }

    /// <summary>Field number for the "position_z_curve" field.</summary>
    public const int PositionZCurveFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_positionZCurve_codec
        = pb::FieldCodec.ForMessage(26, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> positionZCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> PositionZCurve {
      get { return positionZCurve_; }
    }

    /// <summary>Field number for the "rotation_x_curve" field.</summary>
    public const int RotationXCurveFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_rotationXCurve_codec
        = pb::FieldCodec.ForMessage(34, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> rotationXCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> RotationXCurve {
      get { return rotationXCurve_; }
    }

    /// <summary>Field number for the "rotation_y_curve" field.</summary>
    public const int RotationYCurveFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_rotationYCurve_codec
        = pb::FieldCodec.ForMessage(42, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> rotationYCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> RotationYCurve {
      get { return rotationYCurve_; }
    }

    /// <summary>Field number for the "rotation_z_curve" field.</summary>
    public const int RotationZCurveFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_rotationZCurve_codec
        = pb::FieldCodec.ForMessage(50, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> rotationZCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> RotationZCurve {
      get { return rotationZCurve_; }
    }

    /// <summary>Field number for the "rotation_w_curve" field.</summary>
    public const int RotationWCurveFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_rotationWCurve_codec
        = pb::FieldCodec.ForMessage(58, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> rotationWCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> RotationWCurve {
      get { return rotationWCurve_; }
    }

    /// <summary>Field number for the "motion_name" field.</summary>
    public const int MotionNameFieldNumber = 8;
    private string motionName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MotionName {
      get { return motionName_ ?? ""; }
      set {
        motionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "motion_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMotionName {
      get { return motionName_ != null; }
    }
    /// <summary>Gets whether the "motion_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMotionNameDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "motion_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMotionName() {
      motionName_ = null;
    }

    /// <summary>Field number for the "position_y_curve" field.</summary>
    public const int PositionYCurveFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_positionYCurve_codec
        = pb::FieldCodec.ForMessage(74, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> positionYCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    /// <summary>
    ///Y轴的位移动画
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> PositionYCurve {
      get { return positionYCurve_; }
    }

    /// <summary>Field number for the "none_rotation" field.</summary>
    public const int NoneRotationFieldNumber = 10;
    private bool noneRotation_;
    /// <summary>
    ///没有旋转
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NoneRotation {
      get { if ((_hasBits0 & 2) != 0) { return noneRotation_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 512;
        noneRotation_ = value;
      }
    }
    /// <summary>Gets whether the "none_rotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNoneRotation {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "none_rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNoneRotationDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "none_rotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNoneRotation() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "none_postion_xz" field.</summary>
    public const int NonePostionXzFieldNumber = 11;
    private bool nonePostionXz_;
    /// <summary>
    ///没有平面位移
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NonePostionXz {
      get { if ((_hasBits0 & 4) != 0) { return nonePostionXz_; } else { return false; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 1024;
        nonePostionXz_ = value;
      }
    }
    /// <summary>Gets whether the "none_postion_xz" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNonePostionXz {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "none_postion_xz" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNonePostionXzDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "none_postion_xz" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNonePostionXz() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "none_postion_y" field.</summary>
    public const int NonePostionYFieldNumber = 12;
    private bool nonePostionY_;
    /// <summary>
    ///没有垂直方向位移
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NonePostionY {
      get { if ((_hasBits0 & 8) != 0) { return nonePostionY_; } else { return false; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 2048;
        nonePostionY_ = value;
      }
    }
    /// <summary>Gets whether the "none_postion_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNonePostionY {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "none_postion_y" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNonePostionYDirty {
      get { return (_dirtyBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "none_postion_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNonePostionY() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "is_loop" field.</summary>
    public const int IsLoopFieldNumber = 17;
    private bool isLoop_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLoop {
      get { if ((_hasBits0 & 16) != 0) { return isLoop_; } else { return false; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 4096;
        isLoop_ = value;
      }
    }
    /// <summary>Gets whether the "is_loop" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsLoop {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "is_loop" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsLoopDirty {
      get { return (_dirtyBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "is_loop" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsLoop() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "scale_x_curve" field.</summary>
    public const int ScaleXCurveFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_scaleXCurve_codec
        = pb::FieldCodec.ForMessage(146, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> scaleXCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> ScaleXCurve {
      get { return scaleXCurve_; }
    }

    /// <summary>Field number for the "scale_y_curve" field.</summary>
    public const int ScaleYCurveFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_scaleYCurve_codec
        = pb::FieldCodec.ForMessage(154, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> scaleYCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> ScaleYCurve {
      get { return scaleYCurve_; }
    }

    /// <summary>Field number for the "scale_z_curve" field.</summary>
    public const int ScaleZCurveFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Protocol.MoveKeyFrame> _repeated_scaleZCurve_codec
        = pb::FieldCodec.ForMessage(162, global::Protocol.MoveKeyFrame.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveKeyFrame> scaleZCurve_ = new pbc::RepeatedField<global::Protocol.MoveKeyFrame>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveKeyFrame> ScaleZCurve {
      get { return scaleZCurve_; }
    }

    /// <summary>Field number for the "motion_type" field.</summary>
    public const int MotionTypeFieldNumber = 21;
    private uint motionType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MotionType {
      get { if ((_hasBits0 & 32) != 0) { return motionType_; } else { return 0; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 65536;
        motionType_ = value;
      }
    }
    /// <summary>Gets whether the "motion_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMotionType {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "motion_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMotionTypeDirty {
      get { return (_dirtyBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "motion_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMotionType() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MoveMotion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MoveMotion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Length, other.Length)) return false;
      if(!positionXCurve_.Equals(other.positionXCurve_)) return false;
      if(!positionZCurve_.Equals(other.positionZCurve_)) return false;
      if(!rotationXCurve_.Equals(other.rotationXCurve_)) return false;
      if(!rotationYCurve_.Equals(other.rotationYCurve_)) return false;
      if(!rotationZCurve_.Equals(other.rotationZCurve_)) return false;
      if(!rotationWCurve_.Equals(other.rotationWCurve_)) return false;
      if (MotionName != other.MotionName) return false;
      if(!positionYCurve_.Equals(other.positionYCurve_)) return false;
      if (NoneRotation != other.NoneRotation) return false;
      if (NonePostionXz != other.NonePostionXz) return false;
      if (NonePostionY != other.NonePostionY) return false;
      if (IsLoop != other.IsLoop) return false;
      if(!scaleXCurve_.Equals(other.scaleXCurve_)) return false;
      if(!scaleYCurve_.Equals(other.scaleYCurve_)) return false;
      if(!scaleZCurve_.Equals(other.scaleZCurve_)) return false;
      if (MotionType != other.MotionType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasLength) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Length);
      hash ^= positionXCurve_.GetHashCode();
      hash ^= positionZCurve_.GetHashCode();
      hash ^= rotationXCurve_.GetHashCode();
      hash ^= rotationYCurve_.GetHashCode();
      hash ^= rotationZCurve_.GetHashCode();
      hash ^= rotationWCurve_.GetHashCode();
      if (HasMotionName) hash ^= MotionName.GetHashCode();
      hash ^= positionYCurve_.GetHashCode();
      if (HasNoneRotation) hash ^= NoneRotation.GetHashCode();
      if (HasNonePostionXz) hash ^= NonePostionXz.GetHashCode();
      if (HasNonePostionY) hash ^= NonePostionY.GetHashCode();
      if (HasIsLoop) hash ^= IsLoop.GetHashCode();
      hash ^= scaleXCurve_.GetHashCode();
      hash ^= scaleYCurve_.GetHashCode();
      hash ^= scaleZCurve_.GetHashCode();
      if (HasMotionType) hash ^= MotionType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Length);
      }
      positionXCurve_.WriteTo(output, _repeated_positionXCurve_codec);
      positionZCurve_.WriteTo(output, _repeated_positionZCurve_codec);
      rotationXCurve_.WriteTo(output, _repeated_rotationXCurve_codec);
      rotationYCurve_.WriteTo(output, _repeated_rotationYCurve_codec);
      rotationZCurve_.WriteTo(output, _repeated_rotationZCurve_codec);
      rotationWCurve_.WriteTo(output, _repeated_rotationWCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasMotionName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionNameDirty)) {
        output.WriteRawTag(66);
        output.WriteString(MotionName);
      }
      positionYCurve_.WriteTo(output, _repeated_positionYCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasNoneRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNoneRotationDirty)) {
        output.WriteRawTag(80);
        output.WriteBool(NoneRotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNonePostionXz)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionXzDirty)) {
        output.WriteRawTag(88);
        output.WriteBool(NonePostionXz);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNonePostionY)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionYDirty)) {
        output.WriteRawTag(96);
        output.WriteBool(NonePostionY);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsLoop)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsLoopDirty)) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsLoop);
      }
      scaleXCurve_.WriteTo(output, _repeated_scaleXCurve_codec);
      scaleYCurve_.WriteTo(output, _repeated_scaleYCurve_codec);
      scaleZCurve_.WriteTo(output, _repeated_scaleZCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasMotionType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionTypeDirty)) {
        output.WriteRawTag(168, 1);
        output.WriteUInt32(MotionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Length);
      }
      positionXCurve_.WriteTo(ref output, _repeated_positionXCurve_codec);
      positionZCurve_.WriteTo(ref output, _repeated_positionZCurve_codec);
      rotationXCurve_.WriteTo(ref output, _repeated_rotationXCurve_codec);
      rotationYCurve_.WriteTo(ref output, _repeated_rotationYCurve_codec);
      rotationZCurve_.WriteTo(ref output, _repeated_rotationZCurve_codec);
      rotationWCurve_.WriteTo(ref output, _repeated_rotationWCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasMotionName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionNameDirty)) {
        output.WriteRawTag(66);
        output.WriteString(MotionName);
      }
      positionYCurve_.WriteTo(ref output, _repeated_positionYCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasNoneRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNoneRotationDirty)) {
        output.WriteRawTag(80);
        output.WriteBool(NoneRotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNonePostionXz)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionXzDirty)) {
        output.WriteRawTag(88);
        output.WriteBool(NonePostionXz);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasNonePostionY)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionYDirty)) {
        output.WriteRawTag(96);
        output.WriteBool(NonePostionY);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsLoop)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsLoopDirty)) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsLoop);
      }
      scaleXCurve_.WriteTo(ref output, _repeated_scaleXCurve_codec);
      scaleYCurve_.WriteTo(ref output, _repeated_scaleYCurve_codec);
      scaleZCurve_.WriteTo(ref output, _repeated_scaleZCurve_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasMotionType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionTypeDirty)) {
        output.WriteRawTag(168, 1);
        output.WriteUInt32(MotionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasLength)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        size += 1 + 4;
      }
      size += positionXCurve_.CalculateSize(_repeated_positionXCurve_codec);
      size += positionZCurve_.CalculateSize(_repeated_positionZCurve_codec);
      size += rotationXCurve_.CalculateSize(_repeated_rotationXCurve_codec);
      size += rotationYCurve_.CalculateSize(_repeated_rotationYCurve_codec);
      size += rotationZCurve_.CalculateSize(_repeated_rotationZCurve_codec);
      size += rotationWCurve_.CalculateSize(_repeated_rotationWCurve_codec);
      if ((scope == pb.WriteScope.FULL && HasMotionName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMotionNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MotionName);
      }
      size += positionYCurve_.CalculateSize(_repeated_positionYCurve_codec);
      if ((scope == pb.WriteScope.FULL && HasNoneRotation)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNoneRotationDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasNonePostionXz)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionXzDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasNonePostionY)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNonePostionYDirty)) {
        size += 1 + 1;
      }
      if ((scope == pb.WriteScope.FULL && HasIsLoop)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsLoopDirty)) {
        size += 2 + 1;
      }
      size += scaleXCurve_.CalculateSize(_repeated_scaleXCurve_codec);
      size += scaleYCurve_.CalculateSize(_repeated_scaleYCurve_codec);
      size += scaleZCurve_.CalculateSize(_repeated_scaleZCurve_codec);
      if ((scope == pb.WriteScope.FULL && HasMotionType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMotionTypeDirty)) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(MotionType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MoveMotion other) {
      if (other == null) {
        return;
      }
      if (other.HasLength) {
        Length = other.Length;
      }
      positionXCurve_.Add(other.positionXCurve_);
      positionZCurve_.Add(other.positionZCurve_);
      rotationXCurve_.Add(other.rotationXCurve_);
      rotationYCurve_.Add(other.rotationYCurve_);
      rotationZCurve_.Add(other.rotationZCurve_);
      rotationWCurve_.Add(other.rotationWCurve_);
      if (other.HasMotionName) {
        MotionName = other.MotionName;
      }
      positionYCurve_.Add(other.positionYCurve_);
      if (other.HasNoneRotation) {
        NoneRotation = other.NoneRotation;
      }
      if (other.HasNonePostionXz) {
        NonePostionXz = other.NonePostionXz;
      }
      if (other.HasNonePostionY) {
        NonePostionY = other.NonePostionY;
      }
      if (other.HasIsLoop) {
        IsLoop = other.IsLoop;
      }
      scaleXCurve_.Add(other.scaleXCurve_);
      scaleYCurve_.Add(other.scaleYCurve_);
      scaleZCurve_.Add(other.scaleZCurve_);
      if (other.HasMotionType) {
        MotionType = other.MotionType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Length = input.ReadFloat();
            break;
          }
          case 18: {
            positionXCurve_.AddEntriesFrom(input, _repeated_positionXCurve_codec);
            break;
          }
          case 26: {
            positionZCurve_.AddEntriesFrom(input, _repeated_positionZCurve_codec);
            break;
          }
          case 34: {
            rotationXCurve_.AddEntriesFrom(input, _repeated_rotationXCurve_codec);
            break;
          }
          case 42: {
            rotationYCurve_.AddEntriesFrom(input, _repeated_rotationYCurve_codec);
            break;
          }
          case 50: {
            rotationZCurve_.AddEntriesFrom(input, _repeated_rotationZCurve_codec);
            break;
          }
          case 58: {
            rotationWCurve_.AddEntriesFrom(input, _repeated_rotationWCurve_codec);
            break;
          }
          case 66: {
            MotionName = input.ReadString();
            break;
          }
          case 74: {
            positionYCurve_.AddEntriesFrom(input, _repeated_positionYCurve_codec);
            break;
          }
          case 80: {
            NoneRotation = input.ReadBool();
            break;
          }
          case 88: {
            NonePostionXz = input.ReadBool();
            break;
          }
          case 96: {
            NonePostionY = input.ReadBool();
            break;
          }
          case 136: {
            IsLoop = input.ReadBool();
            break;
          }
          case 146: {
            scaleXCurve_.AddEntriesFrom(input, _repeated_scaleXCurve_codec);
            break;
          }
          case 154: {
            scaleYCurve_.AddEntriesFrom(input, _repeated_scaleYCurve_codec);
            break;
          }
          case 162: {
            scaleZCurve_.AddEntriesFrom(input, _repeated_scaleZCurve_codec);
            break;
          }
          case 168: {
            MotionType = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Length = input.ReadFloat();
            break;
          }
          case 18: {
            positionXCurve_.AddEntriesFrom(ref input, _repeated_positionXCurve_codec);
            break;
          }
          case 26: {
            positionZCurve_.AddEntriesFrom(ref input, _repeated_positionZCurve_codec);
            break;
          }
          case 34: {
            rotationXCurve_.AddEntriesFrom(ref input, _repeated_rotationXCurve_codec);
            break;
          }
          case 42: {
            rotationYCurve_.AddEntriesFrom(ref input, _repeated_rotationYCurve_codec);
            break;
          }
          case 50: {
            rotationZCurve_.AddEntriesFrom(ref input, _repeated_rotationZCurve_codec);
            break;
          }
          case 58: {
            rotationWCurve_.AddEntriesFrom(ref input, _repeated_rotationWCurve_codec);
            break;
          }
          case 66: {
            MotionName = input.ReadString();
            break;
          }
          case 74: {
            positionYCurve_.AddEntriesFrom(ref input, _repeated_positionYCurve_codec);
            break;
          }
          case 80: {
            NoneRotation = input.ReadBool();
            break;
          }
          case 88: {
            NonePostionXz = input.ReadBool();
            break;
          }
          case 96: {
            NonePostionY = input.ReadBool();
            break;
          }
          case 136: {
            IsLoop = input.ReadBool();
            break;
          }
          case 146: {
            scaleXCurve_.AddEntriesFrom(ref input, _repeated_scaleXCurve_codec);
            break;
          }
          case 154: {
            scaleYCurve_.AddEntriesFrom(ref input, _repeated_scaleYCurve_codec);
            break;
          }
          case 162: {
            scaleZCurve_.AddEntriesFrom(ref input, _repeated_scaleZCurve_codec);
            break;
          }
          case 168: {
            MotionType = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///混合节点
  /// </summary>
  public sealed partial class BlendNode : pb::IMessage<BlendNode>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BlendNode> _parser = new pb::MessageParser<BlendNode>(() => new BlendNode());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BlendNode> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BlendNode() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BlendNode(BlendNode other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      moveSpeed_ = other.moveSpeed_;
      angleSpeed_ = other.angleSpeed_;
      xPostion_ = other.xPostion_;
      yPostion_ = other.yPostion_;
      moveDir_ = other.HasMoveDir ? other.moveDir_.Clone() : null;
      length_ = other.length_;
      isAddtion_ = other.isAddtion_;
      motion_ = other.HasMotion ? other.motion_.Clone() : null;
      boundCenter_ = other.HasBoundCenter ? other.boundCenter_.Clone() : null;
      boundSize_ = other.HasBoundSize ? other.boundSize_.Clone() : null;
      headPosition_ = other.HasHeadPosition ? other.headPosition_.Clone() : null;
      headRotation_ = other.HasHeadRotation ? other.headRotation_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BlendNode Clone() {
      return new BlendNode(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "move_speed" field.</summary>
    public const int MoveSpeedFieldNumber = 1;
    private float moveSpeed_;
    /// <summary>
    ///移动速度
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MoveSpeed {
      get { if ((_hasBits0 & 1) != 0) { return moveSpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        moveSpeed_ = value;
      }
    }
    /// <summary>Gets whether the "move_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMoveSpeed {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "move_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMoveSpeedDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "move_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMoveSpeed() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "angle_speed" field.</summary>
    public const int AngleSpeedFieldNumber = 2;
    private float angleSpeed_;
    /// <summary>
    ///角速度(Y轴)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float AngleSpeed {
      get { if ((_hasBits0 & 2) != 0) { return angleSpeed_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        angleSpeed_ = value;
      }
    }
    /// <summary>Gets whether the "angle_speed" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAngleSpeed {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "angle_speed" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAngleSpeedDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "angle_speed" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAngleSpeed() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "x_postion" field.</summary>
    public const int XPostionFieldNumber = 3;
    private float xPostion_;
    /// <summary>
    ///x的位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float XPostion {
      get { if ((_hasBits0 & 4) != 0) { return xPostion_; } else { return 0F; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        xPostion_ = value;
      }
    }
    /// <summary>Gets whether the "x_postion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasXPostion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "x_postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsXPostionDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "x_postion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearXPostion() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "y_postion" field.</summary>
    public const int YPostionFieldNumber = 4;
    private float yPostion_;
    /// <summary>
    ///y的位置（1d不需要）
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float YPostion {
      get { if ((_hasBits0 & 8) != 0) { return yPostion_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        yPostion_ = value;
      }
    }
    /// <summary>Gets whether the "y_postion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYPostion {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "y_postion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsYPostionDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "y_postion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYPostion() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "move_dir" field.</summary>
    public const int MoveDirFieldNumber = 5;
    private global::Protocol.Float3 moveDir_;
    /// <summary>
    ///移动朝向（相对模型自身正方向）
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 MoveDir {
      get { return moveDir_; }
      set {
        moveDir_ = value;
      }
    }
    /// <summary>Gets whether the move_dir field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMoveDir {
      get { return moveDir_ != null; }
    }
    /// <summary>Clears the value of the move_dir field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMoveDir() {
      moveDir_ = null;
    }
    /// <summary>Gets whether the "move_dir" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMoveDirDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 6;
    private float length_;
    /// <summary>
    ///长度
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Length {
      get { if ((_hasBits0 & 16) != 0) { return length_; } else { return 0F; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 32;
        length_ = value;
      }
    }
    /// <summary>Gets whether the "length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLength {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "length" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLengthDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLength() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "is_addtion" field.</summary>
    public const int IsAddtionFieldNumber = 7;
    private bool isAddtion_;
    /// <summary>
    ///是否为手动添加
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAddtion {
      get { if ((_hasBits0 & 32) != 0) { return isAddtion_; } else { return false; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 64;
        isAddtion_ = value;
      }
    }
    /// <summary>Gets whether the "is_addtion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsAddtion {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "is_addtion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsAddtionDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "is_addtion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsAddtion() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "motion" field.</summary>
    public const int MotionFieldNumber = 8;
    private global::Protocol.MoveMotion motion_;
    /// <summary>
    ///完整的动画信息
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.MoveMotion Motion {
      get { return motion_; }
      set {
        motion_ = value;
      }
    }
    /// <summary>Gets whether the motion field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMotion {
      get { return motion_ != null; }
    }
    /// <summary>Clears the value of the motion field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMotion() {
      motion_ = null;
    }
    /// <summary>Gets whether the "motion" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMotionDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }

    /// <summary>Field number for the "bound_center" field.</summary>
    public const int BoundCenterFieldNumber = 9;
    private global::Protocol.Float3 boundCenter_;
    /// <summary>
    ///受击盒中心点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 BoundCenter {
      get { return boundCenter_; }
      set {
        boundCenter_ = value;
      }
    }
    /// <summary>Gets whether the bound_center field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBoundCenter {
      get { return boundCenter_ != null; }
    }
    /// <summary>Clears the value of the bound_center field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBoundCenter() {
      boundCenter_ = null;
    }
    /// <summary>Gets whether the "bound_center" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBoundCenterDirty {
      get { return (_dirtyBits0 & 256) != 0; }
    }

    /// <summary>Field number for the "bound_size" field.</summary>
    public const int BoundSizeFieldNumber = 10;
    private global::Protocol.Float3 boundSize_;
    /// <summary>
    ///受击盒大小
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 BoundSize {
      get { return boundSize_; }
      set {
        boundSize_ = value;
      }
    }
    /// <summary>Gets whether the bound_size field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBoundSize {
      get { return boundSize_ != null; }
    }
    /// <summary>Clears the value of the bound_size field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBoundSize() {
      boundSize_ = null;
    }
    /// <summary>Gets whether the "bound_size" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBoundSizeDirty {
      get { return (_dirtyBits0 & 512) != 0; }
    }

    /// <summary>Field number for the "head_position" field.</summary>
    public const int HeadPositionFieldNumber = 11;
    private global::Protocol.Float3 headPosition_;
    /// <summary>
    ///头部位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 HeadPosition {
      get { return headPosition_; }
      set {
        headPosition_ = value;
      }
    }
    /// <summary>Gets whether the head_position field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadPosition {
      get { return headPosition_ != null; }
    }
    /// <summary>Clears the value of the head_position field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadPosition() {
      headPosition_ = null;
    }
    /// <summary>Gets whether the "head_position" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeadPositionDirty {
      get { return (_dirtyBits0 & 1024) != 0; }
    }

    /// <summary>Field number for the "head_rotation" field.</summary>
    public const int HeadRotationFieldNumber = 12;
    private global::Protocol.Float3 headRotation_;
    /// <summary>
    ///头部旋转
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 HeadRotation {
      get { return headRotation_; }
      set {
        headRotation_ = value;
      }
    }
    /// <summary>Gets whether the head_rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadRotation {
      get { return headRotation_ != null; }
    }
    /// <summary>Clears the value of the head_rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadRotation() {
      headRotation_ = null;
    }
    /// <summary>Gets whether the "head_rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeadRotationDirty {
      get { return (_dirtyBits0 & 2048) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BlendNode);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BlendNode other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MoveSpeed, other.MoveSpeed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AngleSpeed, other.AngleSpeed)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(XPostion, other.XPostion)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(YPostion, other.YPostion)) return false;
      if (!object.Equals(MoveDir, other.MoveDir)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Length, other.Length)) return false;
      if (IsAddtion != other.IsAddtion) return false;
      if (!object.Equals(Motion, other.Motion)) return false;
      if (!object.Equals(BoundCenter, other.BoundCenter)) return false;
      if (!object.Equals(BoundSize, other.BoundSize)) return false;
      if (!object.Equals(HeadPosition, other.HeadPosition)) return false;
      if (!object.Equals(HeadRotation, other.HeadRotation)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMoveSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MoveSpeed);
      if (HasAngleSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AngleSpeed);
      if (HasXPostion) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(XPostion);
      if (HasYPostion) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(YPostion);
      if (HasMoveDir) hash ^= MoveDir.GetHashCode();
      if (HasLength) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Length);
      if (HasIsAddtion) hash ^= IsAddtion.GetHashCode();
      if (HasMotion) hash ^= Motion.GetHashCode();
      if (HasBoundCenter) hash ^= BoundCenter.GetHashCode();
      if (HasBoundSize) hash ^= BoundSize.GetHashCode();
      if (HasHeadPosition) hash ^= HeadPosition.GetHashCode();
      if (HasHeadRotation) hash ^= HeadRotation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasMoveSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMoveSpeedDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(MoveSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAngleSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAngleSpeedDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(AngleSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasXPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsXPostionDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(XPostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasYPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsYPostionDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(YPostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMoveDir)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMoveDirDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(MoveDir);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(Length);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsAddtion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsAddtionDirty)) {
        output.WriteRawTag(56);
        output.WriteBool(IsAddtion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMotion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionDirty)) {
        output.WriteRawTag(66);
        output.WriteMessage(Motion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBoundCenter)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBoundCenterDirty)) {
        output.WriteRawTag(74);
        output.WriteMessage(BoundCenter);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBoundSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBoundSizeDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(BoundSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadPositionDirty)) {
        output.WriteRawTag(90);
        output.WriteMessage(HeadPosition);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadRotationDirty)) {
        output.WriteRawTag(98);
        output.WriteMessage(HeadRotation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasMoveSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMoveSpeedDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(MoveSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasAngleSpeed)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsAngleSpeedDirty)) {
        output.WriteRawTag(21);
        output.WriteFloat(AngleSpeed);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasXPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsXPostionDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(XPostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasYPostion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsYPostionDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(YPostion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMoveDir)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMoveDirDirty)) {
        output.WriteRawTag(42);
        output.WriteMessage(MoveDir);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(Length);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsAddtion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsAddtionDirty)) {
        output.WriteRawTag(56);
        output.WriteBool(IsAddtion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasMotion)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsMotionDirty)) {
        output.WriteRawTag(66);
        output.WriteMessage(Motion);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBoundCenter)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBoundCenterDirty)) {
        output.WriteRawTag(74);
        output.WriteMessage(BoundCenter);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasBoundSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBoundSizeDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(BoundSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadPositionDirty)) {
        output.WriteRawTag(90);
        output.WriteMessage(HeadPosition);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadRotationDirty)) {
        output.WriteRawTag(98);
        output.WriteMessage(HeadRotation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasMoveSpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsMoveSpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasAngleSpeed)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsAngleSpeedDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasXPostion)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsXPostionDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasYPostion)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsYPostionDirty)) {
        size += 1 + 4;
      }
      if (HasMoveDir) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(MoveDir, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 16;
        } else {
          _dirtyBits0 &= ~16;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasLength)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasIsAddtion)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsAddtionDirty)) {
        size += 1 + 1;
      }
      if (HasMotion) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Motion, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 128;
        } else {
          _dirtyBits0 &= ~128;
        }
      }
      if (HasBoundCenter) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(BoundCenter, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 256;
        } else {
          _dirtyBits0 &= ~256;
        }
      }
      if (HasBoundSize) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(BoundSize, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 512;
        } else {
          _dirtyBits0 &= ~512;
        }
      }
      if (HasHeadPosition) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(HeadPosition, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1024;
        } else {
          _dirtyBits0 &= ~1024;
        }
      }
      if (HasHeadRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(HeadRotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2048;
        } else {
          _dirtyBits0 &= ~2048;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BlendNode other) {
      if (other == null) {
        return;
      }
      if (other.HasMoveSpeed) {
        MoveSpeed = other.MoveSpeed;
      }
      if (other.HasAngleSpeed) {
        AngleSpeed = other.AngleSpeed;
      }
      if (other.HasXPostion) {
        XPostion = other.XPostion;
      }
      if (other.HasYPostion) {
        YPostion = other.YPostion;
      }
      if (other.HasMoveDir) {
        if (!HasMoveDir) {
          MoveDir = new global::Protocol.Float3();
        }
        MoveDir.MergeFrom(other.MoveDir);
      }
      if (other.HasLength) {
        Length = other.Length;
      }
      if (other.HasIsAddtion) {
        IsAddtion = other.IsAddtion;
      }
      if (other.HasMotion) {
        if (!HasMotion) {
          Motion = new global::Protocol.MoveMotion();
        }
        Motion.MergeFrom(other.Motion);
      }
      if (other.HasBoundCenter) {
        if (!HasBoundCenter) {
          BoundCenter = new global::Protocol.Float3();
        }
        BoundCenter.MergeFrom(other.BoundCenter);
      }
      if (other.HasBoundSize) {
        if (!HasBoundSize) {
          BoundSize = new global::Protocol.Float3();
        }
        BoundSize.MergeFrom(other.BoundSize);
      }
      if (other.HasHeadPosition) {
        if (!HasHeadPosition) {
          HeadPosition = new global::Protocol.Float3();
        }
        HeadPosition.MergeFrom(other.HeadPosition);
      }
      if (other.HasHeadRotation) {
        if (!HasHeadRotation) {
          HeadRotation = new global::Protocol.Float3();
        }
        HeadRotation.MergeFrom(other.HeadRotation);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MoveSpeed = input.ReadFloat();
            break;
          }
          case 21: {
            AngleSpeed = input.ReadFloat();
            break;
          }
          case 29: {
            XPostion = input.ReadFloat();
            break;
          }
          case 37: {
            YPostion = input.ReadFloat();
            break;
          }
          case 42: {
            if (!HasMoveDir) {
              MoveDir = new global::Protocol.Float3();
            }
            input.ReadMessage(MoveDir);
            break;
          }
          case 53: {
            Length = input.ReadFloat();
            break;
          }
          case 56: {
            IsAddtion = input.ReadBool();
            break;
          }
          case 66: {
            if (!HasMotion) {
              Motion = new global::Protocol.MoveMotion();
            }
            input.ReadMessage(Motion);
            break;
          }
          case 74: {
            if (!HasBoundCenter) {
              BoundCenter = new global::Protocol.Float3();
            }
            input.ReadMessage(BoundCenter);
            break;
          }
          case 82: {
            if (!HasBoundSize) {
              BoundSize = new global::Protocol.Float3();
            }
            input.ReadMessage(BoundSize);
            break;
          }
          case 90: {
            if (!HasHeadPosition) {
              HeadPosition = new global::Protocol.Float3();
            }
            input.ReadMessage(HeadPosition);
            break;
          }
          case 98: {
            if (!HasHeadRotation) {
              HeadRotation = new global::Protocol.Float3();
            }
            input.ReadMessage(HeadRotation);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            MoveSpeed = input.ReadFloat();
            break;
          }
          case 21: {
            AngleSpeed = input.ReadFloat();
            break;
          }
          case 29: {
            XPostion = input.ReadFloat();
            break;
          }
          case 37: {
            YPostion = input.ReadFloat();
            break;
          }
          case 42: {
            if (!HasMoveDir) {
              MoveDir = new global::Protocol.Float3();
            }
            input.ReadMessage(MoveDir);
            break;
          }
          case 53: {
            Length = input.ReadFloat();
            break;
          }
          case 56: {
            IsAddtion = input.ReadBool();
            break;
          }
          case 66: {
            if (!HasMotion) {
              Motion = new global::Protocol.MoveMotion();
            }
            input.ReadMessage(Motion);
            break;
          }
          case 74: {
            if (!HasBoundCenter) {
              BoundCenter = new global::Protocol.Float3();
            }
            input.ReadMessage(BoundCenter);
            break;
          }
          case 82: {
            if (!HasBoundSize) {
              BoundSize = new global::Protocol.Float3();
            }
            input.ReadMessage(BoundSize);
            break;
          }
          case 90: {
            if (!HasHeadPosition) {
              HeadPosition = new global::Protocol.Float3();
            }
            input.ReadMessage(HeadPosition);
            break;
          }
          case 98: {
            if (!HasHeadRotation) {
              HeadRotation = new global::Protocol.Float3();
            }
            input.ReadMessage(HeadRotation);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///混合器
  /// </summary>
  public sealed partial class Blender : pb::IMessage<Blender>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Blender> _parser = new pb::MessageParser<Blender>(() => new Blender());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Blender> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Blender() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Blender(Blender other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      blendType_ = other.blendType_;
      nodeList_ = other.nodeList_.Clone();
      length_ = other.length_;
      name_ = other.name_;
      isFixAngle_ = other.isFixAngle_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Blender Clone() {
      return new Blender(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "blend_type" field.</summary>
    public const int BlendTypeFieldNumber = 1;
    private global::Protocol.BlendType blendType_;
    /// <summary>
    ///混合模式
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.BlendType BlendType {
      get { if ((_hasBits0 & 1) != 0) { return blendType_; } else { return global::Protocol.BlendType.BtNone; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        blendType_ = value;
      }
    }
    /// <summary>Gets whether the "blend_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBlendType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "blend_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBlendTypeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "blend_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBlendType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "node_list" field.</summary>
    public const int NodeListFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Protocol.BlendNode> _repeated_nodeList_codec
        = pb::FieldCodec.ForMessage(18, global::Protocol.BlendNode.Parser);
    private readonly pbc::RepeatedField<global::Protocol.BlendNode> nodeList_ = new pbc::RepeatedField<global::Protocol.BlendNode>();
    /// <summary>
    ///节点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.BlendNode> NodeList {
      get { return nodeList_; }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 3;
    private float length_;
    /// <summary>
    ///持续时间
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Length {
      get { if ((_hasBits0 & 2) != 0) { return length_; } else { return 0F; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 4;
        length_ = value;
      }
    }
    /// <summary>Gets whether the "length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLength {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "length" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLengthDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLength() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 4;
    private string name_;
    /// <summary>
    ///名字
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_ ?? ""; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Gets whether the "name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNameDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "is_fix_angle" field.</summary>
    public const int IsFixAngleFieldNumber = 5;
    private bool isFixAngle_;
    /// <summary>
    ///是否固定角度
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFixAngle {
      get { if ((_hasBits0 & 4) != 0) { return isFixAngle_; } else { return false; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 16;
        isFixAngle_ = value;
      }
    }
    /// <summary>Gets whether the "is_fix_angle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsFixAngle {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "is_fix_angle" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsFixAngleDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "is_fix_angle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsFixAngle() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Blender);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Blender other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BlendType != other.BlendType) return false;
      if(!nodeList_.Equals(other.nodeList_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Length, other.Length)) return false;
      if (Name != other.Name) return false;
      if (IsFixAngle != other.IsFixAngle) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBlendType) hash ^= BlendType.GetHashCode();
      hash ^= nodeList_.GetHashCode();
      if (HasLength) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Length);
      if (HasName) hash ^= Name.GetHashCode();
      if (HasIsFixAngle) hash ^= IsFixAngle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasBlendType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBlendTypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BlendType);
      }
      nodeList_.WriteTo(output, _repeated_nodeList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Length);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNameDirty)) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsFixAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsFixAngleDirty)) {
        output.WriteRawTag(40);
        output.WriteBool(IsFixAngle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasBlendType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBlendTypeDirty)) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BlendType);
      }
      nodeList_.WriteTo(ref output, _repeated_nodeList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasLength)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        output.WriteRawTag(29);
        output.WriteFloat(Length);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsNameDirty)) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsFixAngle)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsFixAngleDirty)) {
        output.WriteRawTag(40);
        output.WriteBool(IsFixAngle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasBlendType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBlendTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BlendType);
      }
      size += nodeList_.CalculateSize(_repeated_nodeList_codec);
      if ((scope == pb.WriteScope.FULL && HasLength)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLengthDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if ((scope == pb.WriteScope.FULL && HasIsFixAngle)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsFixAngleDirty)) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Blender other) {
      if (other == null) {
        return;
      }
      if (other.HasBlendType) {
        BlendType = other.BlendType;
      }
      nodeList_.Add(other.nodeList_);
      if (other.HasLength) {
        Length = other.Length;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasIsFixAngle) {
        IsFixAngle = other.IsFixAngle;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            BlendType = (global::Protocol.BlendType) input.ReadEnum();
            break;
          }
          case 18: {
            nodeList_.AddEntriesFrom(input, _repeated_nodeList_codec);
            break;
          }
          case 29: {
            Length = input.ReadFloat();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
          case 40: {
            IsFixAngle = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            BlendType = (global::Protocol.BlendType) input.ReadEnum();
            break;
          }
          case 18: {
            nodeList_.AddEntriesFrom(ref input, _repeated_nodeList_codec);
            break;
          }
          case 29: {
            Length = input.ReadFloat();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
          case 40: {
            IsFixAngle = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MoveControllerCfg : pb::IMessage<MoveControllerCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MoveControllerCfg> _parser = new pb::MessageParser<MoveControllerCfg>(() => new MoveControllerCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MoveControllerCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveControllerCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveControllerCfg(MoveControllerCfg other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      exportMotions_ = other.exportMotions_.Clone();
      exportBlenders_ = other.exportBlenders_.Clone();
      weaponPath_ = other.weaponPath_;
      boundPathList_ = other.boundPathList_.Clone();
      headPath_ = other.headPath_;
      headSize_ = other.headSize_;
      modelPath_ = other.modelPath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MoveControllerCfg Clone() {
      return new MoveControllerCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "export_motions" field.</summary>
    public const int ExportMotionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Protocol.MoveMotion> _repeated_exportMotions_codec
        = pb::FieldCodec.ForMessage(10, global::Protocol.MoveMotion.Parser);
    private readonly pbc::RepeatedField<global::Protocol.MoveMotion> exportMotions_ = new pbc::RepeatedField<global::Protocol.MoveMotion>();
    /// <summary>
    ///导出的动画
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.MoveMotion> ExportMotions {
      get { return exportMotions_; }
    }

    /// <summary>Field number for the "export_blenders" field.</summary>
    public const int ExportBlendersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Protocol.Blender> _repeated_exportBlenders_codec
        = pb::FieldCodec.ForMessage(18, global::Protocol.Blender.Parser);
    private readonly pbc::RepeatedField<global::Protocol.Blender> exportBlenders_ = new pbc::RepeatedField<global::Protocol.Blender>();
    /// <summary>
    ///导出的混合器
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.Blender> ExportBlenders {
      get { return exportBlenders_; }
    }

    /// <summary>Field number for the "weapon_path" field.</summary>
    public const int WeaponPathFieldNumber = 3;
    private string weaponPath_;
    /// <summary>
    ///武器骨骼点
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WeaponPath {
      get { return weaponPath_ ?? ""; }
      set {
        weaponPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "weapon_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWeaponPath {
      get { return weaponPath_ != null; }
    }
    /// <summary>Gets whether the "weapon_path" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWeaponPathDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "weapon_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWeaponPath() {
      weaponPath_ = null;
    }

    /// <summary>Field number for the "bound_path_list" field.</summary>
    public const int BoundPathListFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_boundPathList_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> boundPathList_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///组成包围盒的节点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> BoundPathList {
      get { return boundPathList_; }
    }

    /// <summary>Field number for the "head_path" field.</summary>
    public const int HeadPathFieldNumber = 5;
    private string headPath_;
    /// <summary>
    ///头部路径
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HeadPath {
      get { return headPath_ ?? ""; }
      set {
        headPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "head_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadPath {
      get { return headPath_ != null; }
    }
    /// <summary>Gets whether the "head_path" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeadPathDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "head_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadPath() {
      headPath_ = null;
    }

    /// <summary>Field number for the "head_size" field.</summary>
    public const int HeadSizeFieldNumber = 6;
    private float headSize_;
    /// <summary>
    ///头的大小
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float HeadSize {
      get { if ((_hasBits0 & 1) != 0) { return headSize_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 32;
        headSize_ = value;
      }
    }
    /// <summary>Gets whether the "head_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "head_size" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeadSizeDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "head_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "model_path" field.</summary>
    public const int ModelPathFieldNumber = 7;
    private string modelPath_;
    /// <summary>
    ///模型位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelPath {
      get { return modelPath_ ?? ""; }
      set {
        modelPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "model_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelPath {
      get { return modelPath_ != null; }
    }
    /// <summary>Gets whether the "model_path" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelPathDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "model_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelPath() {
      modelPath_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MoveControllerCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MoveControllerCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!exportMotions_.Equals(other.exportMotions_)) return false;
      if(!exportBlenders_.Equals(other.exportBlenders_)) return false;
      if (WeaponPath != other.WeaponPath) return false;
      if(!boundPathList_.Equals(other.boundPathList_)) return false;
      if (HeadPath != other.HeadPath) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(HeadSize, other.HeadSize)) return false;
      if (ModelPath != other.ModelPath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= exportMotions_.GetHashCode();
      hash ^= exportBlenders_.GetHashCode();
      if (HasWeaponPath) hash ^= WeaponPath.GetHashCode();
      hash ^= boundPathList_.GetHashCode();
      if (HasHeadPath) hash ^= HeadPath.GetHashCode();
      if (HasHeadSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(HeadSize);
      if (HasModelPath) hash ^= ModelPath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      exportMotions_.WriteTo(output, _repeated_exportMotions_codec);
      exportBlenders_.WriteTo(output, _repeated_exportBlenders_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasWeaponPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWeaponPathDirty)) {
        output.WriteRawTag(26);
        output.WriteString(WeaponPath);
      }
      boundPathList_.WriteTo(output, _repeated_boundPathList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadPathDirty)) {
        output.WriteRawTag(42);
        output.WriteString(HeadPath);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadSizeDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(HeadSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelPathDirty)) {
        output.WriteRawTag(58);
        output.WriteString(ModelPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      exportMotions_.WriteTo(ref output, _repeated_exportMotions_codec);
      exportBlenders_.WriteTo(ref output, _repeated_exportBlenders_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasWeaponPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWeaponPathDirty)) {
        output.WriteRawTag(26);
        output.WriteString(WeaponPath);
      }
      boundPathList_.WriteTo(ref output, _repeated_boundPathList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadPathDirty)) {
        output.WriteRawTag(42);
        output.WriteString(HeadPath);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHeadSize)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeadSizeDirty)) {
        output.WriteRawTag(53);
        output.WriteFloat(HeadSize);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelPath)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelPathDirty)) {
        output.WriteRawTag(58);
        output.WriteString(ModelPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      size += exportMotions_.CalculateSize(_repeated_exportMotions_codec);
      size += exportBlenders_.CalculateSize(_repeated_exportBlenders_codec);
      if ((scope == pb.WriteScope.FULL && HasWeaponPath)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWeaponPathDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WeaponPath);
      }
      size += boundPathList_.CalculateSize(_repeated_boundPathList_codec);
      if ((scope == pb.WriteScope.FULL && HasHeadPath)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHeadPathDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HeadPath);
      }
      if ((scope == pb.WriteScope.FULL && HasHeadSize)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHeadSizeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasModelPath)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsModelPathDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelPath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MoveControllerCfg other) {
      if (other == null) {
        return;
      }
      exportMotions_.Add(other.exportMotions_);
      exportBlenders_.Add(other.exportBlenders_);
      if (other.HasWeaponPath) {
        WeaponPath = other.WeaponPath;
      }
      boundPathList_.Add(other.boundPathList_);
      if (other.HasHeadPath) {
        HeadPath = other.HeadPath;
      }
      if (other.HasHeadSize) {
        HeadSize = other.HeadSize;
      }
      if (other.HasModelPath) {
        ModelPath = other.ModelPath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            exportMotions_.AddEntriesFrom(input, _repeated_exportMotions_codec);
            break;
          }
          case 18: {
            exportBlenders_.AddEntriesFrom(input, _repeated_exportBlenders_codec);
            break;
          }
          case 26: {
            WeaponPath = input.ReadString();
            break;
          }
          case 34: {
            boundPathList_.AddEntriesFrom(input, _repeated_boundPathList_codec);
            break;
          }
          case 42: {
            HeadPath = input.ReadString();
            break;
          }
          case 53: {
            HeadSize = input.ReadFloat();
            break;
          }
          case 58: {
            ModelPath = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            exportMotions_.AddEntriesFrom(ref input, _repeated_exportMotions_codec);
            break;
          }
          case 18: {
            exportBlenders_.AddEntriesFrom(ref input, _repeated_exportBlenders_codec);
            break;
          }
          case 26: {
            WeaponPath = input.ReadString();
            break;
          }
          case 34: {
            boundPathList_.AddEntriesFrom(ref input, _repeated_boundPathList_codec);
            break;
          }
          case 42: {
            HeadPath = input.ReadString();
            break;
          }
          case 53: {
            HeadSize = input.ReadFloat();
            break;
          }
          case 58: {
            ModelPath = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///timeline的属性配置
  /// </summary>
  public sealed partial class TimelineCfg : pb::IMessage<TimelineCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TimelineCfg> _parser = new pb::MessageParser<TimelineCfg>(() => new TimelineCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TimelineCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimelineCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimelineCfg(TimelineCfg other) : this() {
      _dirtyBits0 = other._dirtyBits0;
      addTagList_ = other.addTagList_.Clone();
      requireTagList_ = other.requireTagList_.Clone();
      blockTagList_ = other.blockTagList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TimelineCfg Clone() {
      return new TimelineCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "add_tag_list" field.</summary>
    public const int AddTagListFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_addTagList_codec
        = pb::FieldCodec.ForUInt32(10);
    private readonly pbc::RepeatedField<uint> addTagList_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> AddTagList {
      get { return addTagList_; }
    }

    /// <summary>Field number for the "require_tag_list" field.</summary>
    public const int RequireTagListFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_requireTagList_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> requireTagList_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> RequireTagList {
      get { return requireTagList_; }
    }

    /// <summary>Field number for the "block_tag_list" field.</summary>
    public const int BlockTagListFieldNumber = 3;
    private static readonly pb::FieldCodec<uint> _repeated_blockTagList_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> blockTagList_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> BlockTagList {
      get { return blockTagList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TimelineCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TimelineCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!addTagList_.Equals(other.addTagList_)) return false;
      if(!requireTagList_.Equals(other.requireTagList_)) return false;
      if(!blockTagList_.Equals(other.blockTagList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= addTagList_.GetHashCode();
      hash ^= requireTagList_.GetHashCode();
      hash ^= blockTagList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      addTagList_.WriteTo(output, _repeated_addTagList_codec);
      requireTagList_.WriteTo(output, _repeated_requireTagList_codec);
      blockTagList_.WriteTo(output, _repeated_blockTagList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      addTagList_.WriteTo(ref output, _repeated_addTagList_codec);
      requireTagList_.WriteTo(ref output, _repeated_requireTagList_codec);
      blockTagList_.WriteTo(ref output, _repeated_blockTagList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      size += addTagList_.CalculateSize(_repeated_addTagList_codec);
      size += requireTagList_.CalculateSize(_repeated_requireTagList_codec);
      size += blockTagList_.CalculateSize(_repeated_blockTagList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TimelineCfg other) {
      if (other == null) {
        return;
      }
      addTagList_.Add(other.addTagList_);
      requireTagList_.Add(other.requireTagList_);
      blockTagList_.Add(other.blockTagList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            addTagList_.AddEntriesFrom(input, _repeated_addTagList_codec);
            break;
          }
          case 18:
          case 16: {
            requireTagList_.AddEntriesFrom(input, _repeated_requireTagList_codec);
            break;
          }
          case 26:
          case 24: {
            blockTagList_.AddEntriesFrom(input, _repeated_blockTagList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            addTagList_.AddEntriesFrom(ref input, _repeated_addTagList_codec);
            break;
          }
          case 18:
          case 16: {
            requireTagList_.AddEntriesFrom(ref input, _repeated_requireTagList_codec);
            break;
          }
          case 26:
          case 24: {
            blockTagList_.AddEntriesFrom(ref input, _repeated_blockTagList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///timeline的属性配置
  /// </summary>
  public sealed partial class PlayerTimelineCfg : pb::IMessage<PlayerTimelineCfg>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PlayerTimelineCfg> _parser = new pb::MessageParser<PlayerTimelineCfg>(() => new PlayerTimelineCfg());
    private pb::UnknownFieldSet _unknownFields;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PlayerTimelineCfg> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerTimelineCfg() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerTimelineCfg(PlayerTimelineCfg other) : this() {
      _dirtyBits0 = other._dirtyBits0;
      timelineCfgDic_ = other.timelineCfgDic_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PlayerTimelineCfg Clone() {
      return new PlayerTimelineCfg(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "timeline_cfg_dic" field.</summary>
    public const int TimelineCfgDicFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Protocol.TimelineCfg>.Codec _map_timelineCfgDic_codec
        = new pbc::MapField<string, global::Protocol.TimelineCfg>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Protocol.TimelineCfg.Parser), 10);
    private readonly pbc::MapField<string, global::Protocol.TimelineCfg> timelineCfgDic_ = new pbc::MapField<string, global::Protocol.TimelineCfg>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Protocol.TimelineCfg> TimelineCfgDic {
      get { return timelineCfgDic_; }
    }
    /// <summary>Gets whether the "timeline_cfg_dic" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTimelineCfgDicDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PlayerTimelineCfg);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PlayerTimelineCfg other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!TimelineCfgDic.Equals(other.TimelineCfgDic)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= TimelineCfgDic.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (output.writeScope == pb.WriteScope.FULL||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimelineCfgDicDirty)) {
        timelineCfgDic_.WriteTo(output, _map_timelineCfgDic_codec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (output.writeScope == pb.WriteScope.FULL||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTimelineCfgDicDirty)) {
        timelineCfgDic_.WriteTo(ref output, _map_timelineCfgDic_codec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (TimelineCfgDic != null) {
        int msgSize = timelineCfgDic_.CalculateSize(_map_timelineCfgDic_codec, scope);
        if (msgSize>0) {
          size += msgSize;
          _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PlayerTimelineCfg other) {
      if (other == null) {
        return;
      }
      foreach (var key in other.timelineCfgDic_.DeleteList) {
        timelineCfgDic_.Remove(key);
      }
      foreach (var pair in other.timelineCfgDic_) {
        global::Protocol.TimelineCfg value;
        if(timelineCfgDic_.TryGetValue(pair.Key, out value)) {
          value.MergeFrom(pair.Value);
        }else{
          timelineCfgDic_.Add(pair.Key, pair.Value);
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            timelineCfgDic_.AddEntriesFrom(input, _map_timelineCfgDic_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            timelineCfgDic_.AddEntriesFrom(ref input, _map_timelineCfgDic_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///-----战斗玩法数据（需要同步断线帮助断线重连）
  /// </summary>
  public sealed partial class BattleCfgData : pb::IMessage<BattleCfgData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BattleCfgData> _parser = new pb::MessageParser<BattleCfgData>(() => new BattleCfgData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BattleCfgData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BattleCfgData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BattleCfgData(BattleCfgData other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      battleType_ = other.battleType_;
      teamCount_ = other.teamCount_;
      teamMemberCount_ = other.teamMemberCount_;
      hideUi_ = other.hideUi_;
      addTags_ = other.addTags_.Clone();
      twoVsTwo_ = other.HasTwoVsTwo ? other.twoVsTwo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BattleCfgData Clone() {
      return new BattleCfgData(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "battle_type" field.</summary>
    public const int BattleTypeFieldNumber = 1;
    private uint battleType_;
    /// <summary>
    ///通用数据
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BattleType {
      get { if ((_hasBits0 & 1) != 0) { return battleType_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        battleType_ = value;
      }
    }
    /// <summary>Gets whether the "battle_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBattleType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "battle_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBattleTypeDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "battle_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBattleType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "team_count" field.</summary>
    public const int TeamCountFieldNumber = 2;
    private uint teamCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TeamCount {
      get { if ((_hasBits0 & 2) != 0) { return teamCount_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        teamCount_ = value;
      }
    }
    /// <summary>Gets whether the "team_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTeamCount {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "team_count" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTeamCountDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "team_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTeamCount() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "team_member_count" field.</summary>
    public const int TeamMemberCountFieldNumber = 3;
    private uint teamMemberCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TeamMemberCount {
      get { if ((_hasBits0 & 4) != 0) { return teamMemberCount_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        teamMemberCount_ = value;
      }
    }
    /// <summary>Gets whether the "team_member_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTeamMemberCount {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "team_member_count" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTeamMemberCountDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "team_member_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTeamMemberCount() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "hide_ui" field.</summary>
    public const int HideUiFieldNumber = 4;
    private bool hideUi_;
    /// <summary>
    ///隐藏UI
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HideUi {
      get { if ((_hasBits0 & 8) != 0) { return hideUi_; } else { return false; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        hideUi_ = value;
      }
    }
    /// <summary>Gets whether the "hide_ui" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHideUi {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "hide_ui" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHideUiDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "hide_ui" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHideUi() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "add_tags" field.</summary>
    public const int AddTagsFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_addTags_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> addTags_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///开局添加Tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> AddTags {
      get { return addTags_; }
    }

    /// <summary>Field number for the "two_vs_two" field.</summary>
    public const int TwoVsTwoFieldNumber = 10;
    private global::Protocol.TwoVsTwoData twoVsTwo_;
    /// <summary>
    ///玩法数据
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.TwoVsTwoData TwoVsTwo {
      get { return twoVsTwo_; }
      set {
        twoVsTwo_ = value;
      }
    }
    /// <summary>Gets whether the two_vs_two field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTwoVsTwo {
      get { return twoVsTwo_ != null; }
    }
    /// <summary>Clears the value of the two_vs_two field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTwoVsTwo() {
      twoVsTwo_ = null;
    }
    /// <summary>Gets whether the "two_vs_two" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTwoVsTwoDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BattleCfgData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BattleCfgData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BattleType != other.BattleType) return false;
      if (TeamCount != other.TeamCount) return false;
      if (TeamMemberCount != other.TeamMemberCount) return false;
      if (HideUi != other.HideUi) return false;
      if(!addTags_.Equals(other.addTags_)) return false;
      if (!object.Equals(TwoVsTwo, other.TwoVsTwo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBattleType) hash ^= BattleType.GetHashCode();
      if (HasTeamCount) hash ^= TeamCount.GetHashCode();
      if (HasTeamMemberCount) hash ^= TeamMemberCount.GetHashCode();
      if (HasHideUi) hash ^= HideUi.GetHashCode();
      hash ^= addTags_.GetHashCode();
      if (HasTwoVsTwo) hash ^= TwoVsTwo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasBattleType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBattleTypeDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(BattleType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTeamCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTeamCountDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(TeamCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTeamMemberCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTeamMemberCountDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(TeamMemberCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHideUi)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHideUiDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(HideUi);
      }
      addTags_.WriteTo(output, _repeated_addTags_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasTwoVsTwo)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTwoVsTwoDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(TwoVsTwo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasBattleType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsBattleTypeDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(BattleType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTeamCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTeamCountDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(TeamCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTeamMemberCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTeamMemberCountDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(TeamMemberCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasHideUi)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHideUiDirty)) {
        output.WriteRawTag(32);
        output.WriteBool(HideUi);
      }
      addTags_.WriteTo(ref output, _repeated_addTags_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasTwoVsTwo)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTwoVsTwoDirty)) {
        output.WriteRawTag(82);
        output.WriteMessage(TwoVsTwo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasBattleType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsBattleTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BattleType);
      }
      if ((scope == pb.WriteScope.FULL && HasTeamCount)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTeamCountDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TeamCount);
      }
      if ((scope == pb.WriteScope.FULL && HasTeamMemberCount)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTeamMemberCountDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TeamMemberCount);
      }
      if ((scope == pb.WriteScope.FULL && HasHideUi)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHideUiDirty)) {
        size += 1 + 1;
      }
      size += addTags_.CalculateSize(_repeated_addTags_codec);
      if (HasTwoVsTwo) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(TwoVsTwo, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 32;
        } else {
          _dirtyBits0 &= ~32;
        }
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BattleCfgData other) {
      if (other == null) {
        return;
      }
      if (other.HasBattleType) {
        BattleType = other.BattleType;
      }
      if (other.HasTeamCount) {
        TeamCount = other.TeamCount;
      }
      if (other.HasTeamMemberCount) {
        TeamMemberCount = other.TeamMemberCount;
      }
      if (other.HasHideUi) {
        HideUi = other.HideUi;
      }
      addTags_.Add(other.addTags_);
      if (other.HasTwoVsTwo) {
        if (!HasTwoVsTwo) {
          TwoVsTwo = new global::Protocol.TwoVsTwoData();
        }
        TwoVsTwo.MergeFrom(other.TwoVsTwo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            BattleType = input.ReadUInt32();
            break;
          }
          case 16: {
            TeamCount = input.ReadUInt32();
            break;
          }
          case 24: {
            TeamMemberCount = input.ReadUInt32();
            break;
          }
          case 32: {
            HideUi = input.ReadBool();
            break;
          }
          case 42:
          case 40: {
            addTags_.AddEntriesFrom(input, _repeated_addTags_codec);
            break;
          }
          case 82: {
            if (!HasTwoVsTwo) {
              TwoVsTwo = new global::Protocol.TwoVsTwoData();
            }
            input.ReadMessage(TwoVsTwo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            BattleType = input.ReadUInt32();
            break;
          }
          case 16: {
            TeamCount = input.ReadUInt32();
            break;
          }
          case 24: {
            TeamMemberCount = input.ReadUInt32();
            break;
          }
          case 32: {
            HideUi = input.ReadBool();
            break;
          }
          case 42:
          case 40: {
            addTags_.AddEntriesFrom(ref input, _repeated_addTags_codec);
            break;
          }
          case 82: {
            if (!HasTwoVsTwo) {
              TwoVsTwo = new global::Protocol.TwoVsTwoData();
            }
            input.ReadMessage(TwoVsTwo);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class WinPointData : pb::IMessage<WinPointData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WinPointData> _parser = new pb::MessageParser<WinPointData>(() => new WinPointData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WinPointData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WinPointData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WinPointData(WinPointData other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      pointId_ = other.pointId_;
      triggerType_ = other.triggerType_;
      linkId_ = other.linkId_;
      pickingTime_ = other.pickingTime_;
      winScore_ = other.winScore_;
      position_ = other.HasPosition ? other.position_.Clone() : null;
      rotation_ = other.HasRotation ? other.rotation_.Clone() : null;
      delayTime_ = other.delayTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WinPointData Clone() {
      return new WinPointData(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "point_id" field.</summary>
    public const int PointIdFieldNumber = 1;
    private int pointId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PointId {
      get { if ((_hasBits0 & 1) != 0) { return pointId_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        pointId_ = value;
      }
    }
    /// <summary>Gets whether the "point_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPointId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "point_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPointIdDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "point_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPointId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "trigger_type" field.</summary>
    public const int TriggerTypeFieldNumber = 2;
    private int triggerType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int TriggerType {
      get { if ((_hasBits0 & 2) != 0) { return triggerType_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        triggerType_ = value;
      }
    }
    /// <summary>Gets whether the "trigger_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTriggerType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "trigger_type" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTriggerTypeDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "trigger_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTriggerType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "linkId" field.</summary>
    public const int LinkIdFieldNumber = 3;
    private int linkId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int LinkId {
      get { if ((_hasBits0 & 4) != 0) { return linkId_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        linkId_ = value;
      }
    }
    /// <summary>Gets whether the "linkId" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLinkId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "linkId" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLinkIdDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "linkId" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLinkId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "picking_time" field.</summary>
    public const int PickingTimeFieldNumber = 4;
    private float pickingTime_;
    /// <summary>
    ///采集时间
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PickingTime {
      get { if ((_hasBits0 & 8) != 0) { return pickingTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        pickingTime_ = value;
      }
    }
    /// <summary>Gets whether the "picking_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPickingTime {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "picking_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPickingTimeDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "picking_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPickingTime() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "win_score" field.</summary>
    public const int WinScoreFieldNumber = 5;
    private int winScore_;
    /// <summary>
    ///分数
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int WinScore {
      get { if ((_hasBits0 & 16) != 0) { return winScore_; } else { return 0; } }
      set {
        _hasBits0 |= 16;
        _dirtyBits0 |= 16;
        winScore_ = value;
      }
    }
    /// <summary>Gets whether the "win_score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWinScore {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Gets whether the "win_score" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWinScoreDirty {
      get { return (_dirtyBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "win_score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWinScore() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 6;
    private global::Protocol.Float3 position_;
    /// <summary>
    ///位置
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }
    /// <summary>Gets whether the position field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPosition {
      get { return position_ != null; }
    }
    /// <summary>Clears the value of the position field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPosition() {
      position_ = null;
    }
    /// <summary>Gets whether the "position" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPositionDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }

    /// <summary>Field number for the "rotation" field.</summary>
    public const int RotationFieldNumber = 7;
    private global::Protocol.Float3 rotation_;
    /// <summary>
    ///旋转
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set {
        rotation_ = value;
      }
    }
    /// <summary>Gets whether the rotation field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRotation {
      get { return rotation_ != null; }
    }
    /// <summary>Clears the value of the rotation field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRotation() {
      rotation_ = null;
    }
    /// <summary>Gets whether the "rotation" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRotationDirty {
      get { return (_dirtyBits0 & 64) != 0; }
    }

    /// <summary>Field number for the "delay_time" field.</summary>
    public const int DelayTimeFieldNumber = 8;
    private float delayTime_;
    /// <summary>
    ///延迟时间
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DelayTime {
      get { if ((_hasBits0 & 32) != 0) { return delayTime_; } else { return 0F; } }
      set {
        _hasBits0 |= 32;
        _dirtyBits0 |= 128;
        delayTime_ = value;
      }
    }
    /// <summary>Gets whether the "delay_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDelayTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Gets whether the "delay_time" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDelayTimeDirty {
      get { return (_dirtyBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "delay_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDelayTime() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WinPointData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WinPointData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PointId != other.PointId) return false;
      if (TriggerType != other.TriggerType) return false;
      if (LinkId != other.LinkId) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PickingTime, other.PickingTime)) return false;
      if (WinScore != other.WinScore) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Rotation, other.Rotation)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DelayTime, other.DelayTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPointId) hash ^= PointId.GetHashCode();
      if (HasTriggerType) hash ^= TriggerType.GetHashCode();
      if (HasLinkId) hash ^= LinkId.GetHashCode();
      if (HasPickingTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PickingTime);
      if (HasWinScore) hash ^= WinScore.GetHashCode();
      if (HasPosition) hash ^= Position.GetHashCode();
      if (HasRotation) hash ^= Rotation.GetHashCode();
      if (HasDelayTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DelayTime);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasPointId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPointIdDirty)) {
        output.WriteRawTag(8);
        output.WriteInt32(PointId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTriggerType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTriggerTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteInt32(TriggerType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLinkId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLinkIdDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(LinkId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPickingTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPickingTimeDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(PickingTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWinScore)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        output.WriteRawTag(40);
        output.WriteInt32(WinScore);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPositionDirty)) {
        output.WriteRawTag(50);
        output.WriteMessage(Position);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(58);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDelayTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDelayTimeDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(DelayTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasPointId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPointIdDirty)) {
        output.WriteRawTag(8);
        output.WriteInt32(PointId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTriggerType)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTriggerTypeDirty)) {
        output.WriteRawTag(16);
        output.WriteInt32(TriggerType);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasLinkId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLinkIdDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(LinkId);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPickingTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPickingTimeDirty)) {
        output.WriteRawTag(37);
        output.WriteFloat(PickingTime);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWinScore)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        output.WriteRawTag(40);
        output.WriteInt32(WinScore);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasPosition)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsPositionDirty)) {
        output.WriteRawTag(50);
        output.WriteMessage(Position);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasRotation)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRotationDirty)) {
        output.WriteRawTag(58);
        output.WriteMessage(Rotation);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDelayTime)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDelayTimeDirty)) {
        output.WriteRawTag(69);
        output.WriteFloat(DelayTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasPointId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPointIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PointId);
      }
      if ((scope == pb.WriteScope.FULL && HasTriggerType)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTriggerTypeDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TriggerType);
      }
      if ((scope == pb.WriteScope.FULL && HasLinkId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLinkIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(LinkId);
      }
      if ((scope == pb.WriteScope.FULL && HasPickingTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsPickingTimeDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasWinScore)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(WinScore);
      }
      if (HasPosition) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Position, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 32;
        } else {
          _dirtyBits0 &= ~32;
        }
      }
      if (HasRotation) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(Rotation, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 64;
        } else {
          _dirtyBits0 &= ~64;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasDelayTime)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsDelayTimeDirty)) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WinPointData other) {
      if (other == null) {
        return;
      }
      if (other.HasPointId) {
        PointId = other.PointId;
      }
      if (other.HasTriggerType) {
        TriggerType = other.TriggerType;
      }
      if (other.HasLinkId) {
        LinkId = other.LinkId;
      }
      if (other.HasPickingTime) {
        PickingTime = other.PickingTime;
      }
      if (other.HasWinScore) {
        WinScore = other.WinScore;
      }
      if (other.HasPosition) {
        if (!HasPosition) {
          Position = new global::Protocol.Float3();
        }
        Position.MergeFrom(other.Position);
      }
      if (other.HasRotation) {
        if (!HasRotation) {
          Rotation = new global::Protocol.Float3();
        }
        Rotation.MergeFrom(other.Rotation);
      }
      if (other.HasDelayTime) {
        DelayTime = other.DelayTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            PointId = input.ReadInt32();
            break;
          }
          case 16: {
            TriggerType = input.ReadInt32();
            break;
          }
          case 24: {
            LinkId = input.ReadInt32();
            break;
          }
          case 37: {
            PickingTime = input.ReadFloat();
            break;
          }
          case 40: {
            WinScore = input.ReadInt32();
            break;
          }
          case 50: {
            if (!HasPosition) {
              Position = new global::Protocol.Float3();
            }
            input.ReadMessage(Position);
            break;
          }
          case 58: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 69: {
            DelayTime = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            PointId = input.ReadInt32();
            break;
          }
          case 16: {
            TriggerType = input.ReadInt32();
            break;
          }
          case 24: {
            LinkId = input.ReadInt32();
            break;
          }
          case 37: {
            PickingTime = input.ReadFloat();
            break;
          }
          case 40: {
            WinScore = input.ReadInt32();
            break;
          }
          case 50: {
            if (!HasPosition) {
              Position = new global::Protocol.Float3();
            }
            input.ReadMessage(Position);
            break;
          }
          case 58: {
            if (!HasRotation) {
              Rotation = new global::Protocol.Float3();
            }
            input.ReadMessage(Rotation);
            break;
          }
          case 69: {
            DelayTime = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TwoVsTwoData : pb::IMessage<TwoVsTwoData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TwoVsTwoData> _parser = new pb::MessageParser<TwoVsTwoData>(() => new TwoVsTwoData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TwoVsTwoData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TwoVsTwoData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TwoVsTwoData(TwoVsTwoData other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      roundCount_ = other.roundCount_;
      totalSeconds_ = other.totalSeconds_;
      winScore_ = other.winScore_;
      modelId_ = other.modelId_;
      winPointList_ = other.winPointList_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TwoVsTwoData Clone() {
      return new TwoVsTwoData(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "round_count" field.</summary>
    public const int RoundCountFieldNumber = 1;
    private uint roundCount_;
    /// <summary>
    ///总轮次
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RoundCount {
      get { if ((_hasBits0 & 1) != 0) { return roundCount_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        roundCount_ = value;
      }
    }
    /// <summary>Gets whether the "round_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRoundCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "round_count" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsRoundCountDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "round_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRoundCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "total_seconds" field.</summary>
    public const int TotalSecondsFieldNumber = 2;
    private uint totalSeconds_;
    /// <summary>
    ///单轮总时长
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TotalSeconds {
      get { if ((_hasBits0 & 2) != 0) { return totalSeconds_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        totalSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "total_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTotalSeconds {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "total_seconds" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTotalSecondsDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "total_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTotalSeconds() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "win_score" field.</summary>
    public const int WinScoreFieldNumber = 3;
    private uint winScore_;
    /// <summary>
    ///单轮取胜的分数
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint WinScore {
      get { if ((_hasBits0 & 4) != 0) { return winScore_; } else { return 0; } }
      set {
        _hasBits0 |= 4;
        _dirtyBits0 |= 4;
        winScore_ = value;
      }
    }
    /// <summary>Gets whether the "win_score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWinScore {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Gets whether the "win_score" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsWinScoreDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "win_score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWinScore() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "model_id" field.</summary>
    public const int ModelIdFieldNumber = 4;
    private uint modelId_;
    /// <summary>
    ///模型ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ModelId {
      get { if ((_hasBits0 & 8) != 0) { return modelId_; } else { return 0; } }
      set {
        _hasBits0 |= 8;
        _dirtyBits0 |= 8;
        modelId_ = value;
      }
    }
    /// <summary>Gets whether the "model_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModelId {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Gets whether the "model_id" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsModelIdDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "model_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModelId() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "win_point_list" field.</summary>
    public const int WinPointListFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Protocol.WinPointData> _repeated_winPointList_codec
        = pb::FieldCodec.ForMessage(42, global::Protocol.WinPointData.Parser);
    private readonly pbc::RepeatedField<global::Protocol.WinPointData> winPointList_ = new pbc::RepeatedField<global::Protocol.WinPointData>();
    /// <summary>
    ///得分点列表
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.WinPointData> WinPointList {
      get { return winPointList_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TwoVsTwoData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TwoVsTwoData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RoundCount != other.RoundCount) return false;
      if (TotalSeconds != other.TotalSeconds) return false;
      if (WinScore != other.WinScore) return false;
      if (ModelId != other.ModelId) return false;
      if(!winPointList_.Equals(other.winPointList_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRoundCount) hash ^= RoundCount.GetHashCode();
      if (HasTotalSeconds) hash ^= TotalSeconds.GetHashCode();
      if (HasWinScore) hash ^= WinScore.GetHashCode();
      if (HasModelId) hash ^= ModelId.GetHashCode();
      hash ^= winPointList_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasRoundCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRoundCountDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(RoundCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTotalSeconds)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTotalSecondsDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(TotalSeconds);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWinScore)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(WinScore);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(ModelId);
      }
      winPointList_.WriteTo(output, _repeated_winPointList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasRoundCount)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsRoundCountDirty)) {
        output.WriteRawTag(8);
        output.WriteUInt32(RoundCount);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasTotalSeconds)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsTotalSecondsDirty)) {
        output.WriteRawTag(16);
        output.WriteUInt32(TotalSeconds);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasWinScore)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        output.WriteRawTag(24);
        output.WriteUInt32(WinScore);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasModelId)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        output.WriteRawTag(32);
        output.WriteUInt32(ModelId);
      }
      winPointList_.WriteTo(ref output, _repeated_winPointList_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasRoundCount)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsRoundCountDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoundCount);
      }
      if ((scope == pb.WriteScope.FULL && HasTotalSeconds)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsTotalSecondsDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TotalSeconds);
      }
      if ((scope == pb.WriteScope.FULL && HasWinScore)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsWinScoreDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(WinScore);
      }
      if ((scope == pb.WriteScope.FULL && HasModelId)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsModelIdDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ModelId);
      }
      size += winPointList_.CalculateSize(_repeated_winPointList_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TwoVsTwoData other) {
      if (other == null) {
        return;
      }
      if (other.HasRoundCount) {
        RoundCount = other.RoundCount;
      }
      if (other.HasTotalSeconds) {
        TotalSeconds = other.TotalSeconds;
      }
      if (other.HasWinScore) {
        WinScore = other.WinScore;
      }
      if (other.HasModelId) {
        ModelId = other.ModelId;
      }
      winPointList_.Add(other.winPointList_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RoundCount = input.ReadUInt32();
            break;
          }
          case 16: {
            TotalSeconds = input.ReadUInt32();
            break;
          }
          case 24: {
            WinScore = input.ReadUInt32();
            break;
          }
          case 32: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 42: {
            winPointList_.AddEntriesFrom(input, _repeated_winPointList_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RoundCount = input.ReadUInt32();
            break;
          }
          case 16: {
            TotalSeconds = input.ReadUInt32();
            break;
          }
          case 24: {
            WinScore = input.ReadUInt32();
            break;
          }
          case 32: {
            ModelId = input.ReadUInt32();
            break;
          }
          case 42: {
            winPointList_.AddEntriesFrom(ref input, _repeated_winPointList_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///-----AI数据-----
  /// </summary>
  public sealed partial class AIMapData : pb::IMessage<AIMapData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AIMapData> _parser = new pb::MessageParser<AIMapData>(() => new AIMapData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AIMapData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapData(AIMapData other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      upSide_ = other.HasUpSide ? other.upSide_.Clone() : null;
      downSide_ = other.HasDownSide ? other.downSide_.Clone() : null;
      countX_ = other.countX_;
      countY_ = other.countY_;
      pointList_ = other.pointList_.Clone();
      levelConfigName_ = other.levelConfigName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapData Clone() {
      return new AIMapData(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "up_side" field.</summary>
    public const int UpSideFieldNumber = 1;
    private global::Protocol.Float3 upSide_;
    /// <summary>
    ///上边界
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 UpSide {
      get { return upSide_; }
      set {
        upSide_ = value;
      }
    }
    /// <summary>Gets whether the up_side field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUpSide {
      get { return upSide_ != null; }
    }
    /// <summary>Clears the value of the up_side field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUpSide() {
      upSide_ = null;
    }
    /// <summary>Gets whether the "up_side" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsUpSideDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }

    /// <summary>Field number for the "down_side" field.</summary>
    public const int DownSideFieldNumber = 2;
    private global::Protocol.Float3 downSide_;
    /// <summary>
    ///下边界
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Protocol.Float3 DownSide {
      get { return downSide_; }
      set {
        downSide_ = value;
      }
    }
    /// <summary>Gets whether the down_side field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDownSide {
      get { return downSide_ != null; }
    }
    /// <summary>Clears the value of the down_side field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDownSide() {
      downSide_ = null;
    }
    /// <summary>Gets whether the "down_side" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDownSideDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }

    /// <summary>Field number for the "count_x" field.</summary>
    public const int CountXFieldNumber = 3;
    private int countX_;
    /// <summary>
    ///横向格子数量
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CountX {
      get { if ((_hasBits0 & 1) != 0) { return countX_; } else { return 0; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 4;
        countX_ = value;
      }
    }
    /// <summary>Gets whether the "count_x" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCountX {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "count_x" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCountXDirty {
      get { return (_dirtyBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "count_x" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCountX() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "count_y" field.</summary>
    public const int CountYFieldNumber = 4;
    private int countY_;
    /// <summary>
    ///纵向格子数量
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CountY {
      get { if ((_hasBits0 & 2) != 0) { return countY_; } else { return 0; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 8;
        countY_ = value;
      }
    }
    /// <summary>Gets whether the "count_y" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCountY {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "count_y" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsCountYDirty {
      get { return (_dirtyBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "count_y" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCountY() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "point_list" field.</summary>
    public const int PointListFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Protocol.AIMapPointData> _repeated_pointList_codec
        = pb::FieldCodec.ForMessage(42, global::Protocol.AIMapPointData.Parser);
    private readonly pbc::RepeatedField<global::Protocol.AIMapPointData> pointList_ = new pbc::RepeatedField<global::Protocol.AIMapPointData>();
    /// <summary>
    ///每个格子的信息，长度为count_x * count_y
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Protocol.AIMapPointData> PointList {
      get { return pointList_; }
    }

    /// <summary>Field number for the "level_config_name" field.</summary>
    public const int LevelConfigNameFieldNumber = 6;
    private string levelConfigName_;
    /// <summary>
    ///配置名字
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LevelConfigName {
      get { return levelConfigName_ ?? ""; }
      set {
        levelConfigName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "level_config_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLevelConfigName {
      get { return levelConfigName_ != null; }
    }
    /// <summary>Gets whether the "level_config_name" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsLevelConfigNameDirty {
      get { return (_dirtyBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "level_config_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLevelConfigName() {
      levelConfigName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AIMapData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AIMapData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(UpSide, other.UpSide)) return false;
      if (!object.Equals(DownSide, other.DownSide)) return false;
      if (CountX != other.CountX) return false;
      if (CountY != other.CountY) return false;
      if(!pointList_.Equals(other.pointList_)) return false;
      if (LevelConfigName != other.LevelConfigName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUpSide) hash ^= UpSide.GetHashCode();
      if (HasDownSide) hash ^= DownSide.GetHashCode();
      if (HasCountX) hash ^= CountX.GetHashCode();
      if (HasCountY) hash ^= CountY.GetHashCode();
      hash ^= pointList_.GetHashCode();
      if (HasLevelConfigName) hash ^= LevelConfigName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasUpSide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUpSideDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(UpSide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDownSide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDownSideDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(DownSide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCountX)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCountXDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(CountX);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCountY)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCountYDirty)) {
        output.WriteRawTag(32);
        output.WriteInt32(CountY);
      }
      pointList_.WriteTo(output, _repeated_pointList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasLevelConfigName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLevelConfigNameDirty)) {
        output.WriteRawTag(50);
        output.WriteString(LevelConfigName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasUpSide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsUpSideDirty)) {
        output.WriteRawTag(10);
        output.WriteMessage(UpSide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasDownSide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsDownSideDirty)) {
        output.WriteRawTag(18);
        output.WriteMessage(DownSide);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCountX)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCountXDirty)) {
        output.WriteRawTag(24);
        output.WriteInt32(CountX);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasCountY)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsCountYDirty)) {
        output.WriteRawTag(32);
        output.WriteInt32(CountY);
      }
      pointList_.WriteTo(ref output, _repeated_pointList_codec);
      if ((output.writeScope == pb.WriteScope.FULL && HasLevelConfigName)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsLevelConfigNameDirty)) {
        output.WriteRawTag(50);
        output.WriteString(LevelConfigName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if (HasUpSide) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(UpSide, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 1;
        } else {
          _dirtyBits0 &= ~1;
        }
      }
      if (HasDownSide) {
        int msgSize = pb::CodedOutputStream.ComputeMessageSize(DownSide, scope);
        if (msgSize>0 || scope== pb.WriteScope.FULL) {
          size += 1 + msgSize;
          if (scope!= pb.WriteScope.FULL) _dirtyBits0 |= 2;
        } else {
          _dirtyBits0 &= ~2;
        }
      }
      if ((scope == pb.WriteScope.FULL && HasCountX)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCountXDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CountX);
      }
      if ((scope == pb.WriteScope.FULL && HasCountY)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsCountYDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CountY);
      }
      size += pointList_.CalculateSize(_repeated_pointList_codec);
      if ((scope == pb.WriteScope.FULL && HasLevelConfigName)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsLevelConfigNameDirty)) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LevelConfigName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AIMapData other) {
      if (other == null) {
        return;
      }
      if (other.HasUpSide) {
        if (!HasUpSide) {
          UpSide = new global::Protocol.Float3();
        }
        UpSide.MergeFrom(other.UpSide);
      }
      if (other.HasDownSide) {
        if (!HasDownSide) {
          DownSide = new global::Protocol.Float3();
        }
        DownSide.MergeFrom(other.DownSide);
      }
      if (other.HasCountX) {
        CountX = other.CountX;
      }
      if (other.HasCountY) {
        CountY = other.CountY;
      }
      pointList_.Add(other.pointList_);
      if (other.HasLevelConfigName) {
        LevelConfigName = other.LevelConfigName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (!HasUpSide) {
              UpSide = new global::Protocol.Float3();
            }
            input.ReadMessage(UpSide);
            break;
          }
          case 18: {
            if (!HasDownSide) {
              DownSide = new global::Protocol.Float3();
            }
            input.ReadMessage(DownSide);
            break;
          }
          case 24: {
            CountX = input.ReadInt32();
            break;
          }
          case 32: {
            CountY = input.ReadInt32();
            break;
          }
          case 42: {
            pointList_.AddEntriesFrom(input, _repeated_pointList_codec);
            break;
          }
          case 50: {
            LevelConfigName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (!HasUpSide) {
              UpSide = new global::Protocol.Float3();
            }
            input.ReadMessage(UpSide);
            break;
          }
          case 18: {
            if (!HasDownSide) {
              DownSide = new global::Protocol.Float3();
            }
            input.ReadMessage(DownSide);
            break;
          }
          case 24: {
            CountX = input.ReadInt32();
            break;
          }
          case 32: {
            CountY = input.ReadInt32();
            break;
          }
          case 42: {
            pointList_.AddEntriesFrom(ref input, _repeated_pointList_codec);
            break;
          }
          case 50: {
            LevelConfigName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AIMapPointData : pb::IMessage<AIMapPointData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AIMapPointData> _parser = new pb::MessageParser<AIMapPointData>(() => new AIMapPointData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _dirtyBits0 = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AIMapPointData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditorReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapPointData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapPointData(AIMapPointData other) : this() {
      _hasBits0 = other._hasBits0;
      _dirtyBits0 = other._dirtyBits0;
      height_ = other.height_;
      isHide_ = other.isHide_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AIMapPointData Clone() {
      return new AIMapPointData(this);
    }

    public void ClearDirty() {
      _dirtyBits0 = 0;
    }
    public bool IsDirty() {
      if (_dirtyBits0 != 0) return true;
      return false;
    }
    /// <summary>Field number for the "height" field.</summary>
    public const int HeightFieldNumber = 1;
    private float height_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Height {
      get { if ((_hasBits0 & 1) != 0) { return height_; } else { return 0F; } }
      set {
        _hasBits0 |= 1;
        _dirtyBits0 |= 1;
        height_ = value;
      }
    }
    /// <summary>Gets whether the "height" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeight {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Gets whether the "height" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHeightDirty {
      get { return (_dirtyBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "height" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeight() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "is_hide" field.</summary>
    public const int IsHideFieldNumber = 2;
    private bool isHide_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsHide {
      get { if ((_hasBits0 & 2) != 0) { return isHide_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        _dirtyBits0 |= 2;
        isHide_ = value;
      }
    }
    /// <summary>Gets whether the "is_hide" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsHide {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Gets whether the "is_hide" field is dirty</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIsHideDirty {
      get { return (_dirtyBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_hide" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsHide() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AIMapPointData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AIMapPointData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Height, other.Height)) return false;
      if (IsHide != other.IsHide) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHeight) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Height);
      if (HasIsHide) hash ^= IsHide.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if ((output.writeScope == pb.WriteScope.FULL && HasHeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Height);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsHide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        output.WriteRawTag(16);
        output.WriteBool(IsHide);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
      if (output.clear) ClearDirty();
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if ((output.writeScope == pb.WriteScope.FULL && HasHeight)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        output.WriteRawTag(13);
        output.WriteFloat(Height);
      }
      if ((output.writeScope == pb.WriteScope.FULL && HasIsHide)||(output.writeScope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        output.WriteRawTag(16);
        output.WriteBool(IsHide);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
      if (output.clear) ClearDirty();
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize(pb::WriteScope scope) {
      int size = 0;
      if ((scope == pb.WriteScope.FULL && HasHeight)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsHeightDirty)) {
        size += 1 + 4;
      }
      if ((scope == pb.WriteScope.FULL && HasIsHide)||(scope == pb.WriteScope.DIRTY_PUBLIC && IsIsHideDirty)) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize(scope);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AIMapPointData other) {
      if (other == null) {
        return;
      }
      if (other.HasHeight) {
        Height = other.Height;
      }
      if (other.HasIsHide) {
        IsHide = other.IsHide;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Height = input.ReadFloat();
            break;
          }
          case 16: {
            IsHide = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 13: {
            Height = input.ReadFloat();
            break;
          }
          case 16: {
            IsHide = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
