// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Protocol {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class ProtoEditor {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Protocol_LevelCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.LevelCfg, global::Protocol.LevelCfg.Builder> internal__static_Protocol_LevelCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_MapCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.MapCfg, global::Protocol.MapCfg.Builder> internal__static_Protocol_MapCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_BattleCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.BattleCfg, global::Protocol.BattleCfg.Builder> internal__static_Protocol_BattleCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_BornCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.BornCfg, global::Protocol.BornCfg.Builder> internal__static_Protocol_BornCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_HeroBornCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.HeroBornCfg, global::Protocol.HeroBornCfg.Builder> internal__static_Protocol_HeroBornCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_MonsterBornCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.MonsterBornCfg, global::Protocol.MonsterBornCfg.Builder> internal__static_Protocol_MonsterBornCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_WayMapCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayMapCfg, global::Protocol.WayMapCfg.Builder> internal__static_Protocol_WayMapCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_WayPointCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayPointCfg, global::Protocol.WayPointCfg.Builder> internal__static_Protocol_WayPointCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_WayLineCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.WayLineCfg, global::Protocol.WayLineCfg.Builder> internal__static_Protocol_WayLineCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_ThingWayMap__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.ThingWayMap, global::Protocol.ThingWayMap.Builder> internal__static_Protocol_ThingWayMap__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_CellCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.CellCfg, global::Protocol.CellCfg.Builder> internal__static_Protocol_CellCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_UnitCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.UnitCfg, global::Protocol.UnitCfg.Builder> internal__static_Protocol_UnitCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_AnimatorCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.AnimatorCfg, global::Protocol.AnimatorCfg.Builder> internal__static_Protocol_AnimatorCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_AnimationClipCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.AnimationClipCfg, global::Protocol.AnimationClipCfg.Builder> internal__static_Protocol_AnimationClipCfg__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_MoveKeyFrame__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveKeyFrame, global::Protocol.MoveKeyFrame.Builder> internal__static_Protocol_MoveKeyFrame__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_MoveMotion__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveMotion, global::Protocol.MoveMotion.Builder> internal__static_Protocol_MoveMotion__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_BlendNode__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.BlendNode, global::Protocol.BlendNode.Builder> internal__static_Protocol_BlendNode__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_Blender__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.Blender, global::Protocol.Blender.Builder> internal__static_Protocol_Blender__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Protocol_MoveControllerCfg__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveControllerCfg, global::Protocol.MoveControllerCfg.Builder> internal__static_Protocol_MoveControllerCfg__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static ProtoEditor() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJwcm90b19lZGl0b3IucHJvdG8SCFByb3RvY29sGhJwcm90b19jb21tb24u", 
            "cHJvdG8aEnByb3RvX2NvbmZpZy5wcm90byI+CghMZXZlbENmZxIyCgpiYXR0", 
            "bGVfY2ZnGAEgASgLMhMuUHJvdG9jb2wuQmF0dGxlQ2ZnUgliYXR0bGVDZmci", 
            "hgIKBk1hcENmZxIVCgZjZWxsX3gYASACKAVSBWNlbGxYEhUKBmNlbGxfeRgC", 
            "IAIoBVIFY2VsbFkSFwoHaXNfd2FycBgDIAIoCFIGaXNXYXJwEjUKDWNlbGxf", 
            "Y2ZnX2xpc3QYBCADKAsyES5Qcm90b2NvbC5DZWxsQ2ZnUgtjZWxsQ2ZnTGlz", 
            "dBIdCgp1aW50X2NvdW50GAUgAigFUgl1aW50Q291bnQSNQoNdW5pdF9jZmdf", 
            "bGlzdBgGIAMoCzIRLlByb3RvY29sLlVuaXRDZmdSC3VuaXRDZmdMaXN0EigK", 
            "EG1hcF9maWxlX3ZlcnNpb24YByACKAVSDm1hcEZpbGVWZXJzaW9uIsMBCglC", 
            "YXR0bGVDZmcSOwoOaGVyb19ib3JuX2xpc3QYASADKAsyFS5Qcm90b2NvbC5I", 
            "ZXJvQm9ybkNmZ1IMaGVyb0Jvcm5MaXN0EkQKEW1vbnN0ZXJfYm9ybl9saXN0", 
            "GAIgAygLMhguUHJvdG9jb2wuTW9uc3RlckJvcm5DZmdSD21vbnN0ZXJCb3Ju", 
            "TGlzdBIzCgt3YXlfbWFwX2NmZxgDIAEoCzITLlByb3RvY29sLldheU1hcENm", 
            "Z1IJd2F5TWFwQ2ZnIqQBCgdCb3JuQ2ZnEisKBmVfdHlwZRgBIAIoDjIULlBy", 
            "b3RvY29sLkVudGl0eVR5cGVSBWVUeXBlEioKB3Bvc3Rpb24YAiACKAsyEC5Q", 
            "cm90b2NvbC5GbG9hdDNSB3Bvc3Rpb24SLAoIcm90YXRpb24YAyACKAsyEC5Q", 
            "cm90b2NvbC5GbG9hdDNSCHJvdGF0aW9uEhIKBGNhbXAYBCABKA1SBGNhbXAi", 
            "UgoLSGVyb0Jvcm5DZmcSFQoGY2ZnX2lkGAEgAigNUgVjZmdJZBIsCghib3Ju", 
            "X2NmZxgCIAIoCzIRLlByb3RvY29sLkJvcm5DZmdSB2Jvcm5DZmciVQoOTW9u", 
            "c3RlckJvcm5DZmcSFQoGY2ZnX2lkGAEgAigNUgVjZmdJZBIsCghib3JuX2Nm", 
            "ZxgCIAIoCzIRLlByb3RvY29sLkJvcm5DZmdSB2Jvcm5DZmciZgoJV2F5TWFw", 
            "Q2ZnEi0KBnBvaW50cxgBIAMoCzIVLlByb3RvY29sLldheVBvaW50Q2ZnUgZw", 
            "b2ludHMSKgoFbGluZXMYAiADKAsyFC5Qcm90b2NvbC5XYXlMaW5lQ2ZnUgVs", 
            "aW5lcyLyAgoLV2F5UG9pbnRDZmcSDgoCaWQYASACKA1SAmlkEhQKBW1hcElk", 
            "GAIgAigNUgVtYXBJZBIsCghwb3NpdGlvbhgDIAIoCzIQLlByb3RvY29sLkZs", 
            "b2F0M1IIcG9zaXRpb24SKgoHZm9yd2FyZBgEIAEoCzIQLlByb3RvY29sLkZs", 
            "b2F0M1IHZm9yd2FyZBIiCgxtaW5TdGFuZFRpbWUYBSABKAJSDG1pblN0YW5k", 
            "VGltZRIiCgxtYXhTdGFuZFRpbWUYBiABKAJSDG1heFN0YW5kVGltZRISCgR0", 
            "eXBlGAcgASgNUgR0eXBlEh0KCmxpbmVfY291bnQYCCABKA1SCWxpbmVDb3Vu", 
            "dBIkCg5wYXNzX2xpbmVfdGltZRgJIAEoAlIMcGFzc0xpbmVUaW1lEh8KC25l", 
            "ZWRfb2Zmc2V0GAogASgIUgpuZWVkT2Zmc2V0EiEKDG9mZnNldF92YWx1ZRgL", 
            "IAEoAlILb2Zmc2V0VmFsdWUilAEKCldheUxpbmVDZmcSKQoEaGVhZBgBIAIo", 
            "CzIVLlByb3RvY29sLldheVBvaW50Q2ZnUgRoZWFkEikKBGxhc3QYAiACKAsy", 
            "FS5Qcm90b2NvbC5XYXlQb2ludENmZ1IEbGFzdBISCgRjb3N0GAMgAigCUgRj", 
            "b3N0EhwKCmlzX29uZV93YXkYBCACKAhSCGlzT25lV2F5IlIKC1RoaW5nV2F5", 
            "TWFwEg4KAmlkGAEgAigNUgJpZBIzCgt3YXlfbWFwX2NmZxgCIAEoCzITLlBy", 
            "b3RvY29sLldheU1hcENmZ1IJd2F5TWFwQ2ZnIsEECgdDZWxsQ2ZnEiEKDHRl", 
            "cnJhaW5fdHlwZRgBIAIoBVILdGVycmFpblR5cGUSHAoJZWxldmF0aW9uGAIg", 
            "AigFUgllbGV2YXRpb24SHwoLd2F0ZXJfbGV2ZWwYAyACKAVSCndhdGVyTGV2", 
            "ZWwSHwoLdXJiYW5fbGV2ZWwYBCACKAVSCnVyYmFuTGV2ZWwSHQoKZmFybV9s", 
            "ZXZlbBgFIAIoBVIJZmFybUxldmVsEh8KC3BsYW50X2xldmVsGAYgAigFUgpw", 
            "bGFudExldmVsEiMKDXNwZWNpYWxfaW5kZXgYByACKAVSDHNwZWNpYWxJbmRl", 
            "eBIXCgdpc193YWxsGAggAigIUgZpc1dhbGwSPAoNaW5jb21pbmdSaXZlchgJ", 
            "IAEoDjIWLlByb3RvY29sLkhleERpcmVjdGlvblINaW5jb21pbmdSaXZlchI8", 
            "Cg1vdXRnb2luZ1JpdmVyGAogASgOMhYuUHJvdG9jb2wuSGV4RGlyZWN0aW9u", 
            "Ug1vdXRnb2luZ1JpdmVyEhwKCXJvYWRGbGFncxgLIAEoBVIJcm9hZEZsYWdz", 
            "Eh4KCklzRXhwbG9yZWQYDCABKAhSCklzRXhwbG9yZWQSFAoFaW5kZXgYDSAC", 
            "KAVSBWluZGV4EiwKCHBvc2l0aW9uGA4gASgLMhAuUHJvdG9jb2wuRmxvYXQz", 
            "Ughwb3NpdGlvbhI3ChhuZWlnaGJvcl9jZWxsX2luZGV4X2xpc3QYDyADKAVS", 
            "FW5laWdoYm9yQ2VsbEluZGV4TGlzdCJBCgdVbml0Q2ZnEgwKAXgYASACKAVS", 
            "AXgSDAoBeRgCIAIoBVIBeRIaCghyb3RhdGlvbhgDIAIoAlIIcm90YXRpb24i", 
            "kQEKC0FuaW1hdG9yQ2ZnEiMKDWFuaW1hdG9yX25hbWUYASABKAlSDGFuaW1h", 
            "dG9yTmFtZRIdCgpjbGlwX2NvdW50GAIgASgNUgljbGlwQ291bnQSPgoNY2xp", 
            "cF9jZmdfbGlzdBgDIAMoCzIaLlByb3RvY29sLkFuaW1hdGlvbkNsaXBDZmdS", 
            "C2NsaXBDZmdMaXN0ImkKEEFuaW1hdGlvbkNsaXBDZmcSGwoJY2xpcF9uYW1l", 
            "GAEgASgJUghjbGlwTmFtZRIfCgtjbGlwX2xlbmd0aBgCIAEoAlIKY2xpcExl", 
            "bmd0aBIXCgdjbGlwX2lkGAMgASgNUgZjbGlwSWQitAEKDE1vdmVLZXlGcmFt", 
            "ZRISCgR0aW1lGAEgASgCUgR0aW1lEhQKBXZhbHVlGAIgASgCUgV2YWx1ZRId", 
            "Cgppbl90YW5nZW50GAMgASgCUglpblRhbmdlbnQSHwoLb3V0X3RhbmdlbnQY", 
            "BCABKAJSCm91dFRhbmdlbnQSGwoJaW5fd2VpZ2h0GAUgASgCUghpbldlaWdo", 
            "dBIdCgpvdXRfd2VpZ2h0GAYgASgCUglvdXRXZWlnaHQiogYKCk1vdmVNb3Rp", 
            "b24SFgoGbGVuZ3RoGAEgASgFUgZsZW5ndGgSQAoQcG9zaXRpb25feF9jdXJ2", 
            "ZRgCIAMoCzIWLlByb3RvY29sLk1vdmVLZXlGcmFtZVIOcG9zaXRpb25YQ3Vy", 
            "dmUSQAoQcG9zaXRpb25fel9jdXJ2ZRgDIAMoCzIWLlByb3RvY29sLk1vdmVL", 
            "ZXlGcmFtZVIOcG9zaXRpb25aQ3VydmUSQAoQcm90YXRpb25feF9jdXJ2ZRgE", 
            "IAMoCzIWLlByb3RvY29sLk1vdmVLZXlGcmFtZVIOcm90YXRpb25YQ3VydmUS", 
            "QAoQcm90YXRpb25feV9jdXJ2ZRgFIAMoCzIWLlByb3RvY29sLk1vdmVLZXlG", 
            "cmFtZVIOcm90YXRpb25ZQ3VydmUSQAoQcm90YXRpb25fel9jdXJ2ZRgGIAMo", 
            "CzIWLlByb3RvY29sLk1vdmVLZXlGcmFtZVIOcm90YXRpb25aQ3VydmUSQAoQ", 
            "cm90YXRpb25fd19jdXJ2ZRgHIAMoCzIWLlByb3RvY29sLk1vdmVLZXlGcmFt", 
            "ZVIOcm90YXRpb25XQ3VydmUSHwoLbW90aW9uX25hbWUYCCABKAlSCm1vdGlv", 
            "bk5hbWUSQAoQcG9zaXRpb25feV9jdXJ2ZRgJIAMoCzIWLlByb3RvY29sLk1v", 
            "dmVLZXlGcmFtZVIOcG9zaXRpb25ZQ3VydmUSFwoHaXNfbG9vcBgRIAEoCFIG", 
            "aXNMb29wEjoKDXNjYWxlX3hfY3VydmUYEiADKAsyFi5Qcm90b2NvbC5Nb3Zl", 
            "S2V5RnJhbWVSC3NjYWxlWEN1cnZlEjoKDXNjYWxlX3lfY3VydmUYEyADKAsy", 
            "Fi5Qcm90b2NvbC5Nb3ZlS2V5RnJhbWVSC3NjYWxlWUN1cnZlEjoKDXNjYWxl", 
            "X3pfY3VydmUYFCADKAsyFi5Qcm90b2NvbC5Nb3ZlS2V5RnJhbWVSC3NjYWxl", 
            "WkN1cnZlEh8KC21vdGlvbl90eXBlGBUgASgNUgptb3Rpb25UeXBlEh8KC2Zy", 
            "YW1lX2NvdW50GBYgASgFUgpmcmFtZUNvdW50IowECglCbGVuZE5vZGUSHQoK", 
            "bW92ZV9zcGVlZBgBIAEoAlIJbW92ZVNwZWVkEh8KC2FuZ2xlX3NwZWVkGAIg", 
            "ASgCUgphbmdsZVNwZWVkEhsKCXhfcG9zdGlvbhgDIAEoAlIIeFBvc3Rpb24S", 
            "GwoJeV9wb3N0aW9uGAQgASgCUgh5UG9zdGlvbhIrCghtb3ZlX2RpchgFIAEo", 
            "CzIQLlByb3RvY29sLkZsb2F0M1IHbW92ZURpchIWCgZsZW5ndGgYBiABKAJS", 
            "Bmxlbmd0aBIdCgppc19hZGR0aW9uGAcgASgIUglpc0FkZHRpb24SLAoGbW90", 
            "aW9uGAggASgLMhQuUHJvdG9jb2wuTW92ZU1vdGlvblIGbW90aW9uEjMKDGJv", 
            "dW5kX2NlbnRlchgJIAEoCzIQLlByb3RvY29sLkZsb2F0M1ILYm91bmRDZW50", 
            "ZXISLwoKYm91bmRfc2l6ZRgKIAEoCzIQLlByb3RvY29sLkZsb2F0M1IJYm91", 
            "bmRTaXplEjUKDWhlYWRfcG9zaXRpb24YCyABKAsyEC5Qcm90b2NvbC5GbG9h", 
            "dDNSDGhlYWRQb3NpdGlvbhI1Cg1oZWFkX3JvdGF0aW9uGAwgASgLMhAuUHJv", 
            "dG9jb2wuRmxvYXQzUgxoZWFkUm90YXRpb24SHwoLZnJhbWVfY291bnQYDSAB", 
            "KAVSCmZyYW1lQ291bnQivQEKB0JsZW5kZXISMgoKYmxlbmRfdHlwZRgBIAEo", 
            "DjITLlByb3RvY29sLkJsZW5kVHlwZVIJYmxlbmRUeXBlEjAKCW5vZGVfbGlz", 
            "dBgCIAMoCzITLlByb3RvY29sLkJsZW5kTm9kZVIIbm9kZUxpc3QSFgoGbGVu", 
            "Z3RoGAMgASgCUgZsZW5ndGgSEgoEbmFtZRgEIAEoCVIEbmFtZRIgCgxpc19m", 
            "aXhfYW5nbGUYBSABKAhSCmlzRml4QW5nbGUijwIKEU1vdmVDb250cm9sbGVy", 
            "Q2ZnEjsKDmV4cG9ydF9tb3Rpb25zGAEgAygLMhQuUHJvdG9jb2wuTW92ZU1v", 
            "dGlvblINZXhwb3J0TW90aW9ucxI6Cg9leHBvcnRfYmxlbmRlcnMYAiADKAsy", 
            "ES5Qcm90b2NvbC5CbGVuZGVyUg5leHBvcnRCbGVuZGVycxIfCgt3ZWFwb25f", 
            "cGF0aBgDIAEoCVIKd2VhcG9uUGF0aBImCg9ib3VuZF9wYXRoX2xpc3QYBCAD", 
            "KAlSDWJvdW5kUGF0aExpc3QSGwoJaGVhZF9wYXRoGAUgASgJUghoZWFkUGF0", 
            "aBIbCgloZWFkX3NpemUYBiABKAJSCGhlYWRTaXplKkwKCUJsZW5kVHlwZRIL", 
            "CgdCVF9Ob25lEAASCgoGU2ltcGxlEAESCQoFUG9sYXIQAhINCglDYXJ0ZXNp", 
          "YW4QAxIMCghTaW1wbGUxRBAE"));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Protocol_LevelCfg__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Protocol_LevelCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.LevelCfg, global::Protocol.LevelCfg.Builder>(internal__static_Protocol_LevelCfg__Descriptor,
                new string[] { "BattleCfg", });
        internal__static_Protocol_MapCfg__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Protocol_MapCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.MapCfg, global::Protocol.MapCfg.Builder>(internal__static_Protocol_MapCfg__Descriptor,
                new string[] { "CellX", "CellY", "IsWarp", "CellCfgList", "UintCount", "UnitCfgList", "MapFileVersion", });
        internal__static_Protocol_BattleCfg__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Protocol_BattleCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.BattleCfg, global::Protocol.BattleCfg.Builder>(internal__static_Protocol_BattleCfg__Descriptor,
                new string[] { "HeroBornList", "MonsterBornList", "WayMapCfg", });
        internal__static_Protocol_BornCfg__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Protocol_BornCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.BornCfg, global::Protocol.BornCfg.Builder>(internal__static_Protocol_BornCfg__Descriptor,
                new string[] { "EType", "Postion", "Rotation", "Camp", });
        internal__static_Protocol_HeroBornCfg__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Protocol_HeroBornCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.HeroBornCfg, global::Protocol.HeroBornCfg.Builder>(internal__static_Protocol_HeroBornCfg__Descriptor,
                new string[] { "CfgId", "BornCfg", });
        internal__static_Protocol_MonsterBornCfg__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Protocol_MonsterBornCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.MonsterBornCfg, global::Protocol.MonsterBornCfg.Builder>(internal__static_Protocol_MonsterBornCfg__Descriptor,
                new string[] { "CfgId", "BornCfg", });
        internal__static_Protocol_WayMapCfg__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Protocol_WayMapCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayMapCfg, global::Protocol.WayMapCfg.Builder>(internal__static_Protocol_WayMapCfg__Descriptor,
                new string[] { "Points", "Lines", });
        internal__static_Protocol_WayPointCfg__Descriptor = Descriptor.MessageTypes[7];
        internal__static_Protocol_WayPointCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayPointCfg, global::Protocol.WayPointCfg.Builder>(internal__static_Protocol_WayPointCfg__Descriptor,
                new string[] { "Id", "MapId", "Position", "Forward", "MinStandTime", "MaxStandTime", "Type", "LineCount", "PassLineTime", "NeedOffset", "OffsetValue", });
        internal__static_Protocol_WayLineCfg__Descriptor = Descriptor.MessageTypes[8];
        internal__static_Protocol_WayLineCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.WayLineCfg, global::Protocol.WayLineCfg.Builder>(internal__static_Protocol_WayLineCfg__Descriptor,
                new string[] { "Head", "Last", "Cost", "IsOneWay", });
        internal__static_Protocol_ThingWayMap__Descriptor = Descriptor.MessageTypes[9];
        internal__static_Protocol_ThingWayMap__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.ThingWayMap, global::Protocol.ThingWayMap.Builder>(internal__static_Protocol_ThingWayMap__Descriptor,
                new string[] { "Id", "WayMapCfg", });
        internal__static_Protocol_CellCfg__Descriptor = Descriptor.MessageTypes[10];
        internal__static_Protocol_CellCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.CellCfg, global::Protocol.CellCfg.Builder>(internal__static_Protocol_CellCfg__Descriptor,
                new string[] { "TerrainType", "Elevation", "WaterLevel", "UrbanLevel", "FarmLevel", "PlantLevel", "SpecialIndex", "IsWall", "IncomingRiver", "OutgoingRiver", "RoadFlags", "IsExplored", "Index", "Position", "NeighborCellIndexList", });
        internal__static_Protocol_UnitCfg__Descriptor = Descriptor.MessageTypes[11];
        internal__static_Protocol_UnitCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.UnitCfg, global::Protocol.UnitCfg.Builder>(internal__static_Protocol_UnitCfg__Descriptor,
                new string[] { "X", "Y", "Rotation", });
        internal__static_Protocol_AnimatorCfg__Descriptor = Descriptor.MessageTypes[12];
        internal__static_Protocol_AnimatorCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.AnimatorCfg, global::Protocol.AnimatorCfg.Builder>(internal__static_Protocol_AnimatorCfg__Descriptor,
                new string[] { "AnimatorName", "ClipCount", "ClipCfgList", });
        internal__static_Protocol_AnimationClipCfg__Descriptor = Descriptor.MessageTypes[13];
        internal__static_Protocol_AnimationClipCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.AnimationClipCfg, global::Protocol.AnimationClipCfg.Builder>(internal__static_Protocol_AnimationClipCfg__Descriptor,
                new string[] { "ClipName", "ClipLength", "ClipId", });
        internal__static_Protocol_MoveKeyFrame__Descriptor = Descriptor.MessageTypes[14];
        internal__static_Protocol_MoveKeyFrame__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveKeyFrame, global::Protocol.MoveKeyFrame.Builder>(internal__static_Protocol_MoveKeyFrame__Descriptor,
                new string[] { "Time", "Value", "InTangent", "OutTangent", "InWeight", "OutWeight", });
        internal__static_Protocol_MoveMotion__Descriptor = Descriptor.MessageTypes[15];
        internal__static_Protocol_MoveMotion__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveMotion, global::Protocol.MoveMotion.Builder>(internal__static_Protocol_MoveMotion__Descriptor,
                new string[] { "Length", "PositionXCurve", "PositionZCurve", "RotationXCurve", "RotationYCurve", "RotationZCurve", "RotationWCurve", "MotionName", "PositionYCurve", "IsLoop", "ScaleXCurve", "ScaleYCurve", "ScaleZCurve", "MotionType", "FrameCount", });
        internal__static_Protocol_BlendNode__Descriptor = Descriptor.MessageTypes[16];
        internal__static_Protocol_BlendNode__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.BlendNode, global::Protocol.BlendNode.Builder>(internal__static_Protocol_BlendNode__Descriptor,
                new string[] { "MoveSpeed", "AngleSpeed", "XPostion", "YPostion", "MoveDir", "Length", "IsAddtion", "Motion", "BoundCenter", "BoundSize", "HeadPosition", "HeadRotation", "FrameCount", });
        internal__static_Protocol_Blender__Descriptor = Descriptor.MessageTypes[17];
        internal__static_Protocol_Blender__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.Blender, global::Protocol.Blender.Builder>(internal__static_Protocol_Blender__Descriptor,
                new string[] { "BlendType", "NodeList", "Length", "Name", "IsFixAngle", });
        internal__static_Protocol_MoveControllerCfg__Descriptor = Descriptor.MessageTypes[18];
        internal__static_Protocol_MoveControllerCfg__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Protocol.MoveControllerCfg, global::Protocol.MoveControllerCfg.Builder>(internal__static_Protocol_MoveControllerCfg__Descriptor,
                new string[] { "ExportMotions", "ExportBlenders", "WeaponPath", "BoundPathList", "HeadPath", "HeadSize", });
        pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();
        RegisterAllExtensions(registry);
        global::Protocol.ProtoCommon.RegisterAllExtensions(registry);
        global::Protocol.ProtoConfig.RegisterAllExtensions(registry);
        return registry;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::Protocol.ProtoCommon.Descriptor, 
          global::Protocol.ProtoConfig.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Enums
  public enum BlendType {
    BT_None = 0,
    Simple = 1,
    Polar = 2,
    Cartesian = 3,
    Simple1D = 4,
  }
  
  #endregion
  
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LevelCfg : pb::GeneratedMessage<LevelCfg, LevelCfg.Builder> {
    public LevelCfg() { }
    private static readonly LevelCfg defaultInstance = new LevelCfg().MakeReadOnly();
    private static readonly string[] _levelCfgFieldNames = new string[] { "battle_cfg" };
    private static readonly uint[] _levelCfgFieldTags = new uint[] { 10 };
    public static LevelCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LevelCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LevelCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_LevelCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LevelCfg, LevelCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_LevelCfg__FieldAccessorTable; }
    }
    
    public const int BattleCfgFieldNumber = 1;
    private bool hasBattleCfg;
    private global::Protocol.BattleCfg battleCfg_;
    public bool HasBattleCfg {
      get { return hasBattleCfg; }
    }
    public global::Protocol.BattleCfg BattleCfg {
      get { return battleCfg_; }
      set { hasBattleCfg = true;
        battleCfg_ = value;}
    }
    public void MergeBattleCfg(global::Protocol.BattleCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasBattleCfg &&
        battleCfg_ != global::Protocol.BattleCfg.DefaultInstance) {
        battleCfg_.MergeFrom(value, isFull);
      } else {
        battleCfg_ = value;
      }
    }
    
    public override bool IsInitialized {
      get {
        if (HasBattleCfg) {
          if (!BattleCfg.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _levelCfgFieldNames;
      if (hasBattleCfg) {
        output.WriteMessage(1, field_names[0], BattleCfg);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasBattleCfg) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, BattleCfg);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public LevelCfg CommitChange() {
      LevelCfg other = new LevelCfg();
      bool isChange = false;
      
      var BattleCfgcommit = BattleCfg?.CommitChange();
      if(BattleCfgcommit!=null)
      {
          isChange = true;
          other.BattleCfg = BattleCfgcommit;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(LevelCfg other, bool isFull = false) {
      if (other == global::Protocol.LevelCfg.DefaultInstance) return;
      
      if (other.HasBattleCfg)
      {
        MergeBattleCfg(other.BattleCfg, isFull);
      }
    }
    
    public static LevelCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LevelCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LevelCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LevelCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LevelCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LevelCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LevelCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LevelCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LevelCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LevelCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LevelCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LevelCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<LevelCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LevelCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LevelCfg result;
      
      private LevelCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          LevelCfg original = result;
          result = new LevelCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LevelCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.LevelCfg.Descriptor; }
      }
      
      public override LevelCfg DefaultInstanceForType {
        get { return global::Protocol.LevelCfg.DefaultInstance; }
      }
      
      public override LevelCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LevelCfg) {
          return MergeFrom((LevelCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LevelCfg other) {
        if (other == global::Protocol.LevelCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBattleCfg) {
          MergeBattleCfg(other.BattleCfg);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_levelCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _levelCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Protocol.BattleCfg.Builder subBuilder = global::Protocol.BattleCfg.CreateBuilder();
              if (result.hasBattleCfg) {
                subBuilder.MergeFrom(BattleCfg);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BattleCfg = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasBattleCfg {
       get { return result.hasBattleCfg; }
      }
      public global::Protocol.BattleCfg BattleCfg {
        get { return result.BattleCfg; }
        set { SetBattleCfg(value); }
      }
      public Builder SetBattleCfg(global::Protocol.BattleCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBattleCfg = true;
        result.battleCfg_ = value;
        return this;
      }
      public Builder SetBattleCfg(global::Protocol.BattleCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBattleCfg = true;
        result.battleCfg_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBattleCfg(global::Protocol.BattleCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasBattleCfg &&
            result.battleCfg_ != global::Protocol.BattleCfg.DefaultInstance) {
            result.battleCfg_ = global::Protocol.BattleCfg.CreateBuilder(result.battleCfg_).MergeFrom(value).BuildPartial();
        } else {
          result.battleCfg_ = value;
          result.hasBattleCfg = true;
        }
        return this;
      }
      public Builder ClearBattleCfg() {
        PrepareBuilder();
        result.hasBattleCfg = false;
        result.battleCfg_ = null;
        return this;
      }
    }
    static LevelCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MapCfg : pb::GeneratedMessage<MapCfg, MapCfg.Builder> {
    public MapCfg() { }
    private static readonly MapCfg defaultInstance = new MapCfg().MakeReadOnly();
    private static readonly string[] _mapCfgFieldNames = new string[] { "cell_cfg_list", "cell_x", "cell_y", "is_warp", "map_file_version", "uint_count", "unit_cfg_list" };
    private static readonly uint[] _mapCfgFieldTags = new uint[] { 34, 8, 16, 24, 56, 40, 50 };
    public static MapCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MapCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MapCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MapCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MapCfg, MapCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MapCfg__FieldAccessorTable; }
    }
    
    public const int CellXFieldNumber = 1;
    private bool hasCellX;
    private int cellX_;
    public bool HasCellX {
      get { return hasCellX; }
    }
    public int CellX {
      get { return cellX_; }
      set { hasCellX = true;
        cellX_ = value;}
    }
    
    public const int CellYFieldNumber = 2;
    private bool hasCellY;
    private int cellY_;
    public bool HasCellY {
      get { return hasCellY; }
    }
    public int CellY {
      get { return cellY_; }
      set { hasCellY = true;
        cellY_ = value;}
    }
    
    public const int IsWarpFieldNumber = 3;
    private bool hasIsWarp;
    private bool isWarp_;
    public bool HasIsWarp {
      get { return hasIsWarp; }
    }
    public bool IsWarp {
      get { return isWarp_; }
      set { hasIsWarp = true;
        isWarp_ = value;}
    }
    
    public const int CellCfgListFieldNumber = 4;
    private pbc::PopsicleList<global::Protocol.CellCfg> cellCfgList_ = new pbc::PopsicleList<global::Protocol.CellCfg>();
    public scg::IList<global::Protocol.CellCfg> CellCfgList {
      get { return pbc::Lists.AsReadOnly(cellCfgList_); }
    }
    public int CellCfgListCount {
      get { return cellCfgList_.Count; }
    }
    public global::Protocol.CellCfg GetCellCfgList(int index) {
      return cellCfgList_[index];
    }
    public global::Protocol.CellCfg FindCellCfgList(System.Predicate<global::Protocol.CellCfg> match) {
      return cellCfgList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.CellCfg> FindAllCellCfgList(System.Predicate<global::Protocol.CellCfg> match) {
      return cellCfgList_.FindAll(match);
    }
    public void SetCellCfgList(int index, global::Protocol.CellCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= cellCfgList_.Count) return;
      cellCfgList_[index] = value;
    }
    public void AddCellCfgList(global::Protocol.CellCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      cellCfgList_.Add(value);
    }
    public void AddRangeCellCfgList(scg::IEnumerable<global::Protocol.CellCfg> values) {
      cellCfgList_.Add(values);
    }
    public void RemoveCellCfgList(global::Protocol.CellCfg value) {
      if (!cellCfgList_.Contains(value)) return;
      cellCfgList_.Remove(value);
    }
    public void RemoveAtCellCfgList(int index) {
      if (index < 0 || index >= cellCfgList_.Count) return;
      cellCfgList_.RemoveAt(index);
    }
    public void ClearCellCfgList() {
      if (cellCfgList_.Count <= 0) return;
      cellCfgList_.Clear();
    }
    
    public const int UintCountFieldNumber = 5;
    private bool hasUintCount;
    private int uintCount_;
    public bool HasUintCount {
      get { return hasUintCount; }
    }
    public int UintCount {
      get { return uintCount_; }
      set { hasUintCount = true;
        uintCount_ = value;}
    }
    
    public const int UnitCfgListFieldNumber = 6;
    private pbc::PopsicleList<global::Protocol.UnitCfg> unitCfgList_ = new pbc::PopsicleList<global::Protocol.UnitCfg>();
    public scg::IList<global::Protocol.UnitCfg> UnitCfgList {
      get { return pbc::Lists.AsReadOnly(unitCfgList_); }
    }
    public int UnitCfgListCount {
      get { return unitCfgList_.Count; }
    }
    public global::Protocol.UnitCfg GetUnitCfgList(int index) {
      return unitCfgList_[index];
    }
    public global::Protocol.UnitCfg FindUnitCfgList(System.Predicate<global::Protocol.UnitCfg> match) {
      return unitCfgList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.UnitCfg> FindAllUnitCfgList(System.Predicate<global::Protocol.UnitCfg> match) {
      return unitCfgList_.FindAll(match);
    }
    public void SetUnitCfgList(int index, global::Protocol.UnitCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= unitCfgList_.Count) return;
      unitCfgList_[index] = value;
    }
    public void AddUnitCfgList(global::Protocol.UnitCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      unitCfgList_.Add(value);
    }
    public void AddRangeUnitCfgList(scg::IEnumerable<global::Protocol.UnitCfg> values) {
      unitCfgList_.Add(values);
    }
    public void RemoveUnitCfgList(global::Protocol.UnitCfg value) {
      if (!unitCfgList_.Contains(value)) return;
      unitCfgList_.Remove(value);
    }
    public void RemoveAtUnitCfgList(int index) {
      if (index < 0 || index >= unitCfgList_.Count) return;
      unitCfgList_.RemoveAt(index);
    }
    public void ClearUnitCfgList() {
      if (unitCfgList_.Count <= 0) return;
      unitCfgList_.Clear();
    }
    
    public const int MapFileVersionFieldNumber = 7;
    private bool hasMapFileVersion;
    private int mapFileVersion_;
    public bool HasMapFileVersion {
      get { return hasMapFileVersion; }
    }
    public int MapFileVersion {
      get { return mapFileVersion_; }
      set { hasMapFileVersion = true;
        mapFileVersion_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCellX) return false;
        if (!hasCellY) return false;
        if (!hasIsWarp) return false;
        if (!hasUintCount) return false;
        if (!hasMapFileVersion) return false;
        foreach (global::Protocol.CellCfg element in CellCfgList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Protocol.UnitCfg element in UnitCfgList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _mapCfgFieldNames;
      if (hasCellX) {
        output.WriteInt32(1, field_names[1], CellX);
      }
      if (hasCellY) {
        output.WriteInt32(2, field_names[2], CellY);
      }
      if (hasIsWarp) {
        output.WriteBool(3, field_names[3], IsWarp);
      }
      if (cellCfgList_.Count > 0) {
        output.WriteMessageArray(4, field_names[0], cellCfgList_);
      }
      if (hasUintCount) {
        output.WriteInt32(5, field_names[5], UintCount);
      }
      if (unitCfgList_.Count > 0) {
        output.WriteMessageArray(6, field_names[6], unitCfgList_);
      }
      if (hasMapFileVersion) {
        output.WriteInt32(7, field_names[4], MapFileVersion);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasCellX) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, CellX);
      }
      if (hasCellY) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, CellY);
      }
      if (hasIsWarp) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, IsWarp);
      }
      foreach (global::Protocol.CellCfg element in CellCfgList) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      if (hasUintCount) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, UintCount);
      }
      foreach (global::Protocol.UnitCfg element in UnitCfgList) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      if (hasMapFileVersion) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, MapFileVersion);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public MapCfg CommitChange() {
      MapCfg other = new MapCfg();
      bool isChange = false;
      other.CellX = CellX;
      other.CellY = CellY;
      other.IsWarp = IsWarp;
      isChange = true;
      other.cellCfgList_.Add(cellCfgList_);
      other.UintCount = UintCount;
      isChange = true;
      other.unitCfgList_.Add(unitCfgList_);
      other.MapFileVersion = MapFileVersion;
      return isChange?other:null;
    }
    
    public void MergeFrom(MapCfg other, bool isFull = false) {
      if (other == global::Protocol.MapCfg.DefaultInstance) return;
      if (other.HasCellX) {
        CellX = other.CellX;
      }
      if (other.HasCellY) {
        CellY = other.CellY;
      }
      if (other.HasIsWarp) {
        IsWarp = other.IsWarp;
      }
        cellCfgList_.Clear();
        cellCfgList_.Add(other.cellCfgList_);
      if (other.HasUintCount) {
        UintCount = other.UintCount;
      }
        unitCfgList_.Clear();
        unitCfgList_.Add(other.unitCfgList_);
      if (other.HasMapFileVersion) {
        MapFileVersion = other.MapFileVersion;
      }
    }
    
    public static MapCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MapCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MapCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MapCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MapCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MapCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MapCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MapCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MapCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MapCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MapCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MapCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MapCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MapCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MapCfg result;
      
      private MapCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          MapCfg original = result;
          result = new MapCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MapCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.MapCfg.Descriptor; }
      }
      
      public override MapCfg DefaultInstanceForType {
        get { return global::Protocol.MapCfg.DefaultInstance; }
      }
      
      public override MapCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MapCfg) {
          return MergeFrom((MapCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MapCfg other) {
        if (other == global::Protocol.MapCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCellX) {
          CellX = other.CellX;
        }
        if (other.HasCellY) {
          CellY = other.CellY;
        }
        if (other.HasIsWarp) {
          IsWarp = other.IsWarp;
        }
        if (other.cellCfgList_.Count != 0) {
          result.cellCfgList_.Add(other.cellCfgList_);
        }
        if (other.HasUintCount) {
          UintCount = other.UintCount;
        }
        if (other.unitCfgList_.Count != 0) {
          result.unitCfgList_.Add(other.unitCfgList_);
        }
        if (other.HasMapFileVersion) {
          MapFileVersion = other.MapFileVersion;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_mapCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _mapCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCellX = input.ReadInt32(ref result.cellX_);
              break;
            }
            case 16: {
              result.hasCellY = input.ReadInt32(ref result.cellY_);
              break;
            }
            case 24: {
              result.hasIsWarp = input.ReadBool(ref result.isWarp_);
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.cellCfgList_, global::Protocol.CellCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 40: {
              result.hasUintCount = input.ReadInt32(ref result.uintCount_);
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.unitCfgList_, global::Protocol.UnitCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 56: {
              result.hasMapFileVersion = input.ReadInt32(ref result.mapFileVersion_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCellX {
        get { return result.hasCellX; }
      }
      public int CellX {
        get { return result.CellX; }
        set { SetCellX(value); }
      }
      public Builder SetCellX(int value) {
        PrepareBuilder();
        result.hasCellX = true;
        result.cellX_ = value;
        return this;
      }
      public Builder ClearCellX() {
        PrepareBuilder();
        result.hasCellX = false;
        result.cellX_ = 0;
        return this;
      }
      
      public bool HasCellY {
        get { return result.hasCellY; }
      }
      public int CellY {
        get { return result.CellY; }
        set { SetCellY(value); }
      }
      public Builder SetCellY(int value) {
        PrepareBuilder();
        result.hasCellY = true;
        result.cellY_ = value;
        return this;
      }
      public Builder ClearCellY() {
        PrepareBuilder();
        result.hasCellY = false;
        result.cellY_ = 0;
        return this;
      }
      
      public bool HasIsWarp {
        get { return result.hasIsWarp; }
      }
      public bool IsWarp {
        get { return result.IsWarp; }
        set { SetIsWarp(value); }
      }
      public Builder SetIsWarp(bool value) {
        PrepareBuilder();
        result.hasIsWarp = true;
        result.isWarp_ = value;
        return this;
      }
      public Builder ClearIsWarp() {
        PrepareBuilder();
        result.hasIsWarp = false;
        result.isWarp_ = false;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.CellCfg> CellCfgList {
        get { return PrepareBuilder().cellCfgList_; }
      }
      public int CellCfgListCount {
        get { return result.CellCfgListCount; }
      }
      public global::Protocol.CellCfg GetCellCfgList(int index) {
        return result.GetCellCfgList(index);
      }
      public Builder SetCellCfgList(int index, global::Protocol.CellCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.cellCfgList_[index] = value;
        return this;
      }
      public Builder SetCellCfgList(int index, global::Protocol.CellCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.cellCfgList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddCellCfgList(global::Protocol.CellCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.cellCfgList_.Add(value);
        return this;
      }
      public Builder AddCellCfgList(global::Protocol.CellCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.cellCfgList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeCellCfgList(scg::IEnumerable<global::Protocol.CellCfg> values) {
        PrepareBuilder();
        result.cellCfgList_.Add(values);
        return this;
      }
      public Builder ClearCellCfgList() {
        PrepareBuilder();
        result.cellCfgList_.Clear();
        return this;
      }
      
      public bool HasUintCount {
        get { return result.hasUintCount; }
      }
      public int UintCount {
        get { return result.UintCount; }
        set { SetUintCount(value); }
      }
      public Builder SetUintCount(int value) {
        PrepareBuilder();
        result.hasUintCount = true;
        result.uintCount_ = value;
        return this;
      }
      public Builder ClearUintCount() {
        PrepareBuilder();
        result.hasUintCount = false;
        result.uintCount_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.UnitCfg> UnitCfgList {
        get { return PrepareBuilder().unitCfgList_; }
      }
      public int UnitCfgListCount {
        get { return result.UnitCfgListCount; }
      }
      public global::Protocol.UnitCfg GetUnitCfgList(int index) {
        return result.GetUnitCfgList(index);
      }
      public Builder SetUnitCfgList(int index, global::Protocol.UnitCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.unitCfgList_[index] = value;
        return this;
      }
      public Builder SetUnitCfgList(int index, global::Protocol.UnitCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.unitCfgList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddUnitCfgList(global::Protocol.UnitCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.unitCfgList_.Add(value);
        return this;
      }
      public Builder AddUnitCfgList(global::Protocol.UnitCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.unitCfgList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeUnitCfgList(scg::IEnumerable<global::Protocol.UnitCfg> values) {
        PrepareBuilder();
        result.unitCfgList_.Add(values);
        return this;
      }
      public Builder ClearUnitCfgList() {
        PrepareBuilder();
        result.unitCfgList_.Clear();
        return this;
      }
      
      public bool HasMapFileVersion {
        get { return result.hasMapFileVersion; }
      }
      public int MapFileVersion {
        get { return result.MapFileVersion; }
        set { SetMapFileVersion(value); }
      }
      public Builder SetMapFileVersion(int value) {
        PrepareBuilder();
        result.hasMapFileVersion = true;
        result.mapFileVersion_ = value;
        return this;
      }
      public Builder ClearMapFileVersion() {
        PrepareBuilder();
        result.hasMapFileVersion = false;
        result.mapFileVersion_ = 0;
        return this;
      }
    }
    static MapCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class BattleCfg : pb::GeneratedMessage<BattleCfg, BattleCfg.Builder> {
    public BattleCfg() { }
    private static readonly BattleCfg defaultInstance = new BattleCfg().MakeReadOnly();
    private static readonly string[] _battleCfgFieldNames = new string[] { "hero_born_list", "monster_born_list", "way_map_cfg" };
    private static readonly uint[] _battleCfgFieldTags = new uint[] { 10, 18, 26 };
    public static BattleCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BattleCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BattleCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BattleCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BattleCfg, BattleCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BattleCfg__FieldAccessorTable; }
    }
    
    public const int HeroBornListFieldNumber = 1;
    private pbc::PopsicleList<global::Protocol.HeroBornCfg> heroBornList_ = new pbc::PopsicleList<global::Protocol.HeroBornCfg>();
    public scg::IList<global::Protocol.HeroBornCfg> HeroBornList {
      get { return pbc::Lists.AsReadOnly(heroBornList_); }
    }
    public int HeroBornListCount {
      get { return heroBornList_.Count; }
    }
    public global::Protocol.HeroBornCfg GetHeroBornList(int index) {
      return heroBornList_[index];
    }
    public global::Protocol.HeroBornCfg FindHeroBornList(System.Predicate<global::Protocol.HeroBornCfg> match) {
      return heroBornList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.HeroBornCfg> FindAllHeroBornList(System.Predicate<global::Protocol.HeroBornCfg> match) {
      return heroBornList_.FindAll(match);
    }
    public void SetHeroBornList(int index, global::Protocol.HeroBornCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= heroBornList_.Count) return;
      heroBornList_[index] = value;
    }
    public void AddHeroBornList(global::Protocol.HeroBornCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      heroBornList_.Add(value);
    }
    public void AddRangeHeroBornList(scg::IEnumerable<global::Protocol.HeroBornCfg> values) {
      heroBornList_.Add(values);
    }
    public void RemoveHeroBornList(global::Protocol.HeroBornCfg value) {
      if (!heroBornList_.Contains(value)) return;
      heroBornList_.Remove(value);
    }
    public void RemoveAtHeroBornList(int index) {
      if (index < 0 || index >= heroBornList_.Count) return;
      heroBornList_.RemoveAt(index);
    }
    public void ClearHeroBornList() {
      if (heroBornList_.Count <= 0) return;
      heroBornList_.Clear();
    }
    
    public const int MonsterBornListFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.MonsterBornCfg> monsterBornList_ = new pbc::PopsicleList<global::Protocol.MonsterBornCfg>();
    public scg::IList<global::Protocol.MonsterBornCfg> MonsterBornList {
      get { return pbc::Lists.AsReadOnly(monsterBornList_); }
    }
    public int MonsterBornListCount {
      get { return monsterBornList_.Count; }
    }
    public global::Protocol.MonsterBornCfg GetMonsterBornList(int index) {
      return monsterBornList_[index];
    }
    public global::Protocol.MonsterBornCfg FindMonsterBornList(System.Predicate<global::Protocol.MonsterBornCfg> match) {
      return monsterBornList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MonsterBornCfg> FindAllMonsterBornList(System.Predicate<global::Protocol.MonsterBornCfg> match) {
      return monsterBornList_.FindAll(match);
    }
    public void SetMonsterBornList(int index, global::Protocol.MonsterBornCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= monsterBornList_.Count) return;
      monsterBornList_[index] = value;
    }
    public void AddMonsterBornList(global::Protocol.MonsterBornCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      monsterBornList_.Add(value);
    }
    public void AddRangeMonsterBornList(scg::IEnumerable<global::Protocol.MonsterBornCfg> values) {
      monsterBornList_.Add(values);
    }
    public void RemoveMonsterBornList(global::Protocol.MonsterBornCfg value) {
      if (!monsterBornList_.Contains(value)) return;
      monsterBornList_.Remove(value);
    }
    public void RemoveAtMonsterBornList(int index) {
      if (index < 0 || index >= monsterBornList_.Count) return;
      monsterBornList_.RemoveAt(index);
    }
    public void ClearMonsterBornList() {
      if (monsterBornList_.Count <= 0) return;
      monsterBornList_.Clear();
    }
    
    public const int WayMapCfgFieldNumber = 3;
    private bool hasWayMapCfg;
    private global::Protocol.WayMapCfg wayMapCfg_;
    public bool HasWayMapCfg {
      get { return hasWayMapCfg; }
    }
    public global::Protocol.WayMapCfg WayMapCfg {
      get { return wayMapCfg_; }
      set { hasWayMapCfg = true;
        wayMapCfg_ = value;}
    }
    public void MergeWayMapCfg(global::Protocol.WayMapCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasWayMapCfg &&
        wayMapCfg_ != global::Protocol.WayMapCfg.DefaultInstance) {
        wayMapCfg_.MergeFrom(value, isFull);
      } else {
        wayMapCfg_ = value;
      }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Protocol.HeroBornCfg element in HeroBornList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Protocol.MonsterBornCfg element in MonsterBornList) {
          if (!element.IsInitialized) return false;
        }
        if (HasWayMapCfg) {
          if (!WayMapCfg.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _battleCfgFieldNames;
      if (heroBornList_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], heroBornList_);
      }
      if (monsterBornList_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], monsterBornList_);
      }
      if (hasWayMapCfg) {
        output.WriteMessage(3, field_names[2], WayMapCfg);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      foreach (global::Protocol.HeroBornCfg element in HeroBornList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      foreach (global::Protocol.MonsterBornCfg element in MonsterBornList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasWayMapCfg) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, WayMapCfg);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public BattleCfg CommitChange() {
      BattleCfg other = new BattleCfg();
      bool isChange = false;
      isChange = true;
      other.heroBornList_.Add(heroBornList_);
      isChange = true;
      other.monsterBornList_.Add(monsterBornList_);
      
      var WayMapCfgcommit = WayMapCfg?.CommitChange();
      if(WayMapCfgcommit!=null)
      {
          isChange = true;
          other.WayMapCfg = WayMapCfgcommit;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(BattleCfg other, bool isFull = false) {
      if (other == global::Protocol.BattleCfg.DefaultInstance) return;
        heroBornList_.Clear();
        heroBornList_.Add(other.heroBornList_);
        monsterBornList_.Clear();
        monsterBornList_.Add(other.monsterBornList_);
      
      if (other.HasWayMapCfg)
      {
        MergeWayMapCfg(other.WayMapCfg, isFull);
      }
    }
    
    public static BattleCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BattleCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BattleCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BattleCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BattleCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BattleCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BattleCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BattleCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BattleCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BattleCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BattleCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BattleCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<BattleCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BattleCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BattleCfg result;
      
      private BattleCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          BattleCfg original = result;
          result = new BattleCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BattleCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.BattleCfg.Descriptor; }
      }
      
      public override BattleCfg DefaultInstanceForType {
        get { return global::Protocol.BattleCfg.DefaultInstance; }
      }
      
      public override BattleCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BattleCfg) {
          return MergeFrom((BattleCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BattleCfg other) {
        if (other == global::Protocol.BattleCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.heroBornList_.Count != 0) {
          result.heroBornList_.Add(other.heroBornList_);
        }
        if (other.monsterBornList_.Count != 0) {
          result.monsterBornList_.Add(other.monsterBornList_);
        }
        if (other.HasWayMapCfg) {
          MergeWayMapCfg(other.WayMapCfg);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_battleCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _battleCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.heroBornList_, global::Protocol.HeroBornCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.monsterBornList_, global::Protocol.MonsterBornCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              global::Protocol.WayMapCfg.Builder subBuilder = global::Protocol.WayMapCfg.CreateBuilder();
              if (result.hasWayMapCfg) {
                subBuilder.MergeFrom(WayMapCfg);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              WayMapCfg = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Protocol.HeroBornCfg> HeroBornList {
        get { return PrepareBuilder().heroBornList_; }
      }
      public int HeroBornListCount {
        get { return result.HeroBornListCount; }
      }
      public global::Protocol.HeroBornCfg GetHeroBornList(int index) {
        return result.GetHeroBornList(index);
      }
      public Builder SetHeroBornList(int index, global::Protocol.HeroBornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.heroBornList_[index] = value;
        return this;
      }
      public Builder SetHeroBornList(int index, global::Protocol.HeroBornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.heroBornList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddHeroBornList(global::Protocol.HeroBornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.heroBornList_.Add(value);
        return this;
      }
      public Builder AddHeroBornList(global::Protocol.HeroBornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.heroBornList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeHeroBornList(scg::IEnumerable<global::Protocol.HeroBornCfg> values) {
        PrepareBuilder();
        result.heroBornList_.Add(values);
        return this;
      }
      public Builder ClearHeroBornList() {
        PrepareBuilder();
        result.heroBornList_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MonsterBornCfg> MonsterBornList {
        get { return PrepareBuilder().monsterBornList_; }
      }
      public int MonsterBornListCount {
        get { return result.MonsterBornListCount; }
      }
      public global::Protocol.MonsterBornCfg GetMonsterBornList(int index) {
        return result.GetMonsterBornList(index);
      }
      public Builder SetMonsterBornList(int index, global::Protocol.MonsterBornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.monsterBornList_[index] = value;
        return this;
      }
      public Builder SetMonsterBornList(int index, global::Protocol.MonsterBornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.monsterBornList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddMonsterBornList(global::Protocol.MonsterBornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.monsterBornList_.Add(value);
        return this;
      }
      public Builder AddMonsterBornList(global::Protocol.MonsterBornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.monsterBornList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeMonsterBornList(scg::IEnumerable<global::Protocol.MonsterBornCfg> values) {
        PrepareBuilder();
        result.monsterBornList_.Add(values);
        return this;
      }
      public Builder ClearMonsterBornList() {
        PrepareBuilder();
        result.monsterBornList_.Clear();
        return this;
      }
      
      public bool HasWayMapCfg {
       get { return result.hasWayMapCfg; }
      }
      public global::Protocol.WayMapCfg WayMapCfg {
        get { return result.WayMapCfg; }
        set { SetWayMapCfg(value); }
      }
      public Builder SetWayMapCfg(global::Protocol.WayMapCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWayMapCfg = true;
        result.wayMapCfg_ = value;
        return this;
      }
      public Builder SetWayMapCfg(global::Protocol.WayMapCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasWayMapCfg = true;
        result.wayMapCfg_ = builderForValue.Build();
        return this;
      }
      public Builder MergeWayMapCfg(global::Protocol.WayMapCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasWayMapCfg &&
            result.wayMapCfg_ != global::Protocol.WayMapCfg.DefaultInstance) {
            result.wayMapCfg_ = global::Protocol.WayMapCfg.CreateBuilder(result.wayMapCfg_).MergeFrom(value).BuildPartial();
        } else {
          result.wayMapCfg_ = value;
          result.hasWayMapCfg = true;
        }
        return this;
      }
      public Builder ClearWayMapCfg() {
        PrepareBuilder();
        result.hasWayMapCfg = false;
        result.wayMapCfg_ = null;
        return this;
      }
    }
    static BattleCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class BornCfg : pb::GeneratedMessage<BornCfg, BornCfg.Builder> {
    public BornCfg() { }
    private static readonly BornCfg defaultInstance = new BornCfg().MakeReadOnly();
    private static readonly string[] _bornCfgFieldNames = new string[] { "camp", "e_type", "postion", "rotation" };
    private static readonly uint[] _bornCfgFieldTags = new uint[] { 32, 8, 18, 26 };
    public static BornCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BornCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BornCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BornCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BornCfg, BornCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BornCfg__FieldAccessorTable; }
    }
    
    public const int ETypeFieldNumber = 1;
    private bool hasEType;
    private global::Protocol.EntityType eType_ = global::Protocol.EntityType.Hero;
    public bool HasEType {
      get { return hasEType; }
    }
    public global::Protocol.EntityType EType {
      get { return eType_; }
      set { hasEType = true;
        eType_ = value;}
    }
    
    public const int PostionFieldNumber = 2;
    private bool hasPostion;
    private global::Protocol.Float3 postion_;
    public bool HasPostion {
      get { return hasPostion; }
    }
    public global::Protocol.Float3 Postion {
      get { return postion_; }
      set { hasPostion = true;
        postion_ = value;}
    }
    public void MergePostion(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasPostion &&
        postion_ != global::Protocol.Float3.DefaultInstance) {
        postion_.MergeFrom(value, isFull);
      } else {
        postion_ = value;
      }
    }
    
    public const int RotationFieldNumber = 3;
    private bool hasRotation;
    private global::Protocol.Float3 rotation_;
    public bool HasRotation {
      get { return hasRotation; }
    }
    public global::Protocol.Float3 Rotation {
      get { return rotation_; }
      set { hasRotation = true;
        rotation_ = value;}
    }
    public void MergeRotation(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasRotation &&
        rotation_ != global::Protocol.Float3.DefaultInstance) {
        rotation_.MergeFrom(value, isFull);
      } else {
        rotation_ = value;
      }
    }
    
    public const int CampFieldNumber = 4;
    private bool hasCamp;
    private bool isCampChanged = true;
    private uint camp_;
    public bool HasCamp {
      get { return hasCamp; }
    }
    [global::System.CLSCompliant(false)]
    public uint Camp {
      get { return camp_; }
      set { hasCamp = true;
        isCampChanged = true;
        camp_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasEType) return false;
        if (!hasPostion) return false;
        if (!hasRotation) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _bornCfgFieldNames;
      if (hasEType) {
        output.WriteEnum(1, field_names[1], (int) EType, EType);
      }
      if (hasPostion) {
        output.WriteMessage(2, field_names[2], Postion);
      }
      if (hasRotation) {
        output.WriteMessage(3, field_names[3], Rotation);
      }
      if (hasCamp) {
        output.WriteUInt32(4, field_names[0], Camp);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasEType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) EType);
      }
      if (hasPostion) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Postion);
      }
      if (hasRotation) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Rotation);
      }
      if (hasCamp) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, Camp);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public BornCfg CommitChange() {
      BornCfg other = new BornCfg();
      bool isChange = false;
      other.EType = EType;
      
      var Postioncommit = Postion?.CommitChange();
      if(Postioncommit!=null)
      {
          isChange = true;
          other.Postion = Postioncommit;
      }
      
      var Rotationcommit = Rotation?.CommitChange();
      if(Rotationcommit!=null)
      {
          isChange = true;
          other.Rotation = Rotationcommit;
      }
      if (isCampChanged) {
        isChange = true;
        other.Camp = Camp;
        isCampChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(BornCfg other, bool isFull = false) {
      if (other == global::Protocol.BornCfg.DefaultInstance) return;
      if (other.HasEType) {
        EType = other.EType;
      }
      
      if (other.HasPostion)
      {
        MergePostion(other.Postion, isFull);
      }
      
      if (other.HasRotation)
      {
        MergeRotation(other.Rotation, isFull);
      }
      if (other.HasCamp) {
        Camp = other.Camp;
      }
    }
    
    public static BornCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BornCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BornCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BornCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BornCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BornCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BornCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BornCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BornCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BornCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BornCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BornCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<BornCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BornCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BornCfg result;
      
      private BornCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          BornCfg original = result;
          result = new BornCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BornCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.BornCfg.Descriptor; }
      }
      
      public override BornCfg DefaultInstanceForType {
        get { return global::Protocol.BornCfg.DefaultInstance; }
      }
      
      public override BornCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BornCfg) {
          return MergeFrom((BornCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BornCfg other) {
        if (other == global::Protocol.BornCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasEType) {
          EType = other.EType;
        }
        if (other.HasPostion) {
          MergePostion(other.Postion);
        }
        if (other.HasRotation) {
          MergeRotation(other.Rotation);
        }
        if (other.HasCamp) {
          Camp = other.Camp;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_bornCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _bornCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.eType_, out unknown)) {
                result.hasEType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasPostion) {
                subBuilder.MergeFrom(Postion);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Postion = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasRotation) {
                subBuilder.MergeFrom(Rotation);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Rotation = subBuilder.BuildPartial();
              break;
            }
            case 32: {
              result.hasCamp = input.ReadUInt32(ref result.camp_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasEType {
       get { return result.hasEType; }
      }
      public global::Protocol.EntityType EType {
        get { return result.EType; }
        set { SetEType(value); }
      }
      public Builder SetEType(global::Protocol.EntityType value) {
        PrepareBuilder();
        result.hasEType = true;
        result.eType_ = value;
        return this;
      }
      public Builder ClearEType() {
        PrepareBuilder();
        result.hasEType = false;
        result.eType_ = global::Protocol.EntityType.Hero;
        return this;
      }
      
      public bool HasPostion {
       get { return result.hasPostion; }
      }
      public global::Protocol.Float3 Postion {
        get { return result.Postion; }
        set { SetPostion(value); }
      }
      public Builder SetPostion(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPostion = true;
        result.postion_ = value;
        return this;
      }
      public Builder SetPostion(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPostion = true;
        result.postion_ = builderForValue.Build();
        return this;
      }
      public Builder MergePostion(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasPostion &&
            result.postion_ != global::Protocol.Float3.DefaultInstance) {
            result.postion_ = global::Protocol.Float3.CreateBuilder(result.postion_).MergeFrom(value).BuildPartial();
        } else {
          result.postion_ = value;
          result.hasPostion = true;
        }
        return this;
      }
      public Builder ClearPostion() {
        PrepareBuilder();
        result.hasPostion = false;
        result.postion_ = null;
        return this;
      }
      
      public bool HasRotation {
       get { return result.hasRotation; }
      }
      public global::Protocol.Float3 Rotation {
        get { return result.Rotation; }
        set { SetRotation(value); }
      }
      public Builder SetRotation(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRotation = true;
        result.rotation_ = value;
        return this;
      }
      public Builder SetRotation(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRotation = true;
        result.rotation_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRotation(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasRotation &&
            result.rotation_ != global::Protocol.Float3.DefaultInstance) {
            result.rotation_ = global::Protocol.Float3.CreateBuilder(result.rotation_).MergeFrom(value).BuildPartial();
        } else {
          result.rotation_ = value;
          result.hasRotation = true;
        }
        return this;
      }
      public Builder ClearRotation() {
        PrepareBuilder();
        result.hasRotation = false;
        result.rotation_ = null;
        return this;
      }
      
      public bool HasCamp {
        get { return result.hasCamp; }
      }
      [global::System.CLSCompliant(false)]
      public uint Camp {
        get { return result.Camp; }
        set { SetCamp(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetCamp(uint value) {
        PrepareBuilder();
        result.hasCamp = true;
        result.camp_ = value;
        return this;
      }
      public Builder ClearCamp() {
        PrepareBuilder();
        result.hasCamp = false;
        result.camp_ = 0;
        return this;
      }
    }
    static BornCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class HeroBornCfg : pb::GeneratedMessage<HeroBornCfg, HeroBornCfg.Builder> {
    public HeroBornCfg() { }
    private static readonly HeroBornCfg defaultInstance = new HeroBornCfg().MakeReadOnly();
    private static readonly string[] _heroBornCfgFieldNames = new string[] { "born_cfg", "cfg_id" };
    private static readonly uint[] _heroBornCfgFieldTags = new uint[] { 18, 8 };
    public static HeroBornCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroBornCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroBornCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_HeroBornCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroBornCfg, HeroBornCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_HeroBornCfg__FieldAccessorTable; }
    }
    
    public const int CfgIdFieldNumber = 1;
    private bool hasCfgId;
    private uint cfgId_;
    public bool HasCfgId {
      get { return hasCfgId; }
    }
    [global::System.CLSCompliant(false)]
    public uint CfgId {
      get { return cfgId_; }
      set { hasCfgId = true;
        cfgId_ = value;}
    }
    
    public const int BornCfgFieldNumber = 2;
    private bool hasBornCfg;
    private global::Protocol.BornCfg bornCfg_;
    public bool HasBornCfg {
      get { return hasBornCfg; }
    }
    public global::Protocol.BornCfg BornCfg {
      get { return bornCfg_; }
      set { hasBornCfg = true;
        bornCfg_ = value;}
    }
    public void MergeBornCfg(global::Protocol.BornCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasBornCfg &&
        bornCfg_ != global::Protocol.BornCfg.DefaultInstance) {
        bornCfg_.MergeFrom(value, isFull);
      } else {
        bornCfg_ = value;
      }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCfgId) return false;
        if (!hasBornCfg) return false;
        if (!BornCfg.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _heroBornCfgFieldNames;
      if (hasCfgId) {
        output.WriteUInt32(1, field_names[1], CfgId);
      }
      if (hasBornCfg) {
        output.WriteMessage(2, field_names[0], BornCfg);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasCfgId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, CfgId);
      }
      if (hasBornCfg) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, BornCfg);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public HeroBornCfg CommitChange() {
      HeroBornCfg other = new HeroBornCfg();
      bool isChange = false;
      other.CfgId = CfgId;
      
      var BornCfgcommit = BornCfg?.CommitChange();
      if(BornCfgcommit!=null)
      {
          isChange = true;
          other.BornCfg = BornCfgcommit;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(HeroBornCfg other, bool isFull = false) {
      if (other == global::Protocol.HeroBornCfg.DefaultInstance) return;
      if (other.HasCfgId) {
        CfgId = other.CfgId;
      }
      
      if (other.HasBornCfg)
      {
        MergeBornCfg(other.BornCfg, isFull);
      }
    }
    
    public static HeroBornCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroBornCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroBornCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroBornCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroBornCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroBornCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroBornCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroBornCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroBornCfg result;
      
      private HeroBornCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroBornCfg original = result;
          result = new HeroBornCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroBornCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.HeroBornCfg.Descriptor; }
      }
      
      public override HeroBornCfg DefaultInstanceForType {
        get { return global::Protocol.HeroBornCfg.DefaultInstance; }
      }
      
      public override HeroBornCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroBornCfg) {
          return MergeFrom((HeroBornCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroBornCfg other) {
        if (other == global::Protocol.HeroBornCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCfgId) {
          CfgId = other.CfgId;
        }
        if (other.HasBornCfg) {
          MergeBornCfg(other.BornCfg);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroBornCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroBornCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCfgId = input.ReadUInt32(ref result.cfgId_);
              break;
            }
            case 18: {
              global::Protocol.BornCfg.Builder subBuilder = global::Protocol.BornCfg.CreateBuilder();
              if (result.hasBornCfg) {
                subBuilder.MergeFrom(BornCfg);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BornCfg = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCfgId {
        get { return result.hasCfgId; }
      }
      [global::System.CLSCompliant(false)]
      public uint CfgId {
        get { return result.CfgId; }
        set { SetCfgId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetCfgId(uint value) {
        PrepareBuilder();
        result.hasCfgId = true;
        result.cfgId_ = value;
        return this;
      }
      public Builder ClearCfgId() {
        PrepareBuilder();
        result.hasCfgId = false;
        result.cfgId_ = 0;
        return this;
      }
      
      public bool HasBornCfg {
       get { return result.hasBornCfg; }
      }
      public global::Protocol.BornCfg BornCfg {
        get { return result.BornCfg; }
        set { SetBornCfg(value); }
      }
      public Builder SetBornCfg(global::Protocol.BornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBornCfg = true;
        result.bornCfg_ = value;
        return this;
      }
      public Builder SetBornCfg(global::Protocol.BornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBornCfg = true;
        result.bornCfg_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBornCfg(global::Protocol.BornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasBornCfg &&
            result.bornCfg_ != global::Protocol.BornCfg.DefaultInstance) {
            result.bornCfg_ = global::Protocol.BornCfg.CreateBuilder(result.bornCfg_).MergeFrom(value).BuildPartial();
        } else {
          result.bornCfg_ = value;
          result.hasBornCfg = true;
        }
        return this;
      }
      public Builder ClearBornCfg() {
        PrepareBuilder();
        result.hasBornCfg = false;
        result.bornCfg_ = null;
        return this;
      }
    }
    static HeroBornCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MonsterBornCfg : pb::GeneratedMessage<MonsterBornCfg, MonsterBornCfg.Builder> {
    public MonsterBornCfg() { }
    private static readonly MonsterBornCfg defaultInstance = new MonsterBornCfg().MakeReadOnly();
    private static readonly string[] _monsterBornCfgFieldNames = new string[] { "born_cfg", "cfg_id" };
    private static readonly uint[] _monsterBornCfgFieldTags = new uint[] { 18, 8 };
    public static MonsterBornCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MonsterBornCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MonsterBornCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MonsterBornCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MonsterBornCfg, MonsterBornCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MonsterBornCfg__FieldAccessorTable; }
    }
    
    public const int CfgIdFieldNumber = 1;
    private bool hasCfgId;
    private uint cfgId_;
    public bool HasCfgId {
      get { return hasCfgId; }
    }
    [global::System.CLSCompliant(false)]
    public uint CfgId {
      get { return cfgId_; }
      set { hasCfgId = true;
        cfgId_ = value;}
    }
    
    public const int BornCfgFieldNumber = 2;
    private bool hasBornCfg;
    private global::Protocol.BornCfg bornCfg_;
    public bool HasBornCfg {
      get { return hasBornCfg; }
    }
    public global::Protocol.BornCfg BornCfg {
      get { return bornCfg_; }
      set { hasBornCfg = true;
        bornCfg_ = value;}
    }
    public void MergeBornCfg(global::Protocol.BornCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasBornCfg &&
        bornCfg_ != global::Protocol.BornCfg.DefaultInstance) {
        bornCfg_.MergeFrom(value, isFull);
      } else {
        bornCfg_ = value;
      }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasCfgId) return false;
        if (!hasBornCfg) return false;
        if (!BornCfg.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _monsterBornCfgFieldNames;
      if (hasCfgId) {
        output.WriteUInt32(1, field_names[1], CfgId);
      }
      if (hasBornCfg) {
        output.WriteMessage(2, field_names[0], BornCfg);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasCfgId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, CfgId);
      }
      if (hasBornCfg) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, BornCfg);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public MonsterBornCfg CommitChange() {
      MonsterBornCfg other = new MonsterBornCfg();
      bool isChange = false;
      other.CfgId = CfgId;
      
      var BornCfgcommit = BornCfg?.CommitChange();
      if(BornCfgcommit!=null)
      {
          isChange = true;
          other.BornCfg = BornCfgcommit;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(MonsterBornCfg other, bool isFull = false) {
      if (other == global::Protocol.MonsterBornCfg.DefaultInstance) return;
      if (other.HasCfgId) {
        CfgId = other.CfgId;
      }
      
      if (other.HasBornCfg)
      {
        MergeBornCfg(other.BornCfg, isFull);
      }
    }
    
    public static MonsterBornCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MonsterBornCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MonsterBornCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MonsterBornCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MonsterBornCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MonsterBornCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MonsterBornCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MonsterBornCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MonsterBornCfg result;
      
      private MonsterBornCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          MonsterBornCfg original = result;
          result = new MonsterBornCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MonsterBornCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.MonsterBornCfg.Descriptor; }
      }
      
      public override MonsterBornCfg DefaultInstanceForType {
        get { return global::Protocol.MonsterBornCfg.DefaultInstance; }
      }
      
      public override MonsterBornCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MonsterBornCfg) {
          return MergeFrom((MonsterBornCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MonsterBornCfg other) {
        if (other == global::Protocol.MonsterBornCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCfgId) {
          CfgId = other.CfgId;
        }
        if (other.HasBornCfg) {
          MergeBornCfg(other.BornCfg);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_monsterBornCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _monsterBornCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasCfgId = input.ReadUInt32(ref result.cfgId_);
              break;
            }
            case 18: {
              global::Protocol.BornCfg.Builder subBuilder = global::Protocol.BornCfg.CreateBuilder();
              if (result.hasBornCfg) {
                subBuilder.MergeFrom(BornCfg);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BornCfg = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCfgId {
        get { return result.hasCfgId; }
      }
      [global::System.CLSCompliant(false)]
      public uint CfgId {
        get { return result.CfgId; }
        set { SetCfgId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetCfgId(uint value) {
        PrepareBuilder();
        result.hasCfgId = true;
        result.cfgId_ = value;
        return this;
      }
      public Builder ClearCfgId() {
        PrepareBuilder();
        result.hasCfgId = false;
        result.cfgId_ = 0;
        return this;
      }
      
      public bool HasBornCfg {
       get { return result.hasBornCfg; }
      }
      public global::Protocol.BornCfg BornCfg {
        get { return result.BornCfg; }
        set { SetBornCfg(value); }
      }
      public Builder SetBornCfg(global::Protocol.BornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBornCfg = true;
        result.bornCfg_ = value;
        return this;
      }
      public Builder SetBornCfg(global::Protocol.BornCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBornCfg = true;
        result.bornCfg_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBornCfg(global::Protocol.BornCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasBornCfg &&
            result.bornCfg_ != global::Protocol.BornCfg.DefaultInstance) {
            result.bornCfg_ = global::Protocol.BornCfg.CreateBuilder(result.bornCfg_).MergeFrom(value).BuildPartial();
        } else {
          result.bornCfg_ = value;
          result.hasBornCfg = true;
        }
        return this;
      }
      public Builder ClearBornCfg() {
        PrepareBuilder();
        result.hasBornCfg = false;
        result.bornCfg_ = null;
        return this;
      }
    }
    static MonsterBornCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayMapCfg : pb::GeneratedMessage<WayMapCfg, WayMapCfg.Builder> {
    public WayMapCfg() { }
    private static readonly WayMapCfg defaultInstance = new WayMapCfg().MakeReadOnly();
    private static readonly string[] _wayMapCfgFieldNames = new string[] { "lines", "points" };
    private static readonly uint[] _wayMapCfgFieldTags = new uint[] { 18, 10 };
    public static WayMapCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayMapCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayMapCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayMapCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayMapCfg, WayMapCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayMapCfg__FieldAccessorTable; }
    }
    
    public const int PointsFieldNumber = 1;
    private pbc::PopsicleList<global::Protocol.WayPointCfg> points_ = new pbc::PopsicleList<global::Protocol.WayPointCfg>();
    public scg::IList<global::Protocol.WayPointCfg> Points {
      get { return pbc::Lists.AsReadOnly(points_); }
    }
    public int PointsCount {
      get { return points_.Count; }
    }
    public global::Protocol.WayPointCfg GetPoints(int index) {
      return points_[index];
    }
    public global::Protocol.WayPointCfg FindPoints(System.Predicate<global::Protocol.WayPointCfg> match) {
      return points_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.WayPointCfg> FindAllPoints(System.Predicate<global::Protocol.WayPointCfg> match) {
      return points_.FindAll(match);
    }
    public void SetPoints(int index, global::Protocol.WayPointCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= points_.Count) return;
      points_[index] = value;
    }
    public void AddPoints(global::Protocol.WayPointCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      points_.Add(value);
    }
    public void AddRangePoints(scg::IEnumerable<global::Protocol.WayPointCfg> values) {
      points_.Add(values);
    }
    public void RemovePoints(global::Protocol.WayPointCfg value) {
      if (!points_.Contains(value)) return;
      points_.Remove(value);
    }
    public void RemoveAtPoints(int index) {
      if (index < 0 || index >= points_.Count) return;
      points_.RemoveAt(index);
    }
    public void ClearPoints() {
      if (points_.Count <= 0) return;
      points_.Clear();
    }
    
    public const int LinesFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.WayLineCfg> lines_ = new pbc::PopsicleList<global::Protocol.WayLineCfg>();
    public scg::IList<global::Protocol.WayLineCfg> Lines {
      get { return pbc::Lists.AsReadOnly(lines_); }
    }
    public int LinesCount {
      get { return lines_.Count; }
    }
    public global::Protocol.WayLineCfg GetLines(int index) {
      return lines_[index];
    }
    public global::Protocol.WayLineCfg FindLines(System.Predicate<global::Protocol.WayLineCfg> match) {
      return lines_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.WayLineCfg> FindAllLines(System.Predicate<global::Protocol.WayLineCfg> match) {
      return lines_.FindAll(match);
    }
    public void SetLines(int index, global::Protocol.WayLineCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= lines_.Count) return;
      lines_[index] = value;
    }
    public void AddLines(global::Protocol.WayLineCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      lines_.Add(value);
    }
    public void AddRangeLines(scg::IEnumerable<global::Protocol.WayLineCfg> values) {
      lines_.Add(values);
    }
    public void RemoveLines(global::Protocol.WayLineCfg value) {
      if (!lines_.Contains(value)) return;
      lines_.Remove(value);
    }
    public void RemoveAtLines(int index) {
      if (index < 0 || index >= lines_.Count) return;
      lines_.RemoveAt(index);
    }
    public void ClearLines() {
      if (lines_.Count <= 0) return;
      lines_.Clear();
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Protocol.WayPointCfg element in Points) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Protocol.WayLineCfg element in Lines) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayMapCfgFieldNames;
      if (points_.Count > 0) {
        output.WriteMessageArray(1, field_names[1], points_);
      }
      if (lines_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], lines_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      foreach (global::Protocol.WayPointCfg element in Points) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      foreach (global::Protocol.WayLineCfg element in Lines) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayMapCfg CommitChange() {
      WayMapCfg other = new WayMapCfg();
      bool isChange = false;
      isChange = true;
      other.points_.Add(points_);
      isChange = true;
      other.lines_.Add(lines_);
      return isChange?other:null;
    }
    
    public void MergeFrom(WayMapCfg other, bool isFull = false) {
      if (other == global::Protocol.WayMapCfg.DefaultInstance) return;
        points_.Clear();
        points_.Add(other.points_);
        lines_.Clear();
        lines_.Add(other.lines_);
    }
    
    public static WayMapCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayMapCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayMapCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayMapCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayMapCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayMapCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayMapCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayMapCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayMapCfg result;
      
      private WayMapCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayMapCfg original = result;
          result = new WayMapCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayMapCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayMapCfg.Descriptor; }
      }
      
      public override WayMapCfg DefaultInstanceForType {
        get { return global::Protocol.WayMapCfg.DefaultInstance; }
      }
      
      public override WayMapCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayMapCfg) {
          return MergeFrom((WayMapCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayMapCfg other) {
        if (other == global::Protocol.WayMapCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.points_.Count != 0) {
          result.points_.Add(other.points_);
        }
        if (other.lines_.Count != 0) {
          result.lines_.Add(other.lines_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayMapCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayMapCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.points_, global::Protocol.WayPointCfg.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.lines_, global::Protocol.WayLineCfg.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Protocol.WayPointCfg> Points {
        get { return PrepareBuilder().points_; }
      }
      public int PointsCount {
        get { return result.PointsCount; }
      }
      public global::Protocol.WayPointCfg GetPoints(int index) {
        return result.GetPoints(index);
      }
      public Builder SetPoints(int index, global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.points_[index] = value;
        return this;
      }
      public Builder SetPoints(int index, global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.points_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPoints(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.points_.Add(value);
        return this;
      }
      public Builder AddPoints(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.points_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePoints(scg::IEnumerable<global::Protocol.WayPointCfg> values) {
        PrepareBuilder();
        result.points_.Add(values);
        return this;
      }
      public Builder ClearPoints() {
        PrepareBuilder();
        result.points_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.WayLineCfg> Lines {
        get { return PrepareBuilder().lines_; }
      }
      public int LinesCount {
        get { return result.LinesCount; }
      }
      public global::Protocol.WayLineCfg GetLines(int index) {
        return result.GetLines(index);
      }
      public Builder SetLines(int index, global::Protocol.WayLineCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lines_[index] = value;
        return this;
      }
      public Builder SetLines(int index, global::Protocol.WayLineCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lines_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddLines(global::Protocol.WayLineCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.lines_.Add(value);
        return this;
      }
      public Builder AddLines(global::Protocol.WayLineCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.lines_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeLines(scg::IEnumerable<global::Protocol.WayLineCfg> values) {
        PrepareBuilder();
        result.lines_.Add(values);
        return this;
      }
      public Builder ClearLines() {
        PrepareBuilder();
        result.lines_.Clear();
        return this;
      }
    }
    static WayMapCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayPointCfg : pb::GeneratedMessage<WayPointCfg, WayPointCfg.Builder> {
    public WayPointCfg() { }
    private static readonly WayPointCfg defaultInstance = new WayPointCfg().MakeReadOnly();
    private static readonly string[] _wayPointCfgFieldNames = new string[] { "forward", "id", "line_count", "mapId", "maxStandTime", "minStandTime", "need_offset", "offset_value", "pass_line_time", "position", "type" };
    private static readonly uint[] _wayPointCfgFieldTags = new uint[] { 34, 8, 64, 16, 53, 45, 80, 93, 77, 26, 56 };
    public static WayPointCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayPointCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayPointCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayPointCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayPointCfg, WayPointCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayPointCfg__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private uint id_;
    public bool HasId {
      get { return hasId; }
    }
    [global::System.CLSCompliant(false)]
    public uint Id {
      get { return id_; }
      set { hasId = true;
        id_ = value;}
    }
    
    public const int MapIdFieldNumber = 2;
    private bool hasMapId;
    private uint mapId_;
    public bool HasMapId {
      get { return hasMapId; }
    }
    [global::System.CLSCompliant(false)]
    public uint MapId {
      get { return mapId_; }
      set { hasMapId = true;
        mapId_ = value;}
    }
    
    public const int PositionFieldNumber = 3;
    private bool hasPosition;
    private global::Protocol.Float3 position_;
    public bool HasPosition {
      get { return hasPosition; }
    }
    public global::Protocol.Float3 Position {
      get { return position_; }
      set { hasPosition = true;
        position_ = value;}
    }
    public void MergePosition(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasPosition &&
        position_ != global::Protocol.Float3.DefaultInstance) {
        position_.MergeFrom(value, isFull);
      } else {
        position_ = value;
      }
    }
    
    public const int ForwardFieldNumber = 4;
    private bool hasForward;
    private global::Protocol.Float3 forward_;
    public bool HasForward {
      get { return hasForward; }
    }
    public global::Protocol.Float3 Forward {
      get { return forward_; }
      set { hasForward = true;
        forward_ = value;}
    }
    public void MergeForward(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasForward &&
        forward_ != global::Protocol.Float3.DefaultInstance) {
        forward_.MergeFrom(value, isFull);
      } else {
        forward_ = value;
      }
    }
    
    public const int MinStandTimeFieldNumber = 5;
    private bool hasMinStandTime;
    private bool isMinStandTimeChanged = true;
    private float minStandTime_;
    public bool HasMinStandTime {
      get { return hasMinStandTime; }
    }
    public float MinStandTime {
      get { return minStandTime_; }
      set { hasMinStandTime = true;
        isMinStandTimeChanged = true;
        minStandTime_ = value;}
    }
    
    public const int MaxStandTimeFieldNumber = 6;
    private bool hasMaxStandTime;
    private bool isMaxStandTimeChanged = true;
    private float maxStandTime_;
    public bool HasMaxStandTime {
      get { return hasMaxStandTime; }
    }
    public float MaxStandTime {
      get { return maxStandTime_; }
      set { hasMaxStandTime = true;
        isMaxStandTimeChanged = true;
        maxStandTime_ = value;}
    }
    
    public const int TypeFieldNumber = 7;
    private bool hasType;
    private bool isTypeChanged = true;
    private uint type_;
    public bool HasType {
      get { return hasType; }
    }
    [global::System.CLSCompliant(false)]
    public uint Type {
      get { return type_; }
      set { hasType = true;
        isTypeChanged = true;
        type_ = value;}
    }
    
    public const int LineCountFieldNumber = 8;
    private bool hasLineCount;
    private bool isLineCountChanged = true;
    private uint lineCount_;
    public bool HasLineCount {
      get { return hasLineCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint LineCount {
      get { return lineCount_; }
      set { hasLineCount = true;
        isLineCountChanged = true;
        lineCount_ = value;}
    }
    
    public const int PassLineTimeFieldNumber = 9;
    private bool hasPassLineTime;
    private bool isPassLineTimeChanged = true;
    private float passLineTime_;
    public bool HasPassLineTime {
      get { return hasPassLineTime; }
    }
    public float PassLineTime {
      get { return passLineTime_; }
      set { hasPassLineTime = true;
        isPassLineTimeChanged = true;
        passLineTime_ = value;}
    }
    
    public const int NeedOffsetFieldNumber = 10;
    private bool hasNeedOffset;
    private bool isNeedOffsetChanged = true;
    private bool needOffset_;
    public bool HasNeedOffset {
      get { return hasNeedOffset; }
    }
    public bool NeedOffset {
      get { return needOffset_; }
      set { hasNeedOffset = true;
        isNeedOffsetChanged = true;
        needOffset_ = value;}
    }
    
    public const int OffsetValueFieldNumber = 11;
    private bool hasOffsetValue;
    private bool isOffsetValueChanged = true;
    private float offsetValue_;
    public bool HasOffsetValue {
      get { return hasOffsetValue; }
    }
    public float OffsetValue {
      get { return offsetValue_; }
      set { hasOffsetValue = true;
        isOffsetValueChanged = true;
        offsetValue_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (!hasMapId) return false;
        if (!hasPosition) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayPointCfgFieldNames;
      if (hasId) {
        output.WriteUInt32(1, field_names[1], Id);
      }
      if (hasMapId) {
        output.WriteUInt32(2, field_names[3], MapId);
      }
      if (hasPosition) {
        output.WriteMessage(3, field_names[9], Position);
      }
      if (hasForward) {
        output.WriteMessage(4, field_names[0], Forward);
      }
      if (hasMinStandTime) {
        output.WriteFloat(5, field_names[5], MinStandTime);
      }
      if (hasMaxStandTime) {
        output.WriteFloat(6, field_names[4], MaxStandTime);
      }
      if (hasType) {
        output.WriteUInt32(7, field_names[10], Type);
      }
      if (hasLineCount) {
        output.WriteUInt32(8, field_names[2], LineCount);
      }
      if (hasPassLineTime) {
        output.WriteFloat(9, field_names[8], PassLineTime);
      }
      if (hasNeedOffset) {
        output.WriteBool(10, field_names[6], NeedOffset);
      }
      if (hasOffsetValue) {
        output.WriteFloat(11, field_names[7], OffsetValue);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
      }
      if (hasMapId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, MapId);
      }
      if (hasPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Position);
      }
      if (hasForward) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, Forward);
      }
      if (hasMinStandTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(5, MinStandTime);
      }
      if (hasMaxStandTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(6, MaxStandTime);
      }
      if (hasType) {
        size += pb::CodedOutputStream.ComputeUInt32Size(7, Type);
      }
      if (hasLineCount) {
        size += pb::CodedOutputStream.ComputeUInt32Size(8, LineCount);
      }
      if (hasPassLineTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(9, PassLineTime);
      }
      if (hasNeedOffset) {
        size += pb::CodedOutputStream.ComputeBoolSize(10, NeedOffset);
      }
      if (hasOffsetValue) {
        size += pb::CodedOutputStream.ComputeFloatSize(11, OffsetValue);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayPointCfg CommitChange() {
      WayPointCfg other = new WayPointCfg();
      bool isChange = false;
      other.Id = Id;
      other.MapId = MapId;
      
      var Positioncommit = Position?.CommitChange();
      if(Positioncommit!=null)
      {
          isChange = true;
          other.Position = Positioncommit;
      }
      
      var Forwardcommit = Forward?.CommitChange();
      if(Forwardcommit!=null)
      {
          isChange = true;
          other.Forward = Forwardcommit;
      }
      if (isMinStandTimeChanged) {
        isChange = true;
        other.MinStandTime = MinStandTime;
        isMinStandTimeChanged = false;
      }
      if (isMaxStandTimeChanged) {
        isChange = true;
        other.MaxStandTime = MaxStandTime;
        isMaxStandTimeChanged = false;
      }
      if (isTypeChanged) {
        isChange = true;
        other.Type = Type;
        isTypeChanged = false;
      }
      if (isLineCountChanged) {
        isChange = true;
        other.LineCount = LineCount;
        isLineCountChanged = false;
      }
      if (isPassLineTimeChanged) {
        isChange = true;
        other.PassLineTime = PassLineTime;
        isPassLineTimeChanged = false;
      }
      if (isNeedOffsetChanged) {
        isChange = true;
        other.NeedOffset = NeedOffset;
        isNeedOffsetChanged = false;
      }
      if (isOffsetValueChanged) {
        isChange = true;
        other.OffsetValue = OffsetValue;
        isOffsetValueChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(WayPointCfg other, bool isFull = false) {
      if (other == global::Protocol.WayPointCfg.DefaultInstance) return;
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasMapId) {
        MapId = other.MapId;
      }
      
      if (other.HasPosition)
      {
        MergePosition(other.Position, isFull);
      }
      
      if (other.HasForward)
      {
        MergeForward(other.Forward, isFull);
      }
      if (other.HasMinStandTime) {
        MinStandTime = other.MinStandTime;
      }
      if (other.HasMaxStandTime) {
        MaxStandTime = other.MaxStandTime;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLineCount) {
        LineCount = other.LineCount;
      }
      if (other.HasPassLineTime) {
        PassLineTime = other.PassLineTime;
      }
      if (other.HasNeedOffset) {
        NeedOffset = other.NeedOffset;
      }
      if (other.HasOffsetValue) {
        OffsetValue = other.OffsetValue;
      }
    }
    
    public static WayPointCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayPointCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayPointCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayPointCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayPointCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayPointCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayPointCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayPointCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayPointCfg result;
      
      private WayPointCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayPointCfg original = result;
          result = new WayPointCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayPointCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayPointCfg.Descriptor; }
      }
      
      public override WayPointCfg DefaultInstanceForType {
        get { return global::Protocol.WayPointCfg.DefaultInstance; }
      }
      
      public override WayPointCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayPointCfg) {
          return MergeFrom((WayPointCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayPointCfg other) {
        if (other == global::Protocol.WayPointCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasMapId) {
          MapId = other.MapId;
        }
        if (other.HasPosition) {
          MergePosition(other.Position);
        }
        if (other.HasForward) {
          MergeForward(other.Forward);
        }
        if (other.HasMinStandTime) {
          MinStandTime = other.MinStandTime;
        }
        if (other.HasMaxStandTime) {
          MaxStandTime = other.MaxStandTime;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasLineCount) {
          LineCount = other.LineCount;
        }
        if (other.HasPassLineTime) {
          PassLineTime = other.PassLineTime;
        }
        if (other.HasNeedOffset) {
          NeedOffset = other.NeedOffset;
        }
        if (other.HasOffsetValue) {
          OffsetValue = other.OffsetValue;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayPointCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayPointCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadUInt32(ref result.id_);
              break;
            }
            case 16: {
              result.hasMapId = input.ReadUInt32(ref result.mapId_);
              break;
            }
            case 26: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasPosition) {
                subBuilder.MergeFrom(Position);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Position = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasForward) {
                subBuilder.MergeFrom(Forward);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Forward = subBuilder.BuildPartial();
              break;
            }
            case 45: {
              result.hasMinStandTime = input.ReadFloat(ref result.minStandTime_);
              break;
            }
            case 53: {
              result.hasMaxStandTime = input.ReadFloat(ref result.maxStandTime_);
              break;
            }
            case 56: {
              result.hasType = input.ReadUInt32(ref result.type_);
              break;
            }
            case 64: {
              result.hasLineCount = input.ReadUInt32(ref result.lineCount_);
              break;
            }
            case 77: {
              result.hasPassLineTime = input.ReadFloat(ref result.passLineTime_);
              break;
            }
            case 80: {
              result.hasNeedOffset = input.ReadBool(ref result.needOffset_);
              break;
            }
            case 93: {
              result.hasOffsetValue = input.ReadFloat(ref result.offsetValue_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetId(uint value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasMapId {
        get { return result.hasMapId; }
      }
      [global::System.CLSCompliant(false)]
      public uint MapId {
        get { return result.MapId; }
        set { SetMapId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetMapId(uint value) {
        PrepareBuilder();
        result.hasMapId = true;
        result.mapId_ = value;
        return this;
      }
      public Builder ClearMapId() {
        PrepareBuilder();
        result.hasMapId = false;
        result.mapId_ = 0;
        return this;
      }
      
      public bool HasPosition {
       get { return result.hasPosition; }
      }
      public global::Protocol.Float3 Position {
        get { return result.Position; }
        set { SetPosition(value); }
      }
      public Builder SetPosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = value;
        return this;
      }
      public Builder SetPosition(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = builderForValue.Build();
        return this;
      }
      public Builder MergePosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasPosition &&
            result.position_ != global::Protocol.Float3.DefaultInstance) {
            result.position_ = global::Protocol.Float3.CreateBuilder(result.position_).MergeFrom(value).BuildPartial();
        } else {
          result.position_ = value;
          result.hasPosition = true;
        }
        return this;
      }
      public Builder ClearPosition() {
        PrepareBuilder();
        result.hasPosition = false;
        result.position_ = null;
        return this;
      }
      
      public bool HasForward {
       get { return result.hasForward; }
      }
      public global::Protocol.Float3 Forward {
        get { return result.Forward; }
        set { SetForward(value); }
      }
      public Builder SetForward(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasForward = true;
        result.forward_ = value;
        return this;
      }
      public Builder SetForward(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasForward = true;
        result.forward_ = builderForValue.Build();
        return this;
      }
      public Builder MergeForward(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasForward &&
            result.forward_ != global::Protocol.Float3.DefaultInstance) {
            result.forward_ = global::Protocol.Float3.CreateBuilder(result.forward_).MergeFrom(value).BuildPartial();
        } else {
          result.forward_ = value;
          result.hasForward = true;
        }
        return this;
      }
      public Builder ClearForward() {
        PrepareBuilder();
        result.hasForward = false;
        result.forward_ = null;
        return this;
      }
      
      public bool HasMinStandTime {
        get { return result.hasMinStandTime; }
      }
      public float MinStandTime {
        get { return result.MinStandTime; }
        set { SetMinStandTime(value); }
      }
      public Builder SetMinStandTime(float value) {
        PrepareBuilder();
        result.hasMinStandTime = true;
        result.minStandTime_ = value;
        return this;
      }
      public Builder ClearMinStandTime() {
        PrepareBuilder();
        result.hasMinStandTime = false;
        result.minStandTime_ = 0F;
        return this;
      }
      
      public bool HasMaxStandTime {
        get { return result.hasMaxStandTime; }
      }
      public float MaxStandTime {
        get { return result.MaxStandTime; }
        set { SetMaxStandTime(value); }
      }
      public Builder SetMaxStandTime(float value) {
        PrepareBuilder();
        result.hasMaxStandTime = true;
        result.maxStandTime_ = value;
        return this;
      }
      public Builder ClearMaxStandTime() {
        PrepareBuilder();
        result.hasMaxStandTime = false;
        result.maxStandTime_ = 0F;
        return this;
      }
      
      public bool HasType {
        get { return result.hasType; }
      }
      [global::System.CLSCompliant(false)]
      public uint Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetType(uint value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = 0;
        return this;
      }
      
      public bool HasLineCount {
        get { return result.hasLineCount; }
      }
      [global::System.CLSCompliant(false)]
      public uint LineCount {
        get { return result.LineCount; }
        set { SetLineCount(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLineCount(uint value) {
        PrepareBuilder();
        result.hasLineCount = true;
        result.lineCount_ = value;
        return this;
      }
      public Builder ClearLineCount() {
        PrepareBuilder();
        result.hasLineCount = false;
        result.lineCount_ = 0;
        return this;
      }
      
      public bool HasPassLineTime {
        get { return result.hasPassLineTime; }
      }
      public float PassLineTime {
        get { return result.PassLineTime; }
        set { SetPassLineTime(value); }
      }
      public Builder SetPassLineTime(float value) {
        PrepareBuilder();
        result.hasPassLineTime = true;
        result.passLineTime_ = value;
        return this;
      }
      public Builder ClearPassLineTime() {
        PrepareBuilder();
        result.hasPassLineTime = false;
        result.passLineTime_ = 0F;
        return this;
      }
      
      public bool HasNeedOffset {
        get { return result.hasNeedOffset; }
      }
      public bool NeedOffset {
        get { return result.NeedOffset; }
        set { SetNeedOffset(value); }
      }
      public Builder SetNeedOffset(bool value) {
        PrepareBuilder();
        result.hasNeedOffset = true;
        result.needOffset_ = value;
        return this;
      }
      public Builder ClearNeedOffset() {
        PrepareBuilder();
        result.hasNeedOffset = false;
        result.needOffset_ = false;
        return this;
      }
      
      public bool HasOffsetValue {
        get { return result.hasOffsetValue; }
      }
      public float OffsetValue {
        get { return result.OffsetValue; }
        set { SetOffsetValue(value); }
      }
      public Builder SetOffsetValue(float value) {
        PrepareBuilder();
        result.hasOffsetValue = true;
        result.offsetValue_ = value;
        return this;
      }
      public Builder ClearOffsetValue() {
        PrepareBuilder();
        result.hasOffsetValue = false;
        result.offsetValue_ = 0F;
        return this;
      }
    }
    static WayPointCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WayLineCfg : pb::GeneratedMessage<WayLineCfg, WayLineCfg.Builder> {
    public WayLineCfg() { }
    private static readonly WayLineCfg defaultInstance = new WayLineCfg().MakeReadOnly();
    private static readonly string[] _wayLineCfgFieldNames = new string[] { "cost", "head", "is_one_way", "last" };
    private static readonly uint[] _wayLineCfgFieldTags = new uint[] { 29, 10, 32, 18 };
    public static WayLineCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override WayLineCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override WayLineCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayLineCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<WayLineCfg, WayLineCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_WayLineCfg__FieldAccessorTable; }
    }
    
    public const int HeadFieldNumber = 1;
    private bool hasHead;
    private global::Protocol.WayPointCfg head_;
    public bool HasHead {
      get { return hasHead; }
    }
    public global::Protocol.WayPointCfg Head {
      get { return head_; }
      set { hasHead = true;
        head_ = value;}
    }
    public void MergeHead(global::Protocol.WayPointCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasHead &&
        head_ != global::Protocol.WayPointCfg.DefaultInstance) {
        head_.MergeFrom(value, isFull);
      } else {
        head_ = value;
      }
    }
    
    public const int LastFieldNumber = 2;
    private bool hasLast;
    private global::Protocol.WayPointCfg last_;
    public bool HasLast {
      get { return hasLast; }
    }
    public global::Protocol.WayPointCfg Last {
      get { return last_; }
      set { hasLast = true;
        last_ = value;}
    }
    public void MergeLast(global::Protocol.WayPointCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasLast &&
        last_ != global::Protocol.WayPointCfg.DefaultInstance) {
        last_.MergeFrom(value, isFull);
      } else {
        last_ = value;
      }
    }
    
    public const int CostFieldNumber = 3;
    private bool hasCost;
    private float cost_;
    public bool HasCost {
      get { return hasCost; }
    }
    public float Cost {
      get { return cost_; }
      set { hasCost = true;
        cost_ = value;}
    }
    
    public const int IsOneWayFieldNumber = 4;
    private bool hasIsOneWay;
    private bool isOneWay_;
    public bool HasIsOneWay {
      get { return hasIsOneWay; }
    }
    public bool IsOneWay {
      get { return isOneWay_; }
      set { hasIsOneWay = true;
        isOneWay_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasHead) return false;
        if (!hasLast) return false;
        if (!hasCost) return false;
        if (!hasIsOneWay) return false;
        if (!Head.IsInitialized) return false;
        if (!Last.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wayLineCfgFieldNames;
      if (hasHead) {
        output.WriteMessage(1, field_names[1], Head);
      }
      if (hasLast) {
        output.WriteMessage(2, field_names[3], Last);
      }
      if (hasCost) {
        output.WriteFloat(3, field_names[0], Cost);
      }
      if (hasIsOneWay) {
        output.WriteBool(4, field_names[2], IsOneWay);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasHead) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Head);
      }
      if (hasLast) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Last);
      }
      if (hasCost) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Cost);
      }
      if (hasIsOneWay) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, IsOneWay);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public WayLineCfg CommitChange() {
      WayLineCfg other = new WayLineCfg();
      bool isChange = false;
      
      var Headcommit = Head?.CommitChange();
      if(Headcommit!=null)
      {
          isChange = true;
          other.Head = Headcommit;
      }
      
      var Lastcommit = Last?.CommitChange();
      if(Lastcommit!=null)
      {
          isChange = true;
          other.Last = Lastcommit;
      }
      other.Cost = Cost;
      other.IsOneWay = IsOneWay;
      return isChange?other:null;
    }
    
    public void MergeFrom(WayLineCfg other, bool isFull = false) {
      if (other == global::Protocol.WayLineCfg.DefaultInstance) return;
      
      if (other.HasHead)
      {
        MergeHead(other.Head, isFull);
      }
      
      if (other.HasLast)
      {
        MergeLast(other.Last, isFull);
      }
      if (other.HasCost) {
        Cost = other.Cost;
      }
      if (other.HasIsOneWay) {
        IsOneWay = other.IsOneWay;
      }
    }
    
    public static WayLineCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static WayLineCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static WayLineCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static WayLineCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private WayLineCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(WayLineCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<WayLineCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(WayLineCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private WayLineCfg result;
      
      private WayLineCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          WayLineCfg original = result;
          result = new WayLineCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override WayLineCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.WayLineCfg.Descriptor; }
      }
      
      public override WayLineCfg DefaultInstanceForType {
        get { return global::Protocol.WayLineCfg.DefaultInstance; }
      }
      
      public override WayLineCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is WayLineCfg) {
          return MergeFrom((WayLineCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(WayLineCfg other) {
        if (other == global::Protocol.WayLineCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHead) {
          MergeHead(other.Head);
        }
        if (other.HasLast) {
          MergeLast(other.Last);
        }
        if (other.HasCost) {
          Cost = other.Cost;
        }
        if (other.HasIsOneWay) {
          IsOneWay = other.IsOneWay;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wayLineCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wayLineCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::Protocol.WayPointCfg.Builder subBuilder = global::Protocol.WayPointCfg.CreateBuilder();
              if (result.hasHead) {
                subBuilder.MergeFrom(Head);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Head = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::Protocol.WayPointCfg.Builder subBuilder = global::Protocol.WayPointCfg.CreateBuilder();
              if (result.hasLast) {
                subBuilder.MergeFrom(Last);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Last = subBuilder.BuildPartial();
              break;
            }
            case 29: {
              result.hasCost = input.ReadFloat(ref result.cost_);
              break;
            }
            case 32: {
              result.hasIsOneWay = input.ReadBool(ref result.isOneWay_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHead {
       get { return result.hasHead; }
      }
      public global::Protocol.WayPointCfg Head {
        get { return result.Head; }
        set { SetHead(value); }
      }
      public Builder SetHead(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHead = true;
        result.head_ = value;
        return this;
      }
      public Builder SetHead(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHead = true;
        result.head_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHead(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasHead &&
            result.head_ != global::Protocol.WayPointCfg.DefaultInstance) {
            result.head_ = global::Protocol.WayPointCfg.CreateBuilder(result.head_).MergeFrom(value).BuildPartial();
        } else {
          result.head_ = value;
          result.hasHead = true;
        }
        return this;
      }
      public Builder ClearHead() {
        PrepareBuilder();
        result.hasHead = false;
        result.head_ = null;
        return this;
      }
      
      public bool HasLast {
       get { return result.hasLast; }
      }
      public global::Protocol.WayPointCfg Last {
        get { return result.Last; }
        set { SetLast(value); }
      }
      public Builder SetLast(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasLast = true;
        result.last_ = value;
        return this;
      }
      public Builder SetLast(global::Protocol.WayPointCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasLast = true;
        result.last_ = builderForValue.Build();
        return this;
      }
      public Builder MergeLast(global::Protocol.WayPointCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasLast &&
            result.last_ != global::Protocol.WayPointCfg.DefaultInstance) {
            result.last_ = global::Protocol.WayPointCfg.CreateBuilder(result.last_).MergeFrom(value).BuildPartial();
        } else {
          result.last_ = value;
          result.hasLast = true;
        }
        return this;
      }
      public Builder ClearLast() {
        PrepareBuilder();
        result.hasLast = false;
        result.last_ = null;
        return this;
      }
      
      public bool HasCost {
        get { return result.hasCost; }
      }
      public float Cost {
        get { return result.Cost; }
        set { SetCost(value); }
      }
      public Builder SetCost(float value) {
        PrepareBuilder();
        result.hasCost = true;
        result.cost_ = value;
        return this;
      }
      public Builder ClearCost() {
        PrepareBuilder();
        result.hasCost = false;
        result.cost_ = 0F;
        return this;
      }
      
      public bool HasIsOneWay {
        get { return result.hasIsOneWay; }
      }
      public bool IsOneWay {
        get { return result.IsOneWay; }
        set { SetIsOneWay(value); }
      }
      public Builder SetIsOneWay(bool value) {
        PrepareBuilder();
        result.hasIsOneWay = true;
        result.isOneWay_ = value;
        return this;
      }
      public Builder ClearIsOneWay() {
        PrepareBuilder();
        result.hasIsOneWay = false;
        result.isOneWay_ = false;
        return this;
      }
    }
    static WayLineCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class ThingWayMap : pb::GeneratedMessage<ThingWayMap, ThingWayMap.Builder> {
    public ThingWayMap() { }
    private static readonly ThingWayMap defaultInstance = new ThingWayMap().MakeReadOnly();
    private static readonly string[] _thingWayMapFieldNames = new string[] { "id", "way_map_cfg" };
    private static readonly uint[] _thingWayMapFieldTags = new uint[] { 8, 18 };
    public static ThingWayMap DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ThingWayMap DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ThingWayMap ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_ThingWayMap__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ThingWayMap, ThingWayMap.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_ThingWayMap__FieldAccessorTable; }
    }
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private uint id_;
    public bool HasId {
      get { return hasId; }
    }
    [global::System.CLSCompliant(false)]
    public uint Id {
      get { return id_; }
      set { hasId = true;
        id_ = value;}
    }
    
    public const int WayMapCfgFieldNumber = 2;
    private bool hasWayMapCfg;
    private global::Protocol.WayMapCfg wayMapCfg_;
    public bool HasWayMapCfg {
      get { return hasWayMapCfg; }
    }
    public global::Protocol.WayMapCfg WayMapCfg {
      get { return wayMapCfg_; }
      set { hasWayMapCfg = true;
        wayMapCfg_ = value;}
    }
    public void MergeWayMapCfg(global::Protocol.WayMapCfg value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasWayMapCfg &&
        wayMapCfg_ != global::Protocol.WayMapCfg.DefaultInstance) {
        wayMapCfg_.MergeFrom(value, isFull);
      } else {
        wayMapCfg_ = value;
      }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        if (HasWayMapCfg) {
          if (!WayMapCfg.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _thingWayMapFieldNames;
      if (hasId) {
        output.WriteUInt32(1, field_names[0], Id);
      }
      if (hasWayMapCfg) {
        output.WriteMessage(2, field_names[1], WayMapCfg);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Id);
      }
      if (hasWayMapCfg) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, WayMapCfg);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public ThingWayMap CommitChange() {
      ThingWayMap other = new ThingWayMap();
      bool isChange = false;
      other.Id = Id;
      
      var WayMapCfgcommit = WayMapCfg?.CommitChange();
      if(WayMapCfgcommit!=null)
      {
          isChange = true;
          other.WayMapCfg = WayMapCfgcommit;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(ThingWayMap other, bool isFull = false) {
      if (other == global::Protocol.ThingWayMap.DefaultInstance) return;
      if (other.HasId) {
        Id = other.Id;
      }
      
      if (other.HasWayMapCfg)
      {
        MergeWayMapCfg(other.WayMapCfg, isFull);
      }
    }
    
    public static ThingWayMap ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ThingWayMap ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ThingWayMap ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ThingWayMap ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ThingWayMap ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ThingWayMap MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ThingWayMap prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<ThingWayMap, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ThingWayMap cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ThingWayMap result;
      
      private ThingWayMap PrepareBuilder() {
        if (resultIsReadOnly) {
          ThingWayMap original = result;
          result = new ThingWayMap();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ThingWayMap MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.ThingWayMap.Descriptor; }
      }
      
      public override ThingWayMap DefaultInstanceForType {
        get { return global::Protocol.ThingWayMap.DefaultInstance; }
      }
      
      public override ThingWayMap BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ThingWayMap) {
          return MergeFrom((ThingWayMap) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ThingWayMap other) {
        if (other == global::Protocol.ThingWayMap.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasWayMapCfg) {
          MergeWayMapCfg(other.WayMapCfg);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_thingWayMapFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _thingWayMapFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadUInt32(ref result.id_);
              break;
            }
            case 18: {
              global::Protocol.WayMapCfg.Builder subBuilder = global::Protocol.WayMapCfg.CreateBuilder();
              if (result.hasWayMapCfg) {
                subBuilder.MergeFrom(WayMapCfg);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              WayMapCfg = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      [global::System.CLSCompliant(false)]
      public uint Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetId(uint value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0;
        return this;
      }
      
      public bool HasWayMapCfg {
       get { return result.hasWayMapCfg; }
      }
      public global::Protocol.WayMapCfg WayMapCfg {
        get { return result.WayMapCfg; }
        set { SetWayMapCfg(value); }
      }
      public Builder SetWayMapCfg(global::Protocol.WayMapCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWayMapCfg = true;
        result.wayMapCfg_ = value;
        return this;
      }
      public Builder SetWayMapCfg(global::Protocol.WayMapCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasWayMapCfg = true;
        result.wayMapCfg_ = builderForValue.Build();
        return this;
      }
      public Builder MergeWayMapCfg(global::Protocol.WayMapCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasWayMapCfg &&
            result.wayMapCfg_ != global::Protocol.WayMapCfg.DefaultInstance) {
            result.wayMapCfg_ = global::Protocol.WayMapCfg.CreateBuilder(result.wayMapCfg_).MergeFrom(value).BuildPartial();
        } else {
          result.wayMapCfg_ = value;
          result.hasWayMapCfg = true;
        }
        return this;
      }
      public Builder ClearWayMapCfg() {
        PrepareBuilder();
        result.hasWayMapCfg = false;
        result.wayMapCfg_ = null;
        return this;
      }
    }
    static ThingWayMap() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class CellCfg : pb::GeneratedMessage<CellCfg, CellCfg.Builder> {
    public CellCfg() { }
    private static readonly CellCfg defaultInstance = new CellCfg().MakeReadOnly();
    private static readonly string[] _cellCfgFieldNames = new string[] { "IsExplored", "elevation", "farm_level", "incomingRiver", "index", "is_wall", "neighbor_cell_index_list", "outgoingRiver", "plant_level", "position", "roadFlags", "special_index", "terrain_type", "urban_level", "water_level" };
    private static readonly uint[] _cellCfgFieldTags = new uint[] { 96, 16, 40, 72, 104, 64, 120, 80, 48, 114, 88, 56, 8, 32, 24 };
    public static CellCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CellCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CellCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_CellCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CellCfg, CellCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_CellCfg__FieldAccessorTable; }
    }
    
    public const int TerrainTypeFieldNumber = 1;
    private bool hasTerrainType;
    private int terrainType_;
    public bool HasTerrainType {
      get { return hasTerrainType; }
    }
    public int TerrainType {
      get { return terrainType_; }
      set { hasTerrainType = true;
        terrainType_ = value;}
    }
    
    public const int ElevationFieldNumber = 2;
    private bool hasElevation;
    private int elevation_;
    public bool HasElevation {
      get { return hasElevation; }
    }
    public int Elevation {
      get { return elevation_; }
      set { hasElevation = true;
        elevation_ = value;}
    }
    
    public const int WaterLevelFieldNumber = 3;
    private bool hasWaterLevel;
    private int waterLevel_;
    public bool HasWaterLevel {
      get { return hasWaterLevel; }
    }
    public int WaterLevel {
      get { return waterLevel_; }
      set { hasWaterLevel = true;
        waterLevel_ = value;}
    }
    
    public const int UrbanLevelFieldNumber = 4;
    private bool hasUrbanLevel;
    private int urbanLevel_;
    public bool HasUrbanLevel {
      get { return hasUrbanLevel; }
    }
    public int UrbanLevel {
      get { return urbanLevel_; }
      set { hasUrbanLevel = true;
        urbanLevel_ = value;}
    }
    
    public const int FarmLevelFieldNumber = 5;
    private bool hasFarmLevel;
    private int farmLevel_;
    public bool HasFarmLevel {
      get { return hasFarmLevel; }
    }
    public int FarmLevel {
      get { return farmLevel_; }
      set { hasFarmLevel = true;
        farmLevel_ = value;}
    }
    
    public const int PlantLevelFieldNumber = 6;
    private bool hasPlantLevel;
    private int plantLevel_;
    public bool HasPlantLevel {
      get { return hasPlantLevel; }
    }
    public int PlantLevel {
      get { return plantLevel_; }
      set { hasPlantLevel = true;
        plantLevel_ = value;}
    }
    
    public const int SpecialIndexFieldNumber = 7;
    private bool hasSpecialIndex;
    private int specialIndex_;
    public bool HasSpecialIndex {
      get { return hasSpecialIndex; }
    }
    public int SpecialIndex {
      get { return specialIndex_; }
      set { hasSpecialIndex = true;
        specialIndex_ = value;}
    }
    
    public const int IsWallFieldNumber = 8;
    private bool hasIsWall;
    private bool isWall_;
    public bool HasIsWall {
      get { return hasIsWall; }
    }
    public bool IsWall {
      get { return isWall_; }
      set { hasIsWall = true;
        isWall_ = value;}
    }
    
    public const int IncomingRiverFieldNumber = 9;
    private bool hasIncomingRiver;
    private global::Protocol.HexDirection incomingRiver_ = global::Protocol.HexDirection.NE;
    private bool isIncomingRiverChanged = true;
    public bool HasIncomingRiver {
      get { return hasIncomingRiver; }
    }
    public global::Protocol.HexDirection IncomingRiver {
      get { return incomingRiver_; }
      set { hasIncomingRiver = true;
        isIncomingRiverChanged = true;
        incomingRiver_ = value;}
    }
    
    public const int OutgoingRiverFieldNumber = 10;
    private bool hasOutgoingRiver;
    private global::Protocol.HexDirection outgoingRiver_ = global::Protocol.HexDirection.NE;
    private bool isOutgoingRiverChanged = true;
    public bool HasOutgoingRiver {
      get { return hasOutgoingRiver; }
    }
    public global::Protocol.HexDirection OutgoingRiver {
      get { return outgoingRiver_; }
      set { hasOutgoingRiver = true;
        isOutgoingRiverChanged = true;
        outgoingRiver_ = value;}
    }
    
    public const int RoadFlagsFieldNumber = 11;
    private bool hasRoadFlags;
    private bool isRoadFlagsChanged = true;
    private int roadFlags_;
    public bool HasRoadFlags {
      get { return hasRoadFlags; }
    }
    public int RoadFlags {
      get { return roadFlags_; }
      set { hasRoadFlags = true;
        isRoadFlagsChanged = true;
        roadFlags_ = value;}
    }
    
    public const int IsExploredFieldNumber = 12;
    private bool hasIsExplored;
    private bool isIsExploredChanged = true;
    private bool isExplored_;
    public bool HasIsExplored {
      get { return hasIsExplored; }
    }
    public bool IsExplored {
      get { return isExplored_; }
      set { hasIsExplored = true;
        isIsExploredChanged = true;
        isExplored_ = value;}
    }
    
    public const int IndexFieldNumber = 13;
    private bool hasIndex;
    private int index_;
    public bool HasIndex {
      get { return hasIndex; }
    }
    public int Index {
      get { return index_; }
      set { hasIndex = true;
        index_ = value;}
    }
    
    public const int PositionFieldNumber = 14;
    private bool hasPosition;
    private global::Protocol.Float3 position_;
    public bool HasPosition {
      get { return hasPosition; }
    }
    public global::Protocol.Float3 Position {
      get { return position_; }
      set { hasPosition = true;
        position_ = value;}
    }
    public void MergePosition(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasPosition &&
        position_ != global::Protocol.Float3.DefaultInstance) {
        position_.MergeFrom(value, isFull);
      } else {
        position_ = value;
      }
    }
    
    public const int NeighborCellIndexListFieldNumber = 15;
    private pbc::PopsicleList<int> neighborCellIndexList_ = new pbc::PopsicleList<int>();
    private bool isNeighborCellIndexListChanged = true;
    public scg::IList<int> NeighborCellIndexList {
      get { return pbc::Lists.AsReadOnly(neighborCellIndexList_); }
    }
    public int NeighborCellIndexListCount {
      get { return neighborCellIndexList_.Count; }
    }
    public int GetNeighborCellIndexList(int index) {
      return neighborCellIndexList_[index];
    }
    public void SetNeighborCellIndexList(int index, int value) {
      if (index < 0 || index >= neighborCellIndexList_.Count) return;
      neighborCellIndexList_[index] = value;
      isNeighborCellIndexListChanged = true;
    }
    public void AddNeighborCellIndexList(int value) {
      neighborCellIndexList_.Add(value);
      isNeighborCellIndexListChanged = true;
    }
    public void AddRangeNeighborCellIndexList(scg::IEnumerable<int> values) {
      neighborCellIndexList_.Add(values);
      isNeighborCellIndexListChanged = true;
    }
    public void RemoveNeighborCellIndexList(int value) {
      if (!neighborCellIndexList_.Contains(value)) return;
      neighborCellIndexList_.Remove(value);
      isNeighborCellIndexListChanged = true;
    }
    public void RemoveAtNeighborCellIndexList(int index) {
      if (index < 0 || index >= neighborCellIndexList_.Count) return;
      neighborCellIndexList_.RemoveAt(index);
      isNeighborCellIndexListChanged = true;
    }
    public void ClearNeighborCellIndexList() {
      if (neighborCellIndexList_.Count <= 0) return;
      neighborCellIndexList_.Clear();
      isNeighborCellIndexListChanged = true;
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTerrainType) return false;
        if (!hasElevation) return false;
        if (!hasWaterLevel) return false;
        if (!hasUrbanLevel) return false;
        if (!hasFarmLevel) return false;
        if (!hasPlantLevel) return false;
        if (!hasSpecialIndex) return false;
        if (!hasIsWall) return false;
        if (!hasIndex) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _cellCfgFieldNames;
      if (hasTerrainType) {
        output.WriteInt32(1, field_names[12], TerrainType);
      }
      if (hasElevation) {
        output.WriteInt32(2, field_names[1], Elevation);
      }
      if (hasWaterLevel) {
        output.WriteInt32(3, field_names[14], WaterLevel);
      }
      if (hasUrbanLevel) {
        output.WriteInt32(4, field_names[13], UrbanLevel);
      }
      if (hasFarmLevel) {
        output.WriteInt32(5, field_names[2], FarmLevel);
      }
      if (hasPlantLevel) {
        output.WriteInt32(6, field_names[8], PlantLevel);
      }
      if (hasSpecialIndex) {
        output.WriteInt32(7, field_names[11], SpecialIndex);
      }
      if (hasIsWall) {
        output.WriteBool(8, field_names[5], IsWall);
      }
      if (hasIncomingRiver) {
        output.WriteEnum(9, field_names[3], (int) IncomingRiver, IncomingRiver);
      }
      if (hasOutgoingRiver) {
        output.WriteEnum(10, field_names[7], (int) OutgoingRiver, OutgoingRiver);
      }
      if (hasRoadFlags) {
        output.WriteInt32(11, field_names[10], RoadFlags);
      }
      if (hasIsExplored) {
        output.WriteBool(12, field_names[0], IsExplored);
      }
      if (hasIndex) {
        output.WriteInt32(13, field_names[4], Index);
      }
      if (hasPosition) {
        output.WriteMessage(14, field_names[9], Position);
      }
      if (neighborCellIndexList_.Count > 0) {
        output.WriteInt32Array(15, field_names[6], neighborCellIndexList_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasTerrainType) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, TerrainType);
      }
      if (hasElevation) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Elevation);
      }
      if (hasWaterLevel) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, WaterLevel);
      }
      if (hasUrbanLevel) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, UrbanLevel);
      }
      if (hasFarmLevel) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, FarmLevel);
      }
      if (hasPlantLevel) {
        size += pb::CodedOutputStream.ComputeInt32Size(6, PlantLevel);
      }
      if (hasSpecialIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, SpecialIndex);
      }
      if (hasIsWall) {
        size += pb::CodedOutputStream.ComputeBoolSize(8, IsWall);
      }
      if (hasIncomingRiver) {
        size += pb::CodedOutputStream.ComputeEnumSize(9, (int) IncomingRiver);
      }
      if (hasOutgoingRiver) {
        size += pb::CodedOutputStream.ComputeEnumSize(10, (int) OutgoingRiver);
      }
      if (hasRoadFlags) {
        size += pb::CodedOutputStream.ComputeInt32Size(11, RoadFlags);
      }
      if (hasIsExplored) {
        size += pb::CodedOutputStream.ComputeBoolSize(12, IsExplored);
      }
      if (hasIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(13, Index);
      }
      if (hasPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(14, Position);
      }
      {
        int dataSize = 0;
        foreach (int element in NeighborCellIndexList) {
          dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
        }
        size += dataSize;
        size += 1 * neighborCellIndexList_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public CellCfg CommitChange() {
      CellCfg other = new CellCfg();
      bool isChange = false;
      other.TerrainType = TerrainType;
      other.Elevation = Elevation;
      other.WaterLevel = WaterLevel;
      other.UrbanLevel = UrbanLevel;
      other.FarmLevel = FarmLevel;
      other.PlantLevel = PlantLevel;
      other.SpecialIndex = SpecialIndex;
      other.IsWall = IsWall;
      if (isIncomingRiverChanged) {
        isChange = true;
        other.IncomingRiver = IncomingRiver;
        isIncomingRiverChanged = false;
      }
      if (isOutgoingRiverChanged) {
        isChange = true;
        other.OutgoingRiver = OutgoingRiver;
        isOutgoingRiverChanged = false;
      }
      if (isRoadFlagsChanged) {
        isChange = true;
        other.RoadFlags = RoadFlags;
        isRoadFlagsChanged = false;
      }
      if (isIsExploredChanged) {
        isChange = true;
        other.IsExplored = IsExplored;
        isIsExploredChanged = false;
      }
      other.Index = Index;
      
      var Positioncommit = Position?.CommitChange();
      if(Positioncommit!=null)
      {
          isChange = true;
          other.Position = Positioncommit;
      }
        isChange = true;
        other.neighborCellIndexList_.Add(neighborCellIndexList_);
      return isChange?other:null;
    }
    
    public void MergeFrom(CellCfg other, bool isFull = false) {
      if (other == global::Protocol.CellCfg.DefaultInstance) return;
      if (other.HasTerrainType) {
        TerrainType = other.TerrainType;
      }
      if (other.HasElevation) {
        Elevation = other.Elevation;
      }
      if (other.HasWaterLevel) {
        WaterLevel = other.WaterLevel;
      }
      if (other.HasUrbanLevel) {
        UrbanLevel = other.UrbanLevel;
      }
      if (other.HasFarmLevel) {
        FarmLevel = other.FarmLevel;
      }
      if (other.HasPlantLevel) {
        PlantLevel = other.PlantLevel;
      }
      if (other.HasSpecialIndex) {
        SpecialIndex = other.SpecialIndex;
      }
      if (other.HasIsWall) {
        IsWall = other.IsWall;
      }
      if (other.HasIncomingRiver) {
        IncomingRiver = other.IncomingRiver;
      }
      if (other.HasOutgoingRiver) {
        OutgoingRiver = other.OutgoingRiver;
      }
      if (other.HasRoadFlags) {
        RoadFlags = other.RoadFlags;
      }
      if (other.HasIsExplored) {
        IsExplored = other.IsExplored;
      }
      if (other.HasIndex) {
        Index = other.Index;
      }
      
      if (other.HasPosition)
      {
        MergePosition(other.Position, isFull);
      }
      if (other.neighborCellIndexList_.Count != 0) {
        neighborCellIndexList_.Clear();
        neighborCellIndexList_.Add(other.neighborCellIndexList_);
      }
    }
    
    public static CellCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CellCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CellCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CellCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CellCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CellCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CellCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CellCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CellCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CellCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CellCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CellCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<CellCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CellCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CellCfg result;
      
      private CellCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          CellCfg original = result;
          result = new CellCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CellCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.CellCfg.Descriptor; }
      }
      
      public override CellCfg DefaultInstanceForType {
        get { return global::Protocol.CellCfg.DefaultInstance; }
      }
      
      public override CellCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CellCfg) {
          return MergeFrom((CellCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CellCfg other) {
        if (other == global::Protocol.CellCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTerrainType) {
          TerrainType = other.TerrainType;
        }
        if (other.HasElevation) {
          Elevation = other.Elevation;
        }
        if (other.HasWaterLevel) {
          WaterLevel = other.WaterLevel;
        }
        if (other.HasUrbanLevel) {
          UrbanLevel = other.UrbanLevel;
        }
        if (other.HasFarmLevel) {
          FarmLevel = other.FarmLevel;
        }
        if (other.HasPlantLevel) {
          PlantLevel = other.PlantLevel;
        }
        if (other.HasSpecialIndex) {
          SpecialIndex = other.SpecialIndex;
        }
        if (other.HasIsWall) {
          IsWall = other.IsWall;
        }
        if (other.HasIncomingRiver) {
          IncomingRiver = other.IncomingRiver;
        }
        if (other.HasOutgoingRiver) {
          OutgoingRiver = other.OutgoingRiver;
        }
        if (other.HasRoadFlags) {
          RoadFlags = other.RoadFlags;
        }
        if (other.HasIsExplored) {
          IsExplored = other.IsExplored;
        }
        if (other.HasIndex) {
          Index = other.Index;
        }
        if (other.HasPosition) {
          MergePosition(other.Position);
        }
        if (other.neighborCellIndexList_.Count != 0) {
          result.neighborCellIndexList_.Add(other.neighborCellIndexList_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_cellCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _cellCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTerrainType = input.ReadInt32(ref result.terrainType_);
              break;
            }
            case 16: {
              result.hasElevation = input.ReadInt32(ref result.elevation_);
              break;
            }
            case 24: {
              result.hasWaterLevel = input.ReadInt32(ref result.waterLevel_);
              break;
            }
            case 32: {
              result.hasUrbanLevel = input.ReadInt32(ref result.urbanLevel_);
              break;
            }
            case 40: {
              result.hasFarmLevel = input.ReadInt32(ref result.farmLevel_);
              break;
            }
            case 48: {
              result.hasPlantLevel = input.ReadInt32(ref result.plantLevel_);
              break;
            }
            case 56: {
              result.hasSpecialIndex = input.ReadInt32(ref result.specialIndex_);
              break;
            }
            case 64: {
              result.hasIsWall = input.ReadBool(ref result.isWall_);
              break;
            }
            case 72: {
              object unknown;
              if(input.ReadEnum(ref result.incomingRiver_, out unknown)) {
                result.hasIncomingRiver = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(9, (ulong)(int)unknown);
              }
              break;
            }
            case 80: {
              object unknown;
              if(input.ReadEnum(ref result.outgoingRiver_, out unknown)) {
                result.hasOutgoingRiver = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(10, (ulong)(int)unknown);
              }
              break;
            }
            case 88: {
              result.hasRoadFlags = input.ReadInt32(ref result.roadFlags_);
              break;
            }
            case 96: {
              result.hasIsExplored = input.ReadBool(ref result.isExplored_);
              break;
            }
            case 104: {
              result.hasIndex = input.ReadInt32(ref result.index_);
              break;
            }
            case 114: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasPosition) {
                subBuilder.MergeFrom(Position);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Position = subBuilder.BuildPartial();
              break;
            }
            case 122:
            case 120: {
              input.ReadInt32Array(tag, field_name, result.neighborCellIndexList_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTerrainType {
        get { return result.hasTerrainType; }
      }
      public int TerrainType {
        get { return result.TerrainType; }
        set { SetTerrainType(value); }
      }
      public Builder SetTerrainType(int value) {
        PrepareBuilder();
        result.hasTerrainType = true;
        result.terrainType_ = value;
        return this;
      }
      public Builder ClearTerrainType() {
        PrepareBuilder();
        result.hasTerrainType = false;
        result.terrainType_ = 0;
        return this;
      }
      
      public bool HasElevation {
        get { return result.hasElevation; }
      }
      public int Elevation {
        get { return result.Elevation; }
        set { SetElevation(value); }
      }
      public Builder SetElevation(int value) {
        PrepareBuilder();
        result.hasElevation = true;
        result.elevation_ = value;
        return this;
      }
      public Builder ClearElevation() {
        PrepareBuilder();
        result.hasElevation = false;
        result.elevation_ = 0;
        return this;
      }
      
      public bool HasWaterLevel {
        get { return result.hasWaterLevel; }
      }
      public int WaterLevel {
        get { return result.WaterLevel; }
        set { SetWaterLevel(value); }
      }
      public Builder SetWaterLevel(int value) {
        PrepareBuilder();
        result.hasWaterLevel = true;
        result.waterLevel_ = value;
        return this;
      }
      public Builder ClearWaterLevel() {
        PrepareBuilder();
        result.hasWaterLevel = false;
        result.waterLevel_ = 0;
        return this;
      }
      
      public bool HasUrbanLevel {
        get { return result.hasUrbanLevel; }
      }
      public int UrbanLevel {
        get { return result.UrbanLevel; }
        set { SetUrbanLevel(value); }
      }
      public Builder SetUrbanLevel(int value) {
        PrepareBuilder();
        result.hasUrbanLevel = true;
        result.urbanLevel_ = value;
        return this;
      }
      public Builder ClearUrbanLevel() {
        PrepareBuilder();
        result.hasUrbanLevel = false;
        result.urbanLevel_ = 0;
        return this;
      }
      
      public bool HasFarmLevel {
        get { return result.hasFarmLevel; }
      }
      public int FarmLevel {
        get { return result.FarmLevel; }
        set { SetFarmLevel(value); }
      }
      public Builder SetFarmLevel(int value) {
        PrepareBuilder();
        result.hasFarmLevel = true;
        result.farmLevel_ = value;
        return this;
      }
      public Builder ClearFarmLevel() {
        PrepareBuilder();
        result.hasFarmLevel = false;
        result.farmLevel_ = 0;
        return this;
      }
      
      public bool HasPlantLevel {
        get { return result.hasPlantLevel; }
      }
      public int PlantLevel {
        get { return result.PlantLevel; }
        set { SetPlantLevel(value); }
      }
      public Builder SetPlantLevel(int value) {
        PrepareBuilder();
        result.hasPlantLevel = true;
        result.plantLevel_ = value;
        return this;
      }
      public Builder ClearPlantLevel() {
        PrepareBuilder();
        result.hasPlantLevel = false;
        result.plantLevel_ = 0;
        return this;
      }
      
      public bool HasSpecialIndex {
        get { return result.hasSpecialIndex; }
      }
      public int SpecialIndex {
        get { return result.SpecialIndex; }
        set { SetSpecialIndex(value); }
      }
      public Builder SetSpecialIndex(int value) {
        PrepareBuilder();
        result.hasSpecialIndex = true;
        result.specialIndex_ = value;
        return this;
      }
      public Builder ClearSpecialIndex() {
        PrepareBuilder();
        result.hasSpecialIndex = false;
        result.specialIndex_ = 0;
        return this;
      }
      
      public bool HasIsWall {
        get { return result.hasIsWall; }
      }
      public bool IsWall {
        get { return result.IsWall; }
        set { SetIsWall(value); }
      }
      public Builder SetIsWall(bool value) {
        PrepareBuilder();
        result.hasIsWall = true;
        result.isWall_ = value;
        return this;
      }
      public Builder ClearIsWall() {
        PrepareBuilder();
        result.hasIsWall = false;
        result.isWall_ = false;
        return this;
      }
      
      public bool HasIncomingRiver {
       get { return result.hasIncomingRiver; }
      }
      public global::Protocol.HexDirection IncomingRiver {
        get { return result.IncomingRiver; }
        set { SetIncomingRiver(value); }
      }
      public Builder SetIncomingRiver(global::Protocol.HexDirection value) {
        PrepareBuilder();
        result.hasIncomingRiver = true;
        result.incomingRiver_ = value;
        return this;
      }
      public Builder ClearIncomingRiver() {
        PrepareBuilder();
        result.hasIncomingRiver = false;
        result.incomingRiver_ = global::Protocol.HexDirection.NE;
        return this;
      }
      
      public bool HasOutgoingRiver {
       get { return result.hasOutgoingRiver; }
      }
      public global::Protocol.HexDirection OutgoingRiver {
        get { return result.OutgoingRiver; }
        set { SetOutgoingRiver(value); }
      }
      public Builder SetOutgoingRiver(global::Protocol.HexDirection value) {
        PrepareBuilder();
        result.hasOutgoingRiver = true;
        result.outgoingRiver_ = value;
        return this;
      }
      public Builder ClearOutgoingRiver() {
        PrepareBuilder();
        result.hasOutgoingRiver = false;
        result.outgoingRiver_ = global::Protocol.HexDirection.NE;
        return this;
      }
      
      public bool HasRoadFlags {
        get { return result.hasRoadFlags; }
      }
      public int RoadFlags {
        get { return result.RoadFlags; }
        set { SetRoadFlags(value); }
      }
      public Builder SetRoadFlags(int value) {
        PrepareBuilder();
        result.hasRoadFlags = true;
        result.roadFlags_ = value;
        return this;
      }
      public Builder ClearRoadFlags() {
        PrepareBuilder();
        result.hasRoadFlags = false;
        result.roadFlags_ = 0;
        return this;
      }
      
      public bool HasIsExplored {
        get { return result.hasIsExplored; }
      }
      public bool IsExplored {
        get { return result.IsExplored; }
        set { SetIsExplored(value); }
      }
      public Builder SetIsExplored(bool value) {
        PrepareBuilder();
        result.hasIsExplored = true;
        result.isExplored_ = value;
        return this;
      }
      public Builder ClearIsExplored() {
        PrepareBuilder();
        result.hasIsExplored = false;
        result.isExplored_ = false;
        return this;
      }
      
      public bool HasIndex {
        get { return result.hasIndex; }
      }
      public int Index {
        get { return result.Index; }
        set { SetIndex(value); }
      }
      public Builder SetIndex(int value) {
        PrepareBuilder();
        result.hasIndex = true;
        result.index_ = value;
        return this;
      }
      public Builder ClearIndex() {
        PrepareBuilder();
        result.hasIndex = false;
        result.index_ = 0;
        return this;
      }
      
      public bool HasPosition {
       get { return result.hasPosition; }
      }
      public global::Protocol.Float3 Position {
        get { return result.Position; }
        set { SetPosition(value); }
      }
      public Builder SetPosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = value;
        return this;
      }
      public Builder SetPosition(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = builderForValue.Build();
        return this;
      }
      public Builder MergePosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasPosition &&
            result.position_ != global::Protocol.Float3.DefaultInstance) {
            result.position_ = global::Protocol.Float3.CreateBuilder(result.position_).MergeFrom(value).BuildPartial();
        } else {
          result.position_ = value;
          result.hasPosition = true;
        }
        return this;
      }
      public Builder ClearPosition() {
        PrepareBuilder();
        result.hasPosition = false;
        result.position_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<int> NeighborCellIndexList {
        get { return PrepareBuilder().neighborCellIndexList_; }
      }
      public int NeighborCellIndexListCount {
        get { return result.NeighborCellIndexListCount; }
      }
      public int GetNeighborCellIndexList(int index) {
        return result.GetNeighborCellIndexList(index);
      }
      public Builder SetNeighborCellIndexList(int index, int value) {
        PrepareBuilder();
        result.neighborCellIndexList_[index] = value;
        return this;
      }
      public Builder AddNeighborCellIndexList(int value) {
        PrepareBuilder();
        result.neighborCellIndexList_.Add(value);
        return this;
      }
      public Builder AddRangeNeighborCellIndexList(scg::IEnumerable<int> values) {
        PrepareBuilder();
        result.neighborCellIndexList_.Add(values);
        return this;
      }
      public Builder ClearNeighborCellIndexList() {
        PrepareBuilder();
        result.neighborCellIndexList_.Clear();
        return this;
      }
    }
    static CellCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class UnitCfg : pb::GeneratedMessage<UnitCfg, UnitCfg.Builder> {
    public UnitCfg() { }
    private static readonly UnitCfg defaultInstance = new UnitCfg().MakeReadOnly();
    private static readonly string[] _unitCfgFieldNames = new string[] { "rotation", "x", "y" };
    private static readonly uint[] _unitCfgFieldTags = new uint[] { 29, 8, 16 };
    public static UnitCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override UnitCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override UnitCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_UnitCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<UnitCfg, UnitCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_UnitCfg__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private int x_;
    public bool HasX {
      get { return hasX; }
    }
    public int X {
      get { return x_; }
      set { hasX = true;
        x_ = value;}
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private int y_;
    public bool HasY {
      get { return hasY; }
    }
    public int Y {
      get { return y_; }
      set { hasY = true;
        y_ = value;}
    }
    
    public const int RotationFieldNumber = 3;
    private bool hasRotation;
    private float rotation_;
    public bool HasRotation {
      get { return hasRotation; }
    }
    public float Rotation {
      get { return rotation_; }
      set { hasRotation = true;
        rotation_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasRotation) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _unitCfgFieldNames;
      if (hasX) {
        output.WriteInt32(1, field_names[1], X);
      }
      if (hasY) {
        output.WriteInt32(2, field_names[2], Y);
      }
      if (hasRotation) {
        output.WriteFloat(3, field_names[0], Rotation);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Y);
      }
      if (hasRotation) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Rotation);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public UnitCfg CommitChange() {
      UnitCfg other = new UnitCfg();
      bool isChange = false;
      other.X = X;
      other.Y = Y;
      other.Rotation = Rotation;
      return isChange?other:null;
    }
    
    public void MergeFrom(UnitCfg other, bool isFull = false) {
      if (other == global::Protocol.UnitCfg.DefaultInstance) return;
      if (other.HasX) {
        X = other.X;
      }
      if (other.HasY) {
        Y = other.Y;
      }
      if (other.HasRotation) {
        Rotation = other.Rotation;
      }
    }
    
    public static UnitCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UnitCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UnitCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static UnitCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static UnitCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UnitCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static UnitCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static UnitCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static UnitCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static UnitCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private UnitCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(UnitCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<UnitCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(UnitCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UnitCfg result;
      
      private UnitCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          UnitCfg original = result;
          result = new UnitCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override UnitCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.UnitCfg.Descriptor; }
      }
      
      public override UnitCfg DefaultInstanceForType {
        get { return global::Protocol.UnitCfg.DefaultInstance; }
      }
      
      public override UnitCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is UnitCfg) {
          return MergeFrom((UnitCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(UnitCfg other) {
        if (other == global::Protocol.UnitCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasRotation) {
          Rotation = other.Rotation;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_unitCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _unitCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasX = input.ReadInt32(ref result.x_);
              break;
            }
            case 16: {
              result.hasY = input.ReadInt32(ref result.y_);
              break;
            }
            case 29: {
              result.hasRotation = input.ReadFloat(ref result.rotation_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public int X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(int value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public int Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(int value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0;
        return this;
      }
      
      public bool HasRotation {
        get { return result.hasRotation; }
      }
      public float Rotation {
        get { return result.Rotation; }
        set { SetRotation(value); }
      }
      public Builder SetRotation(float value) {
        PrepareBuilder();
        result.hasRotation = true;
        result.rotation_ = value;
        return this;
      }
      public Builder ClearRotation() {
        PrepareBuilder();
        result.hasRotation = false;
        result.rotation_ = 0F;
        return this;
      }
    }
    static UnitCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AnimatorCfg : pb::GeneratedMessage<AnimatorCfg, AnimatorCfg.Builder> {
    public AnimatorCfg() { }
    private static readonly AnimatorCfg defaultInstance = new AnimatorCfg().MakeReadOnly();
    private static readonly string[] _animatorCfgFieldNames = new string[] { "animator_name", "clip_cfg_list", "clip_count" };
    private static readonly uint[] _animatorCfgFieldTags = new uint[] { 10, 26, 16 };
    public static AnimatorCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AnimatorCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AnimatorCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_AnimatorCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AnimatorCfg, AnimatorCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_AnimatorCfg__FieldAccessorTable; }
    }
    
    public const int AnimatorNameFieldNumber = 1;
    private bool hasAnimatorName;
    private bool isAnimatorNameChanged = true;
    private string animatorName_ = "";
    public bool HasAnimatorName {
      get { return hasAnimatorName; }
    }
    public string AnimatorName {
      get { return animatorName_; }
      set { hasAnimatorName = true;
        isAnimatorNameChanged = true;
        animatorName_ = value;}
    }
    
    public const int ClipCountFieldNumber = 2;
    private bool hasClipCount;
    private bool isClipCountChanged = true;
    private uint clipCount_;
    public bool HasClipCount {
      get { return hasClipCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint ClipCount {
      get { return clipCount_; }
      set { hasClipCount = true;
        isClipCountChanged = true;
        clipCount_ = value;}
    }
    
    public const int ClipCfgListFieldNumber = 3;
    private pbc::PopsicleList<global::Protocol.AnimationClipCfg> clipCfgList_ = new pbc::PopsicleList<global::Protocol.AnimationClipCfg>();
    public scg::IList<global::Protocol.AnimationClipCfg> ClipCfgList {
      get { return pbc::Lists.AsReadOnly(clipCfgList_); }
    }
    public int ClipCfgListCount {
      get { return clipCfgList_.Count; }
    }
    public global::Protocol.AnimationClipCfg GetClipCfgList(int index) {
      return clipCfgList_[index];
    }
    public global::Protocol.AnimationClipCfg FindClipCfgList(System.Predicate<global::Protocol.AnimationClipCfg> match) {
      return clipCfgList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.AnimationClipCfg> FindAllClipCfgList(System.Predicate<global::Protocol.AnimationClipCfg> match) {
      return clipCfgList_.FindAll(match);
    }
    public void SetClipCfgList(int index, global::Protocol.AnimationClipCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= clipCfgList_.Count) return;
      clipCfgList_[index] = value;
    }
    public void AddClipCfgList(global::Protocol.AnimationClipCfg value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      clipCfgList_.Add(value);
    }
    public void AddRangeClipCfgList(scg::IEnumerable<global::Protocol.AnimationClipCfg> values) {
      clipCfgList_.Add(values);
    }
    public void RemoveClipCfgList(global::Protocol.AnimationClipCfg value) {
      if (!clipCfgList_.Contains(value)) return;
      clipCfgList_.Remove(value);
    }
    public void RemoveAtClipCfgList(int index) {
      if (index < 0 || index >= clipCfgList_.Count) return;
      clipCfgList_.RemoveAt(index);
    }
    public void ClearClipCfgList() {
      if (clipCfgList_.Count <= 0) return;
      clipCfgList_.Clear();
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _animatorCfgFieldNames;
      if (hasAnimatorName) {
        output.WriteString(1, field_names[0], AnimatorName);
      }
      if (hasClipCount) {
        output.WriteUInt32(2, field_names[2], ClipCount);
      }
      if (clipCfgList_.Count > 0) {
        output.WriteMessageArray(3, field_names[1], clipCfgList_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasAnimatorName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, AnimatorName);
      }
      if (hasClipCount) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, ClipCount);
      }
      foreach (global::Protocol.AnimationClipCfg element in ClipCfgList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public AnimatorCfg CommitChange() {
      AnimatorCfg other = new AnimatorCfg();
      bool isChange = false;
      if (isAnimatorNameChanged) {
        isChange = true;
        other.AnimatorName = AnimatorName;
        isAnimatorNameChanged = false;
      }
      if (isClipCountChanged) {
        isChange = true;
        other.ClipCount = ClipCount;
        isClipCountChanged = false;
      }
      isChange = true;
      other.clipCfgList_.Add(clipCfgList_);
      return isChange?other:null;
    }
    
    public void MergeFrom(AnimatorCfg other, bool isFull = false) {
      if (other == global::Protocol.AnimatorCfg.DefaultInstance) return;
      if (other.HasAnimatorName) {
        AnimatorName = other.AnimatorName;
      }
      if (other.HasClipCount) {
        ClipCount = other.ClipCount;
      }
        clipCfgList_.Clear();
        clipCfgList_.Add(other.clipCfgList_);
    }
    
    public static AnimatorCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AnimatorCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AnimatorCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AnimatorCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AnimatorCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AnimatorCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AnimatorCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AnimatorCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AnimatorCfg result;
      
      private AnimatorCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          AnimatorCfg original = result;
          result = new AnimatorCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AnimatorCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.AnimatorCfg.Descriptor; }
      }
      
      public override AnimatorCfg DefaultInstanceForType {
        get { return global::Protocol.AnimatorCfg.DefaultInstance; }
      }
      
      public override AnimatorCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AnimatorCfg) {
          return MergeFrom((AnimatorCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AnimatorCfg other) {
        if (other == global::Protocol.AnimatorCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAnimatorName) {
          AnimatorName = other.AnimatorName;
        }
        if (other.HasClipCount) {
          ClipCount = other.ClipCount;
        }
        if (other.clipCfgList_.Count != 0) {
          result.clipCfgList_.Add(other.clipCfgList_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_animatorCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _animatorCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasAnimatorName = input.ReadString(ref result.animatorName_);
              break;
            }
            case 16: {
              result.hasClipCount = input.ReadUInt32(ref result.clipCount_);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.clipCfgList_, global::Protocol.AnimationClipCfg.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAnimatorName {
        get { return result.hasAnimatorName; }
      }
      public string AnimatorName {
        get { return result.AnimatorName; }
        set { SetAnimatorName(value); }
      }
      public Builder SetAnimatorName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAnimatorName = true;
        result.animatorName_ = value;
        return this;
      }
      public Builder ClearAnimatorName() {
        PrepareBuilder();
        result.hasAnimatorName = false;
        result.animatorName_ = "";
        return this;
      }
      
      public bool HasClipCount {
        get { return result.hasClipCount; }
      }
      [global::System.CLSCompliant(false)]
      public uint ClipCount {
        get { return result.ClipCount; }
        set { SetClipCount(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetClipCount(uint value) {
        PrepareBuilder();
        result.hasClipCount = true;
        result.clipCount_ = value;
        return this;
      }
      public Builder ClearClipCount() {
        PrepareBuilder();
        result.hasClipCount = false;
        result.clipCount_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.AnimationClipCfg> ClipCfgList {
        get { return PrepareBuilder().clipCfgList_; }
      }
      public int ClipCfgListCount {
        get { return result.ClipCfgListCount; }
      }
      public global::Protocol.AnimationClipCfg GetClipCfgList(int index) {
        return result.GetClipCfgList(index);
      }
      public Builder SetClipCfgList(int index, global::Protocol.AnimationClipCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.clipCfgList_[index] = value;
        return this;
      }
      public Builder SetClipCfgList(int index, global::Protocol.AnimationClipCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.clipCfgList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddClipCfgList(global::Protocol.AnimationClipCfg value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.clipCfgList_.Add(value);
        return this;
      }
      public Builder AddClipCfgList(global::Protocol.AnimationClipCfg.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.clipCfgList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeClipCfgList(scg::IEnumerable<global::Protocol.AnimationClipCfg> values) {
        PrepareBuilder();
        result.clipCfgList_.Add(values);
        return this;
      }
      public Builder ClearClipCfgList() {
        PrepareBuilder();
        result.clipCfgList_.Clear();
        return this;
      }
    }
    static AnimatorCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AnimationClipCfg : pb::GeneratedMessage<AnimationClipCfg, AnimationClipCfg.Builder> {
    public AnimationClipCfg() { }
    private static readonly AnimationClipCfg defaultInstance = new AnimationClipCfg().MakeReadOnly();
    private static readonly string[] _animationClipCfgFieldNames = new string[] { "clip_id", "clip_length", "clip_name" };
    private static readonly uint[] _animationClipCfgFieldTags = new uint[] { 24, 21, 10 };
    public static AnimationClipCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AnimationClipCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AnimationClipCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_AnimationClipCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AnimationClipCfg, AnimationClipCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_AnimationClipCfg__FieldAccessorTable; }
    }
    
    public const int ClipNameFieldNumber = 1;
    private bool hasClipName;
    private bool isClipNameChanged = true;
    private string clipName_ = "";
    public bool HasClipName {
      get { return hasClipName; }
    }
    public string ClipName {
      get { return clipName_; }
      set { hasClipName = true;
        isClipNameChanged = true;
        clipName_ = value;}
    }
    
    public const int ClipLengthFieldNumber = 2;
    private bool hasClipLength;
    private bool isClipLengthChanged = true;
    private float clipLength_;
    public bool HasClipLength {
      get { return hasClipLength; }
    }
    public float ClipLength {
      get { return clipLength_; }
      set { hasClipLength = true;
        isClipLengthChanged = true;
        clipLength_ = value;}
    }
    
    public const int ClipIdFieldNumber = 3;
    private bool hasClipId;
    private bool isClipIdChanged = true;
    private uint clipId_;
    public bool HasClipId {
      get { return hasClipId; }
    }
    [global::System.CLSCompliant(false)]
    public uint ClipId {
      get { return clipId_; }
      set { hasClipId = true;
        isClipIdChanged = true;
        clipId_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _animationClipCfgFieldNames;
      if (hasClipName) {
        output.WriteString(1, field_names[2], ClipName);
      }
      if (hasClipLength) {
        output.WriteFloat(2, field_names[1], ClipLength);
      }
      if (hasClipId) {
        output.WriteUInt32(3, field_names[0], ClipId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasClipName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, ClipName);
      }
      if (hasClipLength) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, ClipLength);
      }
      if (hasClipId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, ClipId);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public AnimationClipCfg CommitChange() {
      AnimationClipCfg other = new AnimationClipCfg();
      bool isChange = false;
      if (isClipNameChanged) {
        isChange = true;
        other.ClipName = ClipName;
        isClipNameChanged = false;
      }
      if (isClipLengthChanged) {
        isChange = true;
        other.ClipLength = ClipLength;
        isClipLengthChanged = false;
      }
      if (isClipIdChanged) {
        isChange = true;
        other.ClipId = ClipId;
        isClipIdChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(AnimationClipCfg other, bool isFull = false) {
      if (other == global::Protocol.AnimationClipCfg.DefaultInstance) return;
      if (other.HasClipName) {
        ClipName = other.ClipName;
      }
      if (other.HasClipLength) {
        ClipLength = other.ClipLength;
      }
      if (other.HasClipId) {
        ClipId = other.ClipId;
      }
    }
    
    public static AnimationClipCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AnimationClipCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AnimationClipCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AnimationClipCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AnimationClipCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AnimationClipCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AnimationClipCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AnimationClipCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AnimationClipCfg result;
      
      private AnimationClipCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          AnimationClipCfg original = result;
          result = new AnimationClipCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AnimationClipCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.AnimationClipCfg.Descriptor; }
      }
      
      public override AnimationClipCfg DefaultInstanceForType {
        get { return global::Protocol.AnimationClipCfg.DefaultInstance; }
      }
      
      public override AnimationClipCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AnimationClipCfg) {
          return MergeFrom((AnimationClipCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AnimationClipCfg other) {
        if (other == global::Protocol.AnimationClipCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasClipName) {
          ClipName = other.ClipName;
        }
        if (other.HasClipLength) {
          ClipLength = other.ClipLength;
        }
        if (other.HasClipId) {
          ClipId = other.ClipId;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_animationClipCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _animationClipCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasClipName = input.ReadString(ref result.clipName_);
              break;
            }
            case 21: {
              result.hasClipLength = input.ReadFloat(ref result.clipLength_);
              break;
            }
            case 24: {
              result.hasClipId = input.ReadUInt32(ref result.clipId_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasClipName {
        get { return result.hasClipName; }
      }
      public string ClipName {
        get { return result.ClipName; }
        set { SetClipName(value); }
      }
      public Builder SetClipName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasClipName = true;
        result.clipName_ = value;
        return this;
      }
      public Builder ClearClipName() {
        PrepareBuilder();
        result.hasClipName = false;
        result.clipName_ = "";
        return this;
      }
      
      public bool HasClipLength {
        get { return result.hasClipLength; }
      }
      public float ClipLength {
        get { return result.ClipLength; }
        set { SetClipLength(value); }
      }
      public Builder SetClipLength(float value) {
        PrepareBuilder();
        result.hasClipLength = true;
        result.clipLength_ = value;
        return this;
      }
      public Builder ClearClipLength() {
        PrepareBuilder();
        result.hasClipLength = false;
        result.clipLength_ = 0F;
        return this;
      }
      
      public bool HasClipId {
        get { return result.hasClipId; }
      }
      [global::System.CLSCompliant(false)]
      public uint ClipId {
        get { return result.ClipId; }
        set { SetClipId(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetClipId(uint value) {
        PrepareBuilder();
        result.hasClipId = true;
        result.clipId_ = value;
        return this;
      }
      public Builder ClearClipId() {
        PrepareBuilder();
        result.hasClipId = false;
        result.clipId_ = 0;
        return this;
      }
    }
    static AnimationClipCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MoveKeyFrame : pb::GeneratedMessage<MoveKeyFrame, MoveKeyFrame.Builder> {
    public MoveKeyFrame() { }
    private static readonly MoveKeyFrame defaultInstance = new MoveKeyFrame().MakeReadOnly();
    private static readonly string[] _moveKeyFrameFieldNames = new string[] { "in_tangent", "in_weight", "out_tangent", "out_weight", "time", "value" };
    private static readonly uint[] _moveKeyFrameFieldTags = new uint[] { 29, 45, 37, 53, 13, 21 };
    public static MoveKeyFrame DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveKeyFrame DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveKeyFrame ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveKeyFrame__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveKeyFrame, MoveKeyFrame.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveKeyFrame__FieldAccessorTable; }
    }
    
    public const int TimeFieldNumber = 1;
    private bool hasTime;
    private bool isTimeChanged = true;
    private float time_;
    public bool HasTime {
      get { return hasTime; }
    }
    public float Time {
      get { return time_; }
      set { hasTime = true;
        isTimeChanged = true;
        time_ = value;}
    }
    
    public const int ValueFieldNumber = 2;
    private bool hasValue;
    private bool isValueChanged = true;
    private float value_;
    public bool HasValue {
      get { return hasValue; }
    }
    public float Value {
      get { return value_; }
      set { hasValue = true;
        isValueChanged = true;
        value_ = value;}
    }
    
    public const int InTangentFieldNumber = 3;
    private bool hasInTangent;
    private bool isInTangentChanged = true;
    private float inTangent_;
    public bool HasInTangent {
      get { return hasInTangent; }
    }
    public float InTangent {
      get { return inTangent_; }
      set { hasInTangent = true;
        isInTangentChanged = true;
        inTangent_ = value;}
    }
    
    public const int OutTangentFieldNumber = 4;
    private bool hasOutTangent;
    private bool isOutTangentChanged = true;
    private float outTangent_;
    public bool HasOutTangent {
      get { return hasOutTangent; }
    }
    public float OutTangent {
      get { return outTangent_; }
      set { hasOutTangent = true;
        isOutTangentChanged = true;
        outTangent_ = value;}
    }
    
    public const int InWeightFieldNumber = 5;
    private bool hasInWeight;
    private bool isInWeightChanged = true;
    private float inWeight_;
    public bool HasInWeight {
      get { return hasInWeight; }
    }
    public float InWeight {
      get { return inWeight_; }
      set { hasInWeight = true;
        isInWeightChanged = true;
        inWeight_ = value;}
    }
    
    public const int OutWeightFieldNumber = 6;
    private bool hasOutWeight;
    private bool isOutWeightChanged = true;
    private float outWeight_;
    public bool HasOutWeight {
      get { return hasOutWeight; }
    }
    public float OutWeight {
      get { return outWeight_; }
      set { hasOutWeight = true;
        isOutWeightChanged = true;
        outWeight_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _moveKeyFrameFieldNames;
      if (hasTime) {
        output.WriteFloat(1, field_names[4], Time);
      }
      if (hasValue) {
        output.WriteFloat(2, field_names[5], Value);
      }
      if (hasInTangent) {
        output.WriteFloat(3, field_names[0], InTangent);
      }
      if (hasOutTangent) {
        output.WriteFloat(4, field_names[2], OutTangent);
      }
      if (hasInWeight) {
        output.WriteFloat(5, field_names[1], InWeight);
      }
      if (hasOutWeight) {
        output.WriteFloat(6, field_names[3], OutWeight);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasTime) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, Time);
      }
      if (hasValue) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Value);
      }
      if (hasInTangent) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, InTangent);
      }
      if (hasOutTangent) {
        size += pb::CodedOutputStream.ComputeFloatSize(4, OutTangent);
      }
      if (hasInWeight) {
        size += pb::CodedOutputStream.ComputeFloatSize(5, InWeight);
      }
      if (hasOutWeight) {
        size += pb::CodedOutputStream.ComputeFloatSize(6, OutWeight);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public MoveKeyFrame CommitChange() {
      MoveKeyFrame other = new MoveKeyFrame();
      bool isChange = false;
      if (isTimeChanged) {
        isChange = true;
        other.Time = Time;
        isTimeChanged = false;
      }
      if (isValueChanged) {
        isChange = true;
        other.Value = Value;
        isValueChanged = false;
      }
      if (isInTangentChanged) {
        isChange = true;
        other.InTangent = InTangent;
        isInTangentChanged = false;
      }
      if (isOutTangentChanged) {
        isChange = true;
        other.OutTangent = OutTangent;
        isOutTangentChanged = false;
      }
      if (isInWeightChanged) {
        isChange = true;
        other.InWeight = InWeight;
        isInWeightChanged = false;
      }
      if (isOutWeightChanged) {
        isChange = true;
        other.OutWeight = OutWeight;
        isOutWeightChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(MoveKeyFrame other, bool isFull = false) {
      if (other == global::Protocol.MoveKeyFrame.DefaultInstance) return;
      if (other.HasTime) {
        Time = other.Time;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasInTangent) {
        InTangent = other.InTangent;
      }
      if (other.HasOutTangent) {
        OutTangent = other.OutTangent;
      }
      if (other.HasInWeight) {
        InWeight = other.InWeight;
      }
      if (other.HasOutWeight) {
        OutWeight = other.OutWeight;
      }
    }
    
    public static MoveKeyFrame ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveKeyFrame ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveKeyFrame ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveKeyFrame ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveKeyFrame MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveKeyFrame prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveKeyFrame, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveKeyFrame cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveKeyFrame result;
      
      private MoveKeyFrame PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveKeyFrame original = result;
          result = new MoveKeyFrame();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveKeyFrame MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.MoveKeyFrame.Descriptor; }
      }
      
      public override MoveKeyFrame DefaultInstanceForType {
        get { return global::Protocol.MoveKeyFrame.DefaultInstance; }
      }
      
      public override MoveKeyFrame BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveKeyFrame) {
          return MergeFrom((MoveKeyFrame) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveKeyFrame other) {
        if (other == global::Protocol.MoveKeyFrame.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTime) {
          Time = other.Time;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        if (other.HasInTangent) {
          InTangent = other.InTangent;
        }
        if (other.HasOutTangent) {
          OutTangent = other.OutTangent;
        }
        if (other.HasInWeight) {
          InWeight = other.InWeight;
        }
        if (other.HasOutWeight) {
          OutWeight = other.OutWeight;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveKeyFrameFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveKeyFrameFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasTime = input.ReadFloat(ref result.time_);
              break;
            }
            case 21: {
              result.hasValue = input.ReadFloat(ref result.value_);
              break;
            }
            case 29: {
              result.hasInTangent = input.ReadFloat(ref result.inTangent_);
              break;
            }
            case 37: {
              result.hasOutTangent = input.ReadFloat(ref result.outTangent_);
              break;
            }
            case 45: {
              result.hasInWeight = input.ReadFloat(ref result.inWeight_);
              break;
            }
            case 53: {
              result.hasOutWeight = input.ReadFloat(ref result.outWeight_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTime {
        get { return result.hasTime; }
      }
      public float Time {
        get { return result.Time; }
        set { SetTime(value); }
      }
      public Builder SetTime(float value) {
        PrepareBuilder();
        result.hasTime = true;
        result.time_ = value;
        return this;
      }
      public Builder ClearTime() {
        PrepareBuilder();
        result.hasTime = false;
        result.time_ = 0F;
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public float Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(float value) {
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = 0F;
        return this;
      }
      
      public bool HasInTangent {
        get { return result.hasInTangent; }
      }
      public float InTangent {
        get { return result.InTangent; }
        set { SetInTangent(value); }
      }
      public Builder SetInTangent(float value) {
        PrepareBuilder();
        result.hasInTangent = true;
        result.inTangent_ = value;
        return this;
      }
      public Builder ClearInTangent() {
        PrepareBuilder();
        result.hasInTangent = false;
        result.inTangent_ = 0F;
        return this;
      }
      
      public bool HasOutTangent {
        get { return result.hasOutTangent; }
      }
      public float OutTangent {
        get { return result.OutTangent; }
        set { SetOutTangent(value); }
      }
      public Builder SetOutTangent(float value) {
        PrepareBuilder();
        result.hasOutTangent = true;
        result.outTangent_ = value;
        return this;
      }
      public Builder ClearOutTangent() {
        PrepareBuilder();
        result.hasOutTangent = false;
        result.outTangent_ = 0F;
        return this;
      }
      
      public bool HasInWeight {
        get { return result.hasInWeight; }
      }
      public float InWeight {
        get { return result.InWeight; }
        set { SetInWeight(value); }
      }
      public Builder SetInWeight(float value) {
        PrepareBuilder();
        result.hasInWeight = true;
        result.inWeight_ = value;
        return this;
      }
      public Builder ClearInWeight() {
        PrepareBuilder();
        result.hasInWeight = false;
        result.inWeight_ = 0F;
        return this;
      }
      
      public bool HasOutWeight {
        get { return result.hasOutWeight; }
      }
      public float OutWeight {
        get { return result.OutWeight; }
        set { SetOutWeight(value); }
      }
      public Builder SetOutWeight(float value) {
        PrepareBuilder();
        result.hasOutWeight = true;
        result.outWeight_ = value;
        return this;
      }
      public Builder ClearOutWeight() {
        PrepareBuilder();
        result.hasOutWeight = false;
        result.outWeight_ = 0F;
        return this;
      }
    }
    static MoveKeyFrame() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MoveMotion : pb::GeneratedMessage<MoveMotion, MoveMotion.Builder> {
    public MoveMotion() { }
    private static readonly MoveMotion defaultInstance = new MoveMotion().MakeReadOnly();
    private static readonly string[] _moveMotionFieldNames = new string[] { "frame_count", "is_loop", "length", "motion_name", "motion_type", "position_x_curve", "position_y_curve", "position_z_curve", "rotation_w_curve", "rotation_x_curve", "rotation_y_curve", "rotation_z_curve", "scale_x_curve", "scale_y_curve", "scale_z_curve" };
    private static readonly uint[] _moveMotionFieldTags = new uint[] { 176, 136, 8, 66, 168, 18, 74, 26, 58, 34, 42, 50, 146, 154, 162 };
    public static MoveMotion DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveMotion DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveMotion ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveMotion__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveMotion, MoveMotion.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveMotion__FieldAccessorTable; }
    }
    
    public const int LengthFieldNumber = 1;
    private bool hasLength;
    private bool isLengthChanged = true;
    private int length_;
    public bool HasLength {
      get { return hasLength; }
    }
    public int Length {
      get { return length_; }
      set { hasLength = true;
        isLengthChanged = true;
        length_ = value;}
    }
    
    public const int PositionXCurveFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> positionXCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> PositionXCurve {
      get { return pbc::Lists.AsReadOnly(positionXCurve_); }
    }
    public int PositionXCurveCount {
      get { return positionXCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetPositionXCurve(int index) {
      return positionXCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindPositionXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionXCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllPositionXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionXCurve_.FindAll(match);
    }
    public void SetPositionXCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= positionXCurve_.Count) return;
      positionXCurve_[index] = value;
    }
    public void AddPositionXCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      positionXCurve_.Add(value);
    }
    public void AddRangePositionXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      positionXCurve_.Add(values);
    }
    public void RemovePositionXCurve(global::Protocol.MoveKeyFrame value) {
      if (!positionXCurve_.Contains(value)) return;
      positionXCurve_.Remove(value);
    }
    public void RemoveAtPositionXCurve(int index) {
      if (index < 0 || index >= positionXCurve_.Count) return;
      positionXCurve_.RemoveAt(index);
    }
    public void ClearPositionXCurve() {
      if (positionXCurve_.Count <= 0) return;
      positionXCurve_.Clear();
    }
    
    public const int PositionZCurveFieldNumber = 3;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> positionZCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> PositionZCurve {
      get { return pbc::Lists.AsReadOnly(positionZCurve_); }
    }
    public int PositionZCurveCount {
      get { return positionZCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetPositionZCurve(int index) {
      return positionZCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindPositionZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionZCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllPositionZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionZCurve_.FindAll(match);
    }
    public void SetPositionZCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= positionZCurve_.Count) return;
      positionZCurve_[index] = value;
    }
    public void AddPositionZCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      positionZCurve_.Add(value);
    }
    public void AddRangePositionZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      positionZCurve_.Add(values);
    }
    public void RemovePositionZCurve(global::Protocol.MoveKeyFrame value) {
      if (!positionZCurve_.Contains(value)) return;
      positionZCurve_.Remove(value);
    }
    public void RemoveAtPositionZCurve(int index) {
      if (index < 0 || index >= positionZCurve_.Count) return;
      positionZCurve_.RemoveAt(index);
    }
    public void ClearPositionZCurve() {
      if (positionZCurve_.Count <= 0) return;
      positionZCurve_.Clear();
    }
    
    public const int RotationXCurveFieldNumber = 4;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> rotationXCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> RotationXCurve {
      get { return pbc::Lists.AsReadOnly(rotationXCurve_); }
    }
    public int RotationXCurveCount {
      get { return rotationXCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetRotationXCurve(int index) {
      return rotationXCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindRotationXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationXCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllRotationXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationXCurve_.FindAll(match);
    }
    public void SetRotationXCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= rotationXCurve_.Count) return;
      rotationXCurve_[index] = value;
    }
    public void AddRotationXCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      rotationXCurve_.Add(value);
    }
    public void AddRangeRotationXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      rotationXCurve_.Add(values);
    }
    public void RemoveRotationXCurve(global::Protocol.MoveKeyFrame value) {
      if (!rotationXCurve_.Contains(value)) return;
      rotationXCurve_.Remove(value);
    }
    public void RemoveAtRotationXCurve(int index) {
      if (index < 0 || index >= rotationXCurve_.Count) return;
      rotationXCurve_.RemoveAt(index);
    }
    public void ClearRotationXCurve() {
      if (rotationXCurve_.Count <= 0) return;
      rotationXCurve_.Clear();
    }
    
    public const int RotationYCurveFieldNumber = 5;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> rotationYCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> RotationYCurve {
      get { return pbc::Lists.AsReadOnly(rotationYCurve_); }
    }
    public int RotationYCurveCount {
      get { return rotationYCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetRotationYCurve(int index) {
      return rotationYCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindRotationYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationYCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllRotationYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationYCurve_.FindAll(match);
    }
    public void SetRotationYCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= rotationYCurve_.Count) return;
      rotationYCurve_[index] = value;
    }
    public void AddRotationYCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      rotationYCurve_.Add(value);
    }
    public void AddRangeRotationYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      rotationYCurve_.Add(values);
    }
    public void RemoveRotationYCurve(global::Protocol.MoveKeyFrame value) {
      if (!rotationYCurve_.Contains(value)) return;
      rotationYCurve_.Remove(value);
    }
    public void RemoveAtRotationYCurve(int index) {
      if (index < 0 || index >= rotationYCurve_.Count) return;
      rotationYCurve_.RemoveAt(index);
    }
    public void ClearRotationYCurve() {
      if (rotationYCurve_.Count <= 0) return;
      rotationYCurve_.Clear();
    }
    
    public const int RotationZCurveFieldNumber = 6;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> rotationZCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> RotationZCurve {
      get { return pbc::Lists.AsReadOnly(rotationZCurve_); }
    }
    public int RotationZCurveCount {
      get { return rotationZCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetRotationZCurve(int index) {
      return rotationZCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindRotationZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationZCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllRotationZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationZCurve_.FindAll(match);
    }
    public void SetRotationZCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= rotationZCurve_.Count) return;
      rotationZCurve_[index] = value;
    }
    public void AddRotationZCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      rotationZCurve_.Add(value);
    }
    public void AddRangeRotationZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      rotationZCurve_.Add(values);
    }
    public void RemoveRotationZCurve(global::Protocol.MoveKeyFrame value) {
      if (!rotationZCurve_.Contains(value)) return;
      rotationZCurve_.Remove(value);
    }
    public void RemoveAtRotationZCurve(int index) {
      if (index < 0 || index >= rotationZCurve_.Count) return;
      rotationZCurve_.RemoveAt(index);
    }
    public void ClearRotationZCurve() {
      if (rotationZCurve_.Count <= 0) return;
      rotationZCurve_.Clear();
    }
    
    public const int RotationWCurveFieldNumber = 7;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> rotationWCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> RotationWCurve {
      get { return pbc::Lists.AsReadOnly(rotationWCurve_); }
    }
    public int RotationWCurveCount {
      get { return rotationWCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetRotationWCurve(int index) {
      return rotationWCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindRotationWCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationWCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllRotationWCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return rotationWCurve_.FindAll(match);
    }
    public void SetRotationWCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= rotationWCurve_.Count) return;
      rotationWCurve_[index] = value;
    }
    public void AddRotationWCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      rotationWCurve_.Add(value);
    }
    public void AddRangeRotationWCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      rotationWCurve_.Add(values);
    }
    public void RemoveRotationWCurve(global::Protocol.MoveKeyFrame value) {
      if (!rotationWCurve_.Contains(value)) return;
      rotationWCurve_.Remove(value);
    }
    public void RemoveAtRotationWCurve(int index) {
      if (index < 0 || index >= rotationWCurve_.Count) return;
      rotationWCurve_.RemoveAt(index);
    }
    public void ClearRotationWCurve() {
      if (rotationWCurve_.Count <= 0) return;
      rotationWCurve_.Clear();
    }
    
    public const int MotionNameFieldNumber = 8;
    private bool hasMotionName;
    private bool isMotionNameChanged = true;
    private string motionName_ = "";
    public bool HasMotionName {
      get { return hasMotionName; }
    }
    public string MotionName {
      get { return motionName_; }
      set { hasMotionName = true;
        isMotionNameChanged = true;
        motionName_ = value;}
    }
    
    public const int PositionYCurveFieldNumber = 9;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> positionYCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> PositionYCurve {
      get { return pbc::Lists.AsReadOnly(positionYCurve_); }
    }
    public int PositionYCurveCount {
      get { return positionYCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetPositionYCurve(int index) {
      return positionYCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindPositionYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionYCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllPositionYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return positionYCurve_.FindAll(match);
    }
    public void SetPositionYCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= positionYCurve_.Count) return;
      positionYCurve_[index] = value;
    }
    public void AddPositionYCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      positionYCurve_.Add(value);
    }
    public void AddRangePositionYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      positionYCurve_.Add(values);
    }
    public void RemovePositionYCurve(global::Protocol.MoveKeyFrame value) {
      if (!positionYCurve_.Contains(value)) return;
      positionYCurve_.Remove(value);
    }
    public void RemoveAtPositionYCurve(int index) {
      if (index < 0 || index >= positionYCurve_.Count) return;
      positionYCurve_.RemoveAt(index);
    }
    public void ClearPositionYCurve() {
      if (positionYCurve_.Count <= 0) return;
      positionYCurve_.Clear();
    }
    
    public const int IsLoopFieldNumber = 17;
    private bool hasIsLoop;
    private bool isIsLoopChanged = true;
    private bool isLoop_;
    public bool HasIsLoop {
      get { return hasIsLoop; }
    }
    public bool IsLoop {
      get { return isLoop_; }
      set { hasIsLoop = true;
        isIsLoopChanged = true;
        isLoop_ = value;}
    }
    
    public const int ScaleXCurveFieldNumber = 18;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> scaleXCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> ScaleXCurve {
      get { return pbc::Lists.AsReadOnly(scaleXCurve_); }
    }
    public int ScaleXCurveCount {
      get { return scaleXCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetScaleXCurve(int index) {
      return scaleXCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindScaleXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleXCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllScaleXCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleXCurve_.FindAll(match);
    }
    public void SetScaleXCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= scaleXCurve_.Count) return;
      scaleXCurve_[index] = value;
    }
    public void AddScaleXCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      scaleXCurve_.Add(value);
    }
    public void AddRangeScaleXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      scaleXCurve_.Add(values);
    }
    public void RemoveScaleXCurve(global::Protocol.MoveKeyFrame value) {
      if (!scaleXCurve_.Contains(value)) return;
      scaleXCurve_.Remove(value);
    }
    public void RemoveAtScaleXCurve(int index) {
      if (index < 0 || index >= scaleXCurve_.Count) return;
      scaleXCurve_.RemoveAt(index);
    }
    public void ClearScaleXCurve() {
      if (scaleXCurve_.Count <= 0) return;
      scaleXCurve_.Clear();
    }
    
    public const int ScaleYCurveFieldNumber = 19;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> scaleYCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> ScaleYCurve {
      get { return pbc::Lists.AsReadOnly(scaleYCurve_); }
    }
    public int ScaleYCurveCount {
      get { return scaleYCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetScaleYCurve(int index) {
      return scaleYCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindScaleYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleYCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllScaleYCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleYCurve_.FindAll(match);
    }
    public void SetScaleYCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= scaleYCurve_.Count) return;
      scaleYCurve_[index] = value;
    }
    public void AddScaleYCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      scaleYCurve_.Add(value);
    }
    public void AddRangeScaleYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      scaleYCurve_.Add(values);
    }
    public void RemoveScaleYCurve(global::Protocol.MoveKeyFrame value) {
      if (!scaleYCurve_.Contains(value)) return;
      scaleYCurve_.Remove(value);
    }
    public void RemoveAtScaleYCurve(int index) {
      if (index < 0 || index >= scaleYCurve_.Count) return;
      scaleYCurve_.RemoveAt(index);
    }
    public void ClearScaleYCurve() {
      if (scaleYCurve_.Count <= 0) return;
      scaleYCurve_.Clear();
    }
    
    public const int ScaleZCurveFieldNumber = 20;
    private pbc::PopsicleList<global::Protocol.MoveKeyFrame> scaleZCurve_ = new pbc::PopsicleList<global::Protocol.MoveKeyFrame>();
    public scg::IList<global::Protocol.MoveKeyFrame> ScaleZCurve {
      get { return pbc::Lists.AsReadOnly(scaleZCurve_); }
    }
    public int ScaleZCurveCount {
      get { return scaleZCurve_.Count; }
    }
    public global::Protocol.MoveKeyFrame GetScaleZCurve(int index) {
      return scaleZCurve_[index];
    }
    public global::Protocol.MoveKeyFrame FindScaleZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleZCurve_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveKeyFrame> FindAllScaleZCurve(System.Predicate<global::Protocol.MoveKeyFrame> match) {
      return scaleZCurve_.FindAll(match);
    }
    public void SetScaleZCurve(int index, global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= scaleZCurve_.Count) return;
      scaleZCurve_[index] = value;
    }
    public void AddScaleZCurve(global::Protocol.MoveKeyFrame value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      scaleZCurve_.Add(value);
    }
    public void AddRangeScaleZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
      scaleZCurve_.Add(values);
    }
    public void RemoveScaleZCurve(global::Protocol.MoveKeyFrame value) {
      if (!scaleZCurve_.Contains(value)) return;
      scaleZCurve_.Remove(value);
    }
    public void RemoveAtScaleZCurve(int index) {
      if (index < 0 || index >= scaleZCurve_.Count) return;
      scaleZCurve_.RemoveAt(index);
    }
    public void ClearScaleZCurve() {
      if (scaleZCurve_.Count <= 0) return;
      scaleZCurve_.Clear();
    }
    
    public const int MotionTypeFieldNumber = 21;
    private bool hasMotionType;
    private bool isMotionTypeChanged = true;
    private uint motionType_;
    public bool HasMotionType {
      get { return hasMotionType; }
    }
    [global::System.CLSCompliant(false)]
    public uint MotionType {
      get { return motionType_; }
      set { hasMotionType = true;
        isMotionTypeChanged = true;
        motionType_ = value;}
    }
    
    public const int FrameCountFieldNumber = 22;
    private bool hasFrameCount;
    private bool isFrameCountChanged = true;
    private int frameCount_;
    public bool HasFrameCount {
      get { return hasFrameCount; }
    }
    public int FrameCount {
      get { return frameCount_; }
      set { hasFrameCount = true;
        isFrameCountChanged = true;
        frameCount_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _moveMotionFieldNames;
      if (hasLength) {
        output.WriteInt32(1, field_names[2], Length);
      }
      if (positionXCurve_.Count > 0) {
        output.WriteMessageArray(2, field_names[5], positionXCurve_);
      }
      if (positionZCurve_.Count > 0) {
        output.WriteMessageArray(3, field_names[7], positionZCurve_);
      }
      if (rotationXCurve_.Count > 0) {
        output.WriteMessageArray(4, field_names[9], rotationXCurve_);
      }
      if (rotationYCurve_.Count > 0) {
        output.WriteMessageArray(5, field_names[10], rotationYCurve_);
      }
      if (rotationZCurve_.Count > 0) {
        output.WriteMessageArray(6, field_names[11], rotationZCurve_);
      }
      if (rotationWCurve_.Count > 0) {
        output.WriteMessageArray(7, field_names[8], rotationWCurve_);
      }
      if (hasMotionName) {
        output.WriteString(8, field_names[3], MotionName);
      }
      if (positionYCurve_.Count > 0) {
        output.WriteMessageArray(9, field_names[6], positionYCurve_);
      }
      if (hasIsLoop) {
        output.WriteBool(17, field_names[1], IsLoop);
      }
      if (scaleXCurve_.Count > 0) {
        output.WriteMessageArray(18, field_names[12], scaleXCurve_);
      }
      if (scaleYCurve_.Count > 0) {
        output.WriteMessageArray(19, field_names[13], scaleYCurve_);
      }
      if (scaleZCurve_.Count > 0) {
        output.WriteMessageArray(20, field_names[14], scaleZCurve_);
      }
      if (hasMotionType) {
        output.WriteUInt32(21, field_names[4], MotionType);
      }
      if (hasFrameCount) {
        output.WriteInt32(22, field_names[0], FrameCount);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasLength) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Length);
      }
      foreach (global::Protocol.MoveKeyFrame element in PositionXCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in PositionZCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in RotationXCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in RotationYCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in RotationZCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in RotationWCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(7, element);
      }
      if (hasMotionName) {
        size += pb::CodedOutputStream.ComputeStringSize(8, MotionName);
      }
      foreach (global::Protocol.MoveKeyFrame element in PositionYCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, element);
      }
      if (hasIsLoop) {
        size += pb::CodedOutputStream.ComputeBoolSize(17, IsLoop);
      }
      foreach (global::Protocol.MoveKeyFrame element in ScaleXCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(18, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in ScaleYCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(19, element);
      }
      foreach (global::Protocol.MoveKeyFrame element in ScaleZCurve) {
        size += pb::CodedOutputStream.ComputeMessageSize(20, element);
      }
      if (hasMotionType) {
        size += pb::CodedOutputStream.ComputeUInt32Size(21, MotionType);
      }
      if (hasFrameCount) {
        size += pb::CodedOutputStream.ComputeInt32Size(22, FrameCount);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public MoveMotion CommitChange() {
      MoveMotion other = new MoveMotion();
      bool isChange = false;
      if (isLengthChanged) {
        isChange = true;
        other.Length = Length;
        isLengthChanged = false;
      }
      isChange = true;
      other.positionXCurve_.Add(positionXCurve_);
      isChange = true;
      other.positionZCurve_.Add(positionZCurve_);
      isChange = true;
      other.rotationXCurve_.Add(rotationXCurve_);
      isChange = true;
      other.rotationYCurve_.Add(rotationYCurve_);
      isChange = true;
      other.rotationZCurve_.Add(rotationZCurve_);
      isChange = true;
      other.rotationWCurve_.Add(rotationWCurve_);
      if (isMotionNameChanged) {
        isChange = true;
        other.MotionName = MotionName;
        isMotionNameChanged = false;
      }
      isChange = true;
      other.positionYCurve_.Add(positionYCurve_);
      if (isIsLoopChanged) {
        isChange = true;
        other.IsLoop = IsLoop;
        isIsLoopChanged = false;
      }
      isChange = true;
      other.scaleXCurve_.Add(scaleXCurve_);
      isChange = true;
      other.scaleYCurve_.Add(scaleYCurve_);
      isChange = true;
      other.scaleZCurve_.Add(scaleZCurve_);
      if (isMotionTypeChanged) {
        isChange = true;
        other.MotionType = MotionType;
        isMotionTypeChanged = false;
      }
      if (isFrameCountChanged) {
        isChange = true;
        other.FrameCount = FrameCount;
        isFrameCountChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(MoveMotion other, bool isFull = false) {
      if (other == global::Protocol.MoveMotion.DefaultInstance) return;
      if (other.HasLength) {
        Length = other.Length;
      }
        positionXCurve_.Clear();
        positionXCurve_.Add(other.positionXCurve_);
        positionZCurve_.Clear();
        positionZCurve_.Add(other.positionZCurve_);
        rotationXCurve_.Clear();
        rotationXCurve_.Add(other.rotationXCurve_);
        rotationYCurve_.Clear();
        rotationYCurve_.Add(other.rotationYCurve_);
        rotationZCurve_.Clear();
        rotationZCurve_.Add(other.rotationZCurve_);
        rotationWCurve_.Clear();
        rotationWCurve_.Add(other.rotationWCurve_);
      if (other.HasMotionName) {
        MotionName = other.MotionName;
      }
        positionYCurve_.Clear();
        positionYCurve_.Add(other.positionYCurve_);
      if (other.HasIsLoop) {
        IsLoop = other.IsLoop;
      }
        scaleXCurve_.Clear();
        scaleXCurve_.Add(other.scaleXCurve_);
        scaleYCurve_.Clear();
        scaleYCurve_.Add(other.scaleYCurve_);
        scaleZCurve_.Clear();
        scaleZCurve_.Add(other.scaleZCurve_);
      if (other.HasMotionType) {
        MotionType = other.MotionType;
      }
      if (other.HasFrameCount) {
        FrameCount = other.FrameCount;
      }
    }
    
    public static MoveMotion ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveMotion ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveMotion ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveMotion ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveMotion ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveMotion ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveMotion ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveMotion ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveMotion ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveMotion ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveMotion MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveMotion prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveMotion, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveMotion cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveMotion result;
      
      private MoveMotion PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveMotion original = result;
          result = new MoveMotion();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveMotion MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.MoveMotion.Descriptor; }
      }
      
      public override MoveMotion DefaultInstanceForType {
        get { return global::Protocol.MoveMotion.DefaultInstance; }
      }
      
      public override MoveMotion BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveMotion) {
          return MergeFrom((MoveMotion) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveMotion other) {
        if (other == global::Protocol.MoveMotion.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLength) {
          Length = other.Length;
        }
        if (other.positionXCurve_.Count != 0) {
          result.positionXCurve_.Add(other.positionXCurve_);
        }
        if (other.positionZCurve_.Count != 0) {
          result.positionZCurve_.Add(other.positionZCurve_);
        }
        if (other.rotationXCurve_.Count != 0) {
          result.rotationXCurve_.Add(other.rotationXCurve_);
        }
        if (other.rotationYCurve_.Count != 0) {
          result.rotationYCurve_.Add(other.rotationYCurve_);
        }
        if (other.rotationZCurve_.Count != 0) {
          result.rotationZCurve_.Add(other.rotationZCurve_);
        }
        if (other.rotationWCurve_.Count != 0) {
          result.rotationWCurve_.Add(other.rotationWCurve_);
        }
        if (other.HasMotionName) {
          MotionName = other.MotionName;
        }
        if (other.positionYCurve_.Count != 0) {
          result.positionYCurve_.Add(other.positionYCurve_);
        }
        if (other.HasIsLoop) {
          IsLoop = other.IsLoop;
        }
        if (other.scaleXCurve_.Count != 0) {
          result.scaleXCurve_.Add(other.scaleXCurve_);
        }
        if (other.scaleYCurve_.Count != 0) {
          result.scaleYCurve_.Add(other.scaleYCurve_);
        }
        if (other.scaleZCurve_.Count != 0) {
          result.scaleZCurve_.Add(other.scaleZCurve_);
        }
        if (other.HasMotionType) {
          MotionType = other.MotionType;
        }
        if (other.HasFrameCount) {
          FrameCount = other.FrameCount;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveMotionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveMotionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLength = input.ReadInt32(ref result.length_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.positionXCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.positionZCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              input.ReadMessageArray(tag, field_name, result.rotationXCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 42: {
              input.ReadMessageArray(tag, field_name, result.rotationYCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 50: {
              input.ReadMessageArray(tag, field_name, result.rotationZCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 58: {
              input.ReadMessageArray(tag, field_name, result.rotationWCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 66: {
              result.hasMotionName = input.ReadString(ref result.motionName_);
              break;
            }
            case 74: {
              input.ReadMessageArray(tag, field_name, result.positionYCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 136: {
              result.hasIsLoop = input.ReadBool(ref result.isLoop_);
              break;
            }
            case 146: {
              input.ReadMessageArray(tag, field_name, result.scaleXCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 154: {
              input.ReadMessageArray(tag, field_name, result.scaleYCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 162: {
              input.ReadMessageArray(tag, field_name, result.scaleZCurve_, global::Protocol.MoveKeyFrame.DefaultInstance, extensionRegistry);
              break;
            }
            case 168: {
              result.hasMotionType = input.ReadUInt32(ref result.motionType_);
              break;
            }
            case 176: {
              result.hasFrameCount = input.ReadInt32(ref result.frameCount_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLength {
        get { return result.hasLength; }
      }
      public int Length {
        get { return result.Length; }
        set { SetLength(value); }
      }
      public Builder SetLength(int value) {
        PrepareBuilder();
        result.hasLength = true;
        result.length_ = value;
        return this;
      }
      public Builder ClearLength() {
        PrepareBuilder();
        result.hasLength = false;
        result.length_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> PositionXCurve {
        get { return PrepareBuilder().positionXCurve_; }
      }
      public int PositionXCurveCount {
        get { return result.PositionXCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetPositionXCurve(int index) {
        return result.GetPositionXCurve(index);
      }
      public Builder SetPositionXCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionXCurve_[index] = value;
        return this;
      }
      public Builder SetPositionXCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionXCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPositionXCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionXCurve_.Add(value);
        return this;
      }
      public Builder AddPositionXCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionXCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePositionXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.positionXCurve_.Add(values);
        return this;
      }
      public Builder ClearPositionXCurve() {
        PrepareBuilder();
        result.positionXCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> PositionZCurve {
        get { return PrepareBuilder().positionZCurve_; }
      }
      public int PositionZCurveCount {
        get { return result.PositionZCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetPositionZCurve(int index) {
        return result.GetPositionZCurve(index);
      }
      public Builder SetPositionZCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionZCurve_[index] = value;
        return this;
      }
      public Builder SetPositionZCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionZCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPositionZCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionZCurve_.Add(value);
        return this;
      }
      public Builder AddPositionZCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionZCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePositionZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.positionZCurve_.Add(values);
        return this;
      }
      public Builder ClearPositionZCurve() {
        PrepareBuilder();
        result.positionZCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> RotationXCurve {
        get { return PrepareBuilder().rotationXCurve_; }
      }
      public int RotationXCurveCount {
        get { return result.RotationXCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetRotationXCurve(int index) {
        return result.GetRotationXCurve(index);
      }
      public Builder SetRotationXCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationXCurve_[index] = value;
        return this;
      }
      public Builder SetRotationXCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationXCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRotationXCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationXCurve_.Add(value);
        return this;
      }
      public Builder AddRotationXCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationXCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRotationXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.rotationXCurve_.Add(values);
        return this;
      }
      public Builder ClearRotationXCurve() {
        PrepareBuilder();
        result.rotationXCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> RotationYCurve {
        get { return PrepareBuilder().rotationYCurve_; }
      }
      public int RotationYCurveCount {
        get { return result.RotationYCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetRotationYCurve(int index) {
        return result.GetRotationYCurve(index);
      }
      public Builder SetRotationYCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationYCurve_[index] = value;
        return this;
      }
      public Builder SetRotationYCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationYCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRotationYCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationYCurve_.Add(value);
        return this;
      }
      public Builder AddRotationYCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationYCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRotationYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.rotationYCurve_.Add(values);
        return this;
      }
      public Builder ClearRotationYCurve() {
        PrepareBuilder();
        result.rotationYCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> RotationZCurve {
        get { return PrepareBuilder().rotationZCurve_; }
      }
      public int RotationZCurveCount {
        get { return result.RotationZCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetRotationZCurve(int index) {
        return result.GetRotationZCurve(index);
      }
      public Builder SetRotationZCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationZCurve_[index] = value;
        return this;
      }
      public Builder SetRotationZCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationZCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRotationZCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationZCurve_.Add(value);
        return this;
      }
      public Builder AddRotationZCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationZCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRotationZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.rotationZCurve_.Add(values);
        return this;
      }
      public Builder ClearRotationZCurve() {
        PrepareBuilder();
        result.rotationZCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> RotationWCurve {
        get { return PrepareBuilder().rotationWCurve_; }
      }
      public int RotationWCurveCount {
        get { return result.RotationWCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetRotationWCurve(int index) {
        return result.GetRotationWCurve(index);
      }
      public Builder SetRotationWCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationWCurve_[index] = value;
        return this;
      }
      public Builder SetRotationWCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationWCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRotationWCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rotationWCurve_.Add(value);
        return this;
      }
      public Builder AddRotationWCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rotationWCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRotationWCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.rotationWCurve_.Add(values);
        return this;
      }
      public Builder ClearRotationWCurve() {
        PrepareBuilder();
        result.rotationWCurve_.Clear();
        return this;
      }
      
      public bool HasMotionName {
        get { return result.hasMotionName; }
      }
      public string MotionName {
        get { return result.MotionName; }
        set { SetMotionName(value); }
      }
      public Builder SetMotionName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMotionName = true;
        result.motionName_ = value;
        return this;
      }
      public Builder ClearMotionName() {
        PrepareBuilder();
        result.hasMotionName = false;
        result.motionName_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> PositionYCurve {
        get { return PrepareBuilder().positionYCurve_; }
      }
      public int PositionYCurveCount {
        get { return result.PositionYCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetPositionYCurve(int index) {
        return result.GetPositionYCurve(index);
      }
      public Builder SetPositionYCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionYCurve_[index] = value;
        return this;
      }
      public Builder SetPositionYCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionYCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPositionYCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.positionYCurve_.Add(value);
        return this;
      }
      public Builder AddPositionYCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.positionYCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePositionYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.positionYCurve_.Add(values);
        return this;
      }
      public Builder ClearPositionYCurve() {
        PrepareBuilder();
        result.positionYCurve_.Clear();
        return this;
      }
      
      public bool HasIsLoop {
        get { return result.hasIsLoop; }
      }
      public bool IsLoop {
        get { return result.IsLoop; }
        set { SetIsLoop(value); }
      }
      public Builder SetIsLoop(bool value) {
        PrepareBuilder();
        result.hasIsLoop = true;
        result.isLoop_ = value;
        return this;
      }
      public Builder ClearIsLoop() {
        PrepareBuilder();
        result.hasIsLoop = false;
        result.isLoop_ = false;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> ScaleXCurve {
        get { return PrepareBuilder().scaleXCurve_; }
      }
      public int ScaleXCurveCount {
        get { return result.ScaleXCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetScaleXCurve(int index) {
        return result.GetScaleXCurve(index);
      }
      public Builder SetScaleXCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleXCurve_[index] = value;
        return this;
      }
      public Builder SetScaleXCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleXCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddScaleXCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleXCurve_.Add(value);
        return this;
      }
      public Builder AddScaleXCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleXCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeScaleXCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.scaleXCurve_.Add(values);
        return this;
      }
      public Builder ClearScaleXCurve() {
        PrepareBuilder();
        result.scaleXCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> ScaleYCurve {
        get { return PrepareBuilder().scaleYCurve_; }
      }
      public int ScaleYCurveCount {
        get { return result.ScaleYCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetScaleYCurve(int index) {
        return result.GetScaleYCurve(index);
      }
      public Builder SetScaleYCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleYCurve_[index] = value;
        return this;
      }
      public Builder SetScaleYCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleYCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddScaleYCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleYCurve_.Add(value);
        return this;
      }
      public Builder AddScaleYCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleYCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeScaleYCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.scaleYCurve_.Add(values);
        return this;
      }
      public Builder ClearScaleYCurve() {
        PrepareBuilder();
        result.scaleYCurve_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.MoveKeyFrame> ScaleZCurve {
        get { return PrepareBuilder().scaleZCurve_; }
      }
      public int ScaleZCurveCount {
        get { return result.ScaleZCurveCount; }
      }
      public global::Protocol.MoveKeyFrame GetScaleZCurve(int index) {
        return result.GetScaleZCurve(index);
      }
      public Builder SetScaleZCurve(int index, global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleZCurve_[index] = value;
        return this;
      }
      public Builder SetScaleZCurve(int index, global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleZCurve_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddScaleZCurve(global::Protocol.MoveKeyFrame value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.scaleZCurve_.Add(value);
        return this;
      }
      public Builder AddScaleZCurve(global::Protocol.MoveKeyFrame.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.scaleZCurve_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeScaleZCurve(scg::IEnumerable<global::Protocol.MoveKeyFrame> values) {
        PrepareBuilder();
        result.scaleZCurve_.Add(values);
        return this;
      }
      public Builder ClearScaleZCurve() {
        PrepareBuilder();
        result.scaleZCurve_.Clear();
        return this;
      }
      
      public bool HasMotionType {
        get { return result.hasMotionType; }
      }
      [global::System.CLSCompliant(false)]
      public uint MotionType {
        get { return result.MotionType; }
        set { SetMotionType(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetMotionType(uint value) {
        PrepareBuilder();
        result.hasMotionType = true;
        result.motionType_ = value;
        return this;
      }
      public Builder ClearMotionType() {
        PrepareBuilder();
        result.hasMotionType = false;
        result.motionType_ = 0;
        return this;
      }
      
      public bool HasFrameCount {
        get { return result.hasFrameCount; }
      }
      public int FrameCount {
        get { return result.FrameCount; }
        set { SetFrameCount(value); }
      }
      public Builder SetFrameCount(int value) {
        PrepareBuilder();
        result.hasFrameCount = true;
        result.frameCount_ = value;
        return this;
      }
      public Builder ClearFrameCount() {
        PrepareBuilder();
        result.hasFrameCount = false;
        result.frameCount_ = 0;
        return this;
      }
    }
    static MoveMotion() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class BlendNode : pb::GeneratedMessage<BlendNode, BlendNode.Builder> {
    public BlendNode() { }
    private static readonly BlendNode defaultInstance = new BlendNode().MakeReadOnly();
    private static readonly string[] _blendNodeFieldNames = new string[] { "angle_speed", "bound_center", "bound_size", "frame_count", "head_position", "head_rotation", "is_addtion", "length", "motion", "move_dir", "move_speed", "x_postion", "y_postion" };
    private static readonly uint[] _blendNodeFieldTags = new uint[] { 21, 74, 82, 104, 90, 98, 56, 53, 66, 42, 13, 29, 37 };
    public static BlendNode DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BlendNode DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BlendNode ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BlendNode__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BlendNode, BlendNode.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_BlendNode__FieldAccessorTable; }
    }
    
    public const int MoveSpeedFieldNumber = 1;
    private bool hasMoveSpeed;
    private bool isMoveSpeedChanged = true;
    private float moveSpeed_;
    public bool HasMoveSpeed {
      get { return hasMoveSpeed; }
    }
    public float MoveSpeed {
      get { return moveSpeed_; }
      set { hasMoveSpeed = true;
        isMoveSpeedChanged = true;
        moveSpeed_ = value;}
    }
    
    public const int AngleSpeedFieldNumber = 2;
    private bool hasAngleSpeed;
    private bool isAngleSpeedChanged = true;
    private float angleSpeed_;
    public bool HasAngleSpeed {
      get { return hasAngleSpeed; }
    }
    public float AngleSpeed {
      get { return angleSpeed_; }
      set { hasAngleSpeed = true;
        isAngleSpeedChanged = true;
        angleSpeed_ = value;}
    }
    
    public const int XPostionFieldNumber = 3;
    private bool hasXPostion;
    private bool isXPostionChanged = true;
    private float xPostion_;
    public bool HasXPostion {
      get { return hasXPostion; }
    }
    public float XPostion {
      get { return xPostion_; }
      set { hasXPostion = true;
        isXPostionChanged = true;
        xPostion_ = value;}
    }
    
    public const int YPostionFieldNumber = 4;
    private bool hasYPostion;
    private bool isYPostionChanged = true;
    private float yPostion_;
    public bool HasYPostion {
      get { return hasYPostion; }
    }
    public float YPostion {
      get { return yPostion_; }
      set { hasYPostion = true;
        isYPostionChanged = true;
        yPostion_ = value;}
    }
    
    public const int MoveDirFieldNumber = 5;
    private bool hasMoveDir;
    private global::Protocol.Float3 moveDir_;
    public bool HasMoveDir {
      get { return hasMoveDir; }
    }
    public global::Protocol.Float3 MoveDir {
      get { return moveDir_; }
      set { hasMoveDir = true;
        moveDir_ = value;}
    }
    public void MergeMoveDir(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasMoveDir &&
        moveDir_ != global::Protocol.Float3.DefaultInstance) {
        moveDir_.MergeFrom(value, isFull);
      } else {
        moveDir_ = value;
      }
    }
    
    public const int LengthFieldNumber = 6;
    private bool hasLength;
    private bool isLengthChanged = true;
    private float length_;
    public bool HasLength {
      get { return hasLength; }
    }
    public float Length {
      get { return length_; }
      set { hasLength = true;
        isLengthChanged = true;
        length_ = value;}
    }
    
    public const int IsAddtionFieldNumber = 7;
    private bool hasIsAddtion;
    private bool isIsAddtionChanged = true;
    private bool isAddtion_;
    public bool HasIsAddtion {
      get { return hasIsAddtion; }
    }
    public bool IsAddtion {
      get { return isAddtion_; }
      set { hasIsAddtion = true;
        isIsAddtionChanged = true;
        isAddtion_ = value;}
    }
    
    public const int MotionFieldNumber = 8;
    private bool hasMotion;
    private global::Protocol.MoveMotion motion_;
    public bool HasMotion {
      get { return hasMotion; }
    }
    public global::Protocol.MoveMotion Motion {
      get { return motion_; }
      set { hasMotion = true;
        motion_ = value;}
    }
    public void MergeMotion(global::Protocol.MoveMotion value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasMotion &&
        motion_ != global::Protocol.MoveMotion.DefaultInstance) {
        motion_.MergeFrom(value, isFull);
      } else {
        motion_ = value;
      }
    }
    
    public const int BoundCenterFieldNumber = 9;
    private bool hasBoundCenter;
    private global::Protocol.Float3 boundCenter_;
    public bool HasBoundCenter {
      get { return hasBoundCenter; }
    }
    public global::Protocol.Float3 BoundCenter {
      get { return boundCenter_; }
      set { hasBoundCenter = true;
        boundCenter_ = value;}
    }
    public void MergeBoundCenter(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasBoundCenter &&
        boundCenter_ != global::Protocol.Float3.DefaultInstance) {
        boundCenter_.MergeFrom(value, isFull);
      } else {
        boundCenter_ = value;
      }
    }
    
    public const int BoundSizeFieldNumber = 10;
    private bool hasBoundSize;
    private global::Protocol.Float3 boundSize_;
    public bool HasBoundSize {
      get { return hasBoundSize; }
    }
    public global::Protocol.Float3 BoundSize {
      get { return boundSize_; }
      set { hasBoundSize = true;
        boundSize_ = value;}
    }
    public void MergeBoundSize(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasBoundSize &&
        boundSize_ != global::Protocol.Float3.DefaultInstance) {
        boundSize_.MergeFrom(value, isFull);
      } else {
        boundSize_ = value;
      }
    }
    
    public const int HeadPositionFieldNumber = 11;
    private bool hasHeadPosition;
    private global::Protocol.Float3 headPosition_;
    public bool HasHeadPosition {
      get { return hasHeadPosition; }
    }
    public global::Protocol.Float3 HeadPosition {
      get { return headPosition_; }
      set { hasHeadPosition = true;
        headPosition_ = value;}
    }
    public void MergeHeadPosition(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasHeadPosition &&
        headPosition_ != global::Protocol.Float3.DefaultInstance) {
        headPosition_.MergeFrom(value, isFull);
      } else {
        headPosition_ = value;
      }
    }
    
    public const int HeadRotationFieldNumber = 12;
    private bool hasHeadRotation;
    private global::Protocol.Float3 headRotation_;
    public bool HasHeadRotation {
      get { return hasHeadRotation; }
    }
    public global::Protocol.Float3 HeadRotation {
      get { return headRotation_; }
      set { hasHeadRotation = true;
        headRotation_ = value;}
    }
    public void MergeHeadRotation(global::Protocol.Float3 value, bool isFull = false) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (HasHeadRotation &&
        headRotation_ != global::Protocol.Float3.DefaultInstance) {
        headRotation_.MergeFrom(value, isFull);
      } else {
        headRotation_ = value;
      }
    }
    
    public const int FrameCountFieldNumber = 13;
    private bool hasFrameCount;
    private bool isFrameCountChanged = true;
    private int frameCount_;
    public bool HasFrameCount {
      get { return hasFrameCount; }
    }
    public int FrameCount {
      get { return frameCount_; }
      set { hasFrameCount = true;
        isFrameCountChanged = true;
        frameCount_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _blendNodeFieldNames;
      if (hasMoveSpeed) {
        output.WriteFloat(1, field_names[10], MoveSpeed);
      }
      if (hasAngleSpeed) {
        output.WriteFloat(2, field_names[0], AngleSpeed);
      }
      if (hasXPostion) {
        output.WriteFloat(3, field_names[11], XPostion);
      }
      if (hasYPostion) {
        output.WriteFloat(4, field_names[12], YPostion);
      }
      if (hasMoveDir) {
        output.WriteMessage(5, field_names[9], MoveDir);
      }
      if (hasLength) {
        output.WriteFloat(6, field_names[7], Length);
      }
      if (hasIsAddtion) {
        output.WriteBool(7, field_names[6], IsAddtion);
      }
      if (hasMotion) {
        output.WriteMessage(8, field_names[8], Motion);
      }
      if (hasBoundCenter) {
        output.WriteMessage(9, field_names[1], BoundCenter);
      }
      if (hasBoundSize) {
        output.WriteMessage(10, field_names[2], BoundSize);
      }
      if (hasHeadPosition) {
        output.WriteMessage(11, field_names[4], HeadPosition);
      }
      if (hasHeadRotation) {
        output.WriteMessage(12, field_names[5], HeadRotation);
      }
      if (hasFrameCount) {
        output.WriteInt32(13, field_names[3], FrameCount);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasMoveSpeed) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, MoveSpeed);
      }
      if (hasAngleSpeed) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, AngleSpeed);
      }
      if (hasXPostion) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, XPostion);
      }
      if (hasYPostion) {
        size += pb::CodedOutputStream.ComputeFloatSize(4, YPostion);
      }
      if (hasMoveDir) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, MoveDir);
      }
      if (hasLength) {
        size += pb::CodedOutputStream.ComputeFloatSize(6, Length);
      }
      if (hasIsAddtion) {
        size += pb::CodedOutputStream.ComputeBoolSize(7, IsAddtion);
      }
      if (hasMotion) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, Motion);
      }
      if (hasBoundCenter) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, BoundCenter);
      }
      if (hasBoundSize) {
        size += pb::CodedOutputStream.ComputeMessageSize(10, BoundSize);
      }
      if (hasHeadPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(11, HeadPosition);
      }
      if (hasHeadRotation) {
        size += pb::CodedOutputStream.ComputeMessageSize(12, HeadRotation);
      }
      if (hasFrameCount) {
        size += pb::CodedOutputStream.ComputeInt32Size(13, FrameCount);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public BlendNode CommitChange() {
      BlendNode other = new BlendNode();
      bool isChange = false;
      if (isMoveSpeedChanged) {
        isChange = true;
        other.MoveSpeed = MoveSpeed;
        isMoveSpeedChanged = false;
      }
      if (isAngleSpeedChanged) {
        isChange = true;
        other.AngleSpeed = AngleSpeed;
        isAngleSpeedChanged = false;
      }
      if (isXPostionChanged) {
        isChange = true;
        other.XPostion = XPostion;
        isXPostionChanged = false;
      }
      if (isYPostionChanged) {
        isChange = true;
        other.YPostion = YPostion;
        isYPostionChanged = false;
      }
      
      var MoveDircommit = MoveDir?.CommitChange();
      if(MoveDircommit!=null)
      {
          isChange = true;
          other.MoveDir = MoveDircommit;
      }
      if (isLengthChanged) {
        isChange = true;
        other.Length = Length;
        isLengthChanged = false;
      }
      if (isIsAddtionChanged) {
        isChange = true;
        other.IsAddtion = IsAddtion;
        isIsAddtionChanged = false;
      }
      
      var Motioncommit = Motion?.CommitChange();
      if(Motioncommit!=null)
      {
          isChange = true;
          other.Motion = Motioncommit;
      }
      
      var BoundCentercommit = BoundCenter?.CommitChange();
      if(BoundCentercommit!=null)
      {
          isChange = true;
          other.BoundCenter = BoundCentercommit;
      }
      
      var BoundSizecommit = BoundSize?.CommitChange();
      if(BoundSizecommit!=null)
      {
          isChange = true;
          other.BoundSize = BoundSizecommit;
      }
      
      var HeadPositioncommit = HeadPosition?.CommitChange();
      if(HeadPositioncommit!=null)
      {
          isChange = true;
          other.HeadPosition = HeadPositioncommit;
      }
      
      var HeadRotationcommit = HeadRotation?.CommitChange();
      if(HeadRotationcommit!=null)
      {
          isChange = true;
          other.HeadRotation = HeadRotationcommit;
      }
      if (isFrameCountChanged) {
        isChange = true;
        other.FrameCount = FrameCount;
        isFrameCountChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(BlendNode other, bool isFull = false) {
      if (other == global::Protocol.BlendNode.DefaultInstance) return;
      if (other.HasMoveSpeed) {
        MoveSpeed = other.MoveSpeed;
      }
      if (other.HasAngleSpeed) {
        AngleSpeed = other.AngleSpeed;
      }
      if (other.HasXPostion) {
        XPostion = other.XPostion;
      }
      if (other.HasYPostion) {
        YPostion = other.YPostion;
      }
      
      if (other.HasMoveDir)
      {
        MergeMoveDir(other.MoveDir, isFull);
      }
      if (other.HasLength) {
        Length = other.Length;
      }
      if (other.HasIsAddtion) {
        IsAddtion = other.IsAddtion;
      }
      
      if (other.HasMotion)
      {
        MergeMotion(other.Motion, isFull);
      }
      
      if (other.HasBoundCenter)
      {
        MergeBoundCenter(other.BoundCenter, isFull);
      }
      
      if (other.HasBoundSize)
      {
        MergeBoundSize(other.BoundSize, isFull);
      }
      
      if (other.HasHeadPosition)
      {
        MergeHeadPosition(other.HeadPosition, isFull);
      }
      
      if (other.HasHeadRotation)
      {
        MergeHeadRotation(other.HeadRotation, isFull);
      }
      if (other.HasFrameCount) {
        FrameCount = other.FrameCount;
      }
    }
    
    public static BlendNode ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BlendNode ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BlendNode ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BlendNode ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BlendNode ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BlendNode ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BlendNode ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BlendNode ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BlendNode ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BlendNode ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BlendNode MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BlendNode prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<BlendNode, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BlendNode cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BlendNode result;
      
      private BlendNode PrepareBuilder() {
        if (resultIsReadOnly) {
          BlendNode original = result;
          result = new BlendNode();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BlendNode MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.BlendNode.Descriptor; }
      }
      
      public override BlendNode DefaultInstanceForType {
        get { return global::Protocol.BlendNode.DefaultInstance; }
      }
      
      public override BlendNode BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BlendNode) {
          return MergeFrom((BlendNode) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BlendNode other) {
        if (other == global::Protocol.BlendNode.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasMoveSpeed) {
          MoveSpeed = other.MoveSpeed;
        }
        if (other.HasAngleSpeed) {
          AngleSpeed = other.AngleSpeed;
        }
        if (other.HasXPostion) {
          XPostion = other.XPostion;
        }
        if (other.HasYPostion) {
          YPostion = other.YPostion;
        }
        if (other.HasMoveDir) {
          MergeMoveDir(other.MoveDir);
        }
        if (other.HasLength) {
          Length = other.Length;
        }
        if (other.HasIsAddtion) {
          IsAddtion = other.IsAddtion;
        }
        if (other.HasMotion) {
          MergeMotion(other.Motion);
        }
        if (other.HasBoundCenter) {
          MergeBoundCenter(other.BoundCenter);
        }
        if (other.HasBoundSize) {
          MergeBoundSize(other.BoundSize);
        }
        if (other.HasHeadPosition) {
          MergeHeadPosition(other.HeadPosition);
        }
        if (other.HasHeadRotation) {
          MergeHeadRotation(other.HeadRotation);
        }
        if (other.HasFrameCount) {
          FrameCount = other.FrameCount;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_blendNodeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _blendNodeFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasMoveSpeed = input.ReadFloat(ref result.moveSpeed_);
              break;
            }
            case 21: {
              result.hasAngleSpeed = input.ReadFloat(ref result.angleSpeed_);
              break;
            }
            case 29: {
              result.hasXPostion = input.ReadFloat(ref result.xPostion_);
              break;
            }
            case 37: {
              result.hasYPostion = input.ReadFloat(ref result.yPostion_);
              break;
            }
            case 42: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasMoveDir) {
                subBuilder.MergeFrom(MoveDir);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MoveDir = subBuilder.BuildPartial();
              break;
            }
            case 53: {
              result.hasLength = input.ReadFloat(ref result.length_);
              break;
            }
            case 56: {
              result.hasIsAddtion = input.ReadBool(ref result.isAddtion_);
              break;
            }
            case 66: {
              global::Protocol.MoveMotion.Builder subBuilder = global::Protocol.MoveMotion.CreateBuilder();
              if (result.hasMotion) {
                subBuilder.MergeFrom(Motion);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Motion = subBuilder.BuildPartial();
              break;
            }
            case 74: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasBoundCenter) {
                subBuilder.MergeFrom(BoundCenter);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BoundCenter = subBuilder.BuildPartial();
              break;
            }
            case 82: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasBoundSize) {
                subBuilder.MergeFrom(BoundSize);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              BoundSize = subBuilder.BuildPartial();
              break;
            }
            case 90: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasHeadPosition) {
                subBuilder.MergeFrom(HeadPosition);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HeadPosition = subBuilder.BuildPartial();
              break;
            }
            case 98: {
              global::Protocol.Float3.Builder subBuilder = global::Protocol.Float3.CreateBuilder();
              if (result.hasHeadRotation) {
                subBuilder.MergeFrom(HeadRotation);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HeadRotation = subBuilder.BuildPartial();
              break;
            }
            case 104: {
              result.hasFrameCount = input.ReadInt32(ref result.frameCount_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasMoveSpeed {
        get { return result.hasMoveSpeed; }
      }
      public float MoveSpeed {
        get { return result.MoveSpeed; }
        set { SetMoveSpeed(value); }
      }
      public Builder SetMoveSpeed(float value) {
        PrepareBuilder();
        result.hasMoveSpeed = true;
        result.moveSpeed_ = value;
        return this;
      }
      public Builder ClearMoveSpeed() {
        PrepareBuilder();
        result.hasMoveSpeed = false;
        result.moveSpeed_ = 0F;
        return this;
      }
      
      public bool HasAngleSpeed {
        get { return result.hasAngleSpeed; }
      }
      public float AngleSpeed {
        get { return result.AngleSpeed; }
        set { SetAngleSpeed(value); }
      }
      public Builder SetAngleSpeed(float value) {
        PrepareBuilder();
        result.hasAngleSpeed = true;
        result.angleSpeed_ = value;
        return this;
      }
      public Builder ClearAngleSpeed() {
        PrepareBuilder();
        result.hasAngleSpeed = false;
        result.angleSpeed_ = 0F;
        return this;
      }
      
      public bool HasXPostion {
        get { return result.hasXPostion; }
      }
      public float XPostion {
        get { return result.XPostion; }
        set { SetXPostion(value); }
      }
      public Builder SetXPostion(float value) {
        PrepareBuilder();
        result.hasXPostion = true;
        result.xPostion_ = value;
        return this;
      }
      public Builder ClearXPostion() {
        PrepareBuilder();
        result.hasXPostion = false;
        result.xPostion_ = 0F;
        return this;
      }
      
      public bool HasYPostion {
        get { return result.hasYPostion; }
      }
      public float YPostion {
        get { return result.YPostion; }
        set { SetYPostion(value); }
      }
      public Builder SetYPostion(float value) {
        PrepareBuilder();
        result.hasYPostion = true;
        result.yPostion_ = value;
        return this;
      }
      public Builder ClearYPostion() {
        PrepareBuilder();
        result.hasYPostion = false;
        result.yPostion_ = 0F;
        return this;
      }
      
      public bool HasMoveDir {
       get { return result.hasMoveDir; }
      }
      public global::Protocol.Float3 MoveDir {
        get { return result.MoveDir; }
        set { SetMoveDir(value); }
      }
      public Builder SetMoveDir(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMoveDir = true;
        result.moveDir_ = value;
        return this;
      }
      public Builder SetMoveDir(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMoveDir = true;
        result.moveDir_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMoveDir(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasMoveDir &&
            result.moveDir_ != global::Protocol.Float3.DefaultInstance) {
            result.moveDir_ = global::Protocol.Float3.CreateBuilder(result.moveDir_).MergeFrom(value).BuildPartial();
        } else {
          result.moveDir_ = value;
          result.hasMoveDir = true;
        }
        return this;
      }
      public Builder ClearMoveDir() {
        PrepareBuilder();
        result.hasMoveDir = false;
        result.moveDir_ = null;
        return this;
      }
      
      public bool HasLength {
        get { return result.hasLength; }
      }
      public float Length {
        get { return result.Length; }
        set { SetLength(value); }
      }
      public Builder SetLength(float value) {
        PrepareBuilder();
        result.hasLength = true;
        result.length_ = value;
        return this;
      }
      public Builder ClearLength() {
        PrepareBuilder();
        result.hasLength = false;
        result.length_ = 0F;
        return this;
      }
      
      public bool HasIsAddtion {
        get { return result.hasIsAddtion; }
      }
      public bool IsAddtion {
        get { return result.IsAddtion; }
        set { SetIsAddtion(value); }
      }
      public Builder SetIsAddtion(bool value) {
        PrepareBuilder();
        result.hasIsAddtion = true;
        result.isAddtion_ = value;
        return this;
      }
      public Builder ClearIsAddtion() {
        PrepareBuilder();
        result.hasIsAddtion = false;
        result.isAddtion_ = false;
        return this;
      }
      
      public bool HasMotion {
       get { return result.hasMotion; }
      }
      public global::Protocol.MoveMotion Motion {
        get { return result.Motion; }
        set { SetMotion(value); }
      }
      public Builder SetMotion(global::Protocol.MoveMotion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMotion = true;
        result.motion_ = value;
        return this;
      }
      public Builder SetMotion(global::Protocol.MoveMotion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMotion = true;
        result.motion_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMotion(global::Protocol.MoveMotion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasMotion &&
            result.motion_ != global::Protocol.MoveMotion.DefaultInstance) {
            result.motion_ = global::Protocol.MoveMotion.CreateBuilder(result.motion_).MergeFrom(value).BuildPartial();
        } else {
          result.motion_ = value;
          result.hasMotion = true;
        }
        return this;
      }
      public Builder ClearMotion() {
        PrepareBuilder();
        result.hasMotion = false;
        result.motion_ = null;
        return this;
      }
      
      public bool HasBoundCenter {
       get { return result.hasBoundCenter; }
      }
      public global::Protocol.Float3 BoundCenter {
        get { return result.BoundCenter; }
        set { SetBoundCenter(value); }
      }
      public Builder SetBoundCenter(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBoundCenter = true;
        result.boundCenter_ = value;
        return this;
      }
      public Builder SetBoundCenter(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBoundCenter = true;
        result.boundCenter_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBoundCenter(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasBoundCenter &&
            result.boundCenter_ != global::Protocol.Float3.DefaultInstance) {
            result.boundCenter_ = global::Protocol.Float3.CreateBuilder(result.boundCenter_).MergeFrom(value).BuildPartial();
        } else {
          result.boundCenter_ = value;
          result.hasBoundCenter = true;
        }
        return this;
      }
      public Builder ClearBoundCenter() {
        PrepareBuilder();
        result.hasBoundCenter = false;
        result.boundCenter_ = null;
        return this;
      }
      
      public bool HasBoundSize {
       get { return result.hasBoundSize; }
      }
      public global::Protocol.Float3 BoundSize {
        get { return result.BoundSize; }
        set { SetBoundSize(value); }
      }
      public Builder SetBoundSize(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBoundSize = true;
        result.boundSize_ = value;
        return this;
      }
      public Builder SetBoundSize(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBoundSize = true;
        result.boundSize_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBoundSize(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasBoundSize &&
            result.boundSize_ != global::Protocol.Float3.DefaultInstance) {
            result.boundSize_ = global::Protocol.Float3.CreateBuilder(result.boundSize_).MergeFrom(value).BuildPartial();
        } else {
          result.boundSize_ = value;
          result.hasBoundSize = true;
        }
        return this;
      }
      public Builder ClearBoundSize() {
        PrepareBuilder();
        result.hasBoundSize = false;
        result.boundSize_ = null;
        return this;
      }
      
      public bool HasHeadPosition {
       get { return result.hasHeadPosition; }
      }
      public global::Protocol.Float3 HeadPosition {
        get { return result.HeadPosition; }
        set { SetHeadPosition(value); }
      }
      public Builder SetHeadPosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadPosition = true;
        result.headPosition_ = value;
        return this;
      }
      public Builder SetHeadPosition(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeadPosition = true;
        result.headPosition_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeadPosition(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasHeadPosition &&
            result.headPosition_ != global::Protocol.Float3.DefaultInstance) {
            result.headPosition_ = global::Protocol.Float3.CreateBuilder(result.headPosition_).MergeFrom(value).BuildPartial();
        } else {
          result.headPosition_ = value;
          result.hasHeadPosition = true;
        }
        return this;
      }
      public Builder ClearHeadPosition() {
        PrepareBuilder();
        result.hasHeadPosition = false;
        result.headPosition_ = null;
        return this;
      }
      
      public bool HasHeadRotation {
       get { return result.hasHeadRotation; }
      }
      public global::Protocol.Float3 HeadRotation {
        get { return result.HeadRotation; }
        set { SetHeadRotation(value); }
      }
      public Builder SetHeadRotation(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadRotation = true;
        result.headRotation_ = value;
        return this;
      }
      public Builder SetHeadRotation(global::Protocol.Float3.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeadRotation = true;
        result.headRotation_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeadRotation(global::Protocol.Float3 value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.HasHeadRotation &&
            result.headRotation_ != global::Protocol.Float3.DefaultInstance) {
            result.headRotation_ = global::Protocol.Float3.CreateBuilder(result.headRotation_).MergeFrom(value).BuildPartial();
        } else {
          result.headRotation_ = value;
          result.hasHeadRotation = true;
        }
        return this;
      }
      public Builder ClearHeadRotation() {
        PrepareBuilder();
        result.hasHeadRotation = false;
        result.headRotation_ = null;
        return this;
      }
      
      public bool HasFrameCount {
        get { return result.hasFrameCount; }
      }
      public int FrameCount {
        get { return result.FrameCount; }
        set { SetFrameCount(value); }
      }
      public Builder SetFrameCount(int value) {
        PrepareBuilder();
        result.hasFrameCount = true;
        result.frameCount_ = value;
        return this;
      }
      public Builder ClearFrameCount() {
        PrepareBuilder();
        result.hasFrameCount = false;
        result.frameCount_ = 0;
        return this;
      }
    }
    static BlendNode() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Blender : pb::GeneratedMessage<Blender, Blender.Builder> {
    public Blender() { }
    private static readonly Blender defaultInstance = new Blender().MakeReadOnly();
    private static readonly string[] _blenderFieldNames = new string[] { "blend_type", "is_fix_angle", "length", "name", "node_list" };
    private static readonly uint[] _blenderFieldTags = new uint[] { 8, 40, 29, 34, 18 };
    public static Blender DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Blender DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Blender ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_Blender__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Blender, Blender.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_Blender__FieldAccessorTable; }
    }
    
    public const int BlendTypeFieldNumber = 1;
    private bool hasBlendType;
    private global::Protocol.BlendType blendType_ = global::Protocol.BlendType.BT_None;
    private bool isBlendTypeChanged = true;
    public bool HasBlendType {
      get { return hasBlendType; }
    }
    public global::Protocol.BlendType BlendType {
      get { return blendType_; }
      set { hasBlendType = true;
        isBlendTypeChanged = true;
        blendType_ = value;}
    }
    
    public const int NodeListFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.BlendNode> nodeList_ = new pbc::PopsicleList<global::Protocol.BlendNode>();
    public scg::IList<global::Protocol.BlendNode> NodeList {
      get { return pbc::Lists.AsReadOnly(nodeList_); }
    }
    public int NodeListCount {
      get { return nodeList_.Count; }
    }
    public global::Protocol.BlendNode GetNodeList(int index) {
      return nodeList_[index];
    }
    public global::Protocol.BlendNode FindNodeList(System.Predicate<global::Protocol.BlendNode> match) {
      return nodeList_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.BlendNode> FindAllNodeList(System.Predicate<global::Protocol.BlendNode> match) {
      return nodeList_.FindAll(match);
    }
    public void SetNodeList(int index, global::Protocol.BlendNode value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= nodeList_.Count) return;
      nodeList_[index] = value;
    }
    public void AddNodeList(global::Protocol.BlendNode value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      nodeList_.Add(value);
    }
    public void AddRangeNodeList(scg::IEnumerable<global::Protocol.BlendNode> values) {
      nodeList_.Add(values);
    }
    public void RemoveNodeList(global::Protocol.BlendNode value) {
      if (!nodeList_.Contains(value)) return;
      nodeList_.Remove(value);
    }
    public void RemoveAtNodeList(int index) {
      if (index < 0 || index >= nodeList_.Count) return;
      nodeList_.RemoveAt(index);
    }
    public void ClearNodeList() {
      if (nodeList_.Count <= 0) return;
      nodeList_.Clear();
    }
    
    public const int LengthFieldNumber = 3;
    private bool hasLength;
    private bool isLengthChanged = true;
    private float length_;
    public bool HasLength {
      get { return hasLength; }
    }
    public float Length {
      get { return length_; }
      set { hasLength = true;
        isLengthChanged = true;
        length_ = value;}
    }
    
    public const int NameFieldNumber = 4;
    private bool hasName;
    private bool isNameChanged = true;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
      set { hasName = true;
        isNameChanged = true;
        name_ = value;}
    }
    
    public const int IsFixAngleFieldNumber = 5;
    private bool hasIsFixAngle;
    private bool isIsFixAngleChanged = true;
    private bool isFixAngle_;
    public bool HasIsFixAngle {
      get { return hasIsFixAngle; }
    }
    public bool IsFixAngle {
      get { return isFixAngle_; }
      set { hasIsFixAngle = true;
        isIsFixAngleChanged = true;
        isFixAngle_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _blenderFieldNames;
      if (hasBlendType) {
        output.WriteEnum(1, field_names[0], (int) BlendType, BlendType);
      }
      if (nodeList_.Count > 0) {
        output.WriteMessageArray(2, field_names[4], nodeList_);
      }
      if (hasLength) {
        output.WriteFloat(3, field_names[2], Length);
      }
      if (hasName) {
        output.WriteString(4, field_names[3], Name);
      }
      if (hasIsFixAngle) {
        output.WriteBool(5, field_names[1], IsFixAngle);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      if (hasBlendType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) BlendType);
      }
      foreach (global::Protocol.BlendNode element in NodeList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasLength) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Length);
      }
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Name);
      }
      if (hasIsFixAngle) {
        size += pb::CodedOutputStream.ComputeBoolSize(5, IsFixAngle);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public Blender CommitChange() {
      Blender other = new Blender();
      bool isChange = false;
      if (isBlendTypeChanged) {
        isChange = true;
        other.BlendType = BlendType;
        isBlendTypeChanged = false;
      }
      isChange = true;
      other.nodeList_.Add(nodeList_);
      if (isLengthChanged) {
        isChange = true;
        other.Length = Length;
        isLengthChanged = false;
      }
      if (isNameChanged) {
        isChange = true;
        other.Name = Name;
        isNameChanged = false;
      }
      if (isIsFixAngleChanged) {
        isChange = true;
        other.IsFixAngle = IsFixAngle;
        isIsFixAngleChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(Blender other, bool isFull = false) {
      if (other == global::Protocol.Blender.DefaultInstance) return;
      if (other.HasBlendType) {
        BlendType = other.BlendType;
      }
        nodeList_.Clear();
        nodeList_.Add(other.nodeList_);
      if (other.HasLength) {
        Length = other.Length;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasIsFixAngle) {
        IsFixAngle = other.IsFixAngle;
      }
    }
    
    public static Blender ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Blender ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Blender ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Blender ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Blender ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Blender ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Blender ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Blender ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Blender ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Blender ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Blender MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Blender prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Blender, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Blender cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Blender result;
      
      private Blender PrepareBuilder() {
        if (resultIsReadOnly) {
          Blender original = result;
          result = new Blender();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Blender MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.Blender.Descriptor; }
      }
      
      public override Blender DefaultInstanceForType {
        get { return global::Protocol.Blender.DefaultInstance; }
      }
      
      public override Blender BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Blender) {
          return MergeFrom((Blender) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Blender other) {
        if (other == global::Protocol.Blender.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBlendType) {
          BlendType = other.BlendType;
        }
        if (other.nodeList_.Count != 0) {
          result.nodeList_.Add(other.nodeList_);
        }
        if (other.HasLength) {
          Length = other.Length;
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasIsFixAngle) {
          IsFixAngle = other.IsFixAngle;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_blenderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _blenderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.blendType_, out unknown)) {
                result.hasBlendType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.nodeList_, global::Protocol.BlendNode.DefaultInstance, extensionRegistry);
              break;
            }
            case 29: {
              result.hasLength = input.ReadFloat(ref result.length_);
              break;
            }
            case 34: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 40: {
              result.hasIsFixAngle = input.ReadBool(ref result.isFixAngle_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasBlendType {
       get { return result.hasBlendType; }
      }
      public global::Protocol.BlendType BlendType {
        get { return result.BlendType; }
        set { SetBlendType(value); }
      }
      public Builder SetBlendType(global::Protocol.BlendType value) {
        PrepareBuilder();
        result.hasBlendType = true;
        result.blendType_ = value;
        return this;
      }
      public Builder ClearBlendType() {
        PrepareBuilder();
        result.hasBlendType = false;
        result.blendType_ = global::Protocol.BlendType.BT_None;
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.BlendNode> NodeList {
        get { return PrepareBuilder().nodeList_; }
      }
      public int NodeListCount {
        get { return result.NodeListCount; }
      }
      public global::Protocol.BlendNode GetNodeList(int index) {
        return result.GetNodeList(index);
      }
      public Builder SetNodeList(int index, global::Protocol.BlendNode value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.nodeList_[index] = value;
        return this;
      }
      public Builder SetNodeList(int index, global::Protocol.BlendNode.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.nodeList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddNodeList(global::Protocol.BlendNode value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.nodeList_.Add(value);
        return this;
      }
      public Builder AddNodeList(global::Protocol.BlendNode.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.nodeList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeNodeList(scg::IEnumerable<global::Protocol.BlendNode> values) {
        PrepareBuilder();
        result.nodeList_.Add(values);
        return this;
      }
      public Builder ClearNodeList() {
        PrepareBuilder();
        result.nodeList_.Clear();
        return this;
      }
      
      public bool HasLength {
        get { return result.hasLength; }
      }
      public float Length {
        get { return result.Length; }
        set { SetLength(value); }
      }
      public Builder SetLength(float value) {
        PrepareBuilder();
        result.hasLength = true;
        result.length_ = value;
        return this;
      }
      public Builder ClearLength() {
        PrepareBuilder();
        result.hasLength = false;
        result.length_ = 0F;
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasIsFixAngle {
        get { return result.hasIsFixAngle; }
      }
      public bool IsFixAngle {
        get { return result.IsFixAngle; }
        set { SetIsFixAngle(value); }
      }
      public Builder SetIsFixAngle(bool value) {
        PrepareBuilder();
        result.hasIsFixAngle = true;
        result.isFixAngle_ = value;
        return this;
      }
      public Builder ClearIsFixAngle() {
        PrepareBuilder();
        result.hasIsFixAngle = false;
        result.isFixAngle_ = false;
        return this;
      }
    }
    static Blender() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MoveControllerCfg : pb::GeneratedMessage<MoveControllerCfg, MoveControllerCfg.Builder> {
    public MoveControllerCfg() { }
    private static readonly MoveControllerCfg defaultInstance = new MoveControllerCfg().MakeReadOnly();
    private static readonly string[] _moveControllerCfgFieldNames = new string[] { "bound_path_list", "export_blenders", "export_motions", "head_path", "head_size", "weapon_path" };
    private static readonly uint[] _moveControllerCfgFieldTags = new uint[] { 34, 18, 10, 42, 53, 26 };
    public static MoveControllerCfg DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveControllerCfg DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveControllerCfg ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveControllerCfg__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveControllerCfg, MoveControllerCfg.Builder> InternalFieldAccessors {
      get { return global::Protocol.ProtoEditor.internal__static_Protocol_MoveControllerCfg__FieldAccessorTable; }
    }
    
    public const int ExportMotionsFieldNumber = 1;
    private pbc::PopsicleList<global::Protocol.MoveMotion> exportMotions_ = new pbc::PopsicleList<global::Protocol.MoveMotion>();
    public scg::IList<global::Protocol.MoveMotion> ExportMotions {
      get { return pbc::Lists.AsReadOnly(exportMotions_); }
    }
    public int ExportMotionsCount {
      get { return exportMotions_.Count; }
    }
    public global::Protocol.MoveMotion GetExportMotions(int index) {
      return exportMotions_[index];
    }
    public global::Protocol.MoveMotion FindExportMotions(System.Predicate<global::Protocol.MoveMotion> match) {
      return exportMotions_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.MoveMotion> FindAllExportMotions(System.Predicate<global::Protocol.MoveMotion> match) {
      return exportMotions_.FindAll(match);
    }
    public void SetExportMotions(int index, global::Protocol.MoveMotion value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= exportMotions_.Count) return;
      exportMotions_[index] = value;
    }
    public void AddExportMotions(global::Protocol.MoveMotion value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      exportMotions_.Add(value);
    }
    public void AddRangeExportMotions(scg::IEnumerable<global::Protocol.MoveMotion> values) {
      exportMotions_.Add(values);
    }
    public void RemoveExportMotions(global::Protocol.MoveMotion value) {
      if (!exportMotions_.Contains(value)) return;
      exportMotions_.Remove(value);
    }
    public void RemoveAtExportMotions(int index) {
      if (index < 0 || index >= exportMotions_.Count) return;
      exportMotions_.RemoveAt(index);
    }
    public void ClearExportMotions() {
      if (exportMotions_.Count <= 0) return;
      exportMotions_.Clear();
    }
    
    public const int ExportBlendersFieldNumber = 2;
    private pbc::PopsicleList<global::Protocol.Blender> exportBlenders_ = new pbc::PopsicleList<global::Protocol.Blender>();
    public scg::IList<global::Protocol.Blender> ExportBlenders {
      get { return pbc::Lists.AsReadOnly(exportBlenders_); }
    }
    public int ExportBlendersCount {
      get { return exportBlenders_.Count; }
    }
    public global::Protocol.Blender GetExportBlenders(int index) {
      return exportBlenders_[index];
    }
    public global::Protocol.Blender FindExportBlenders(System.Predicate<global::Protocol.Blender> match) {
      return exportBlenders_.Find(match);
    }
    public System.Collections.Generic.IList<global::Protocol.Blender> FindAllExportBlenders(System.Predicate<global::Protocol.Blender> match) {
      return exportBlenders_.FindAll(match);
    }
    public void SetExportBlenders(int index, global::Protocol.Blender value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= exportBlenders_.Count) return;
      exportBlenders_[index] = value;
    }
    public void AddExportBlenders(global::Protocol.Blender value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      exportBlenders_.Add(value);
    }
    public void AddRangeExportBlenders(scg::IEnumerable<global::Protocol.Blender> values) {
      exportBlenders_.Add(values);
    }
    public void RemoveExportBlenders(global::Protocol.Blender value) {
      if (!exportBlenders_.Contains(value)) return;
      exportBlenders_.Remove(value);
    }
    public void RemoveAtExportBlenders(int index) {
      if (index < 0 || index >= exportBlenders_.Count) return;
      exportBlenders_.RemoveAt(index);
    }
    public void ClearExportBlenders() {
      if (exportBlenders_.Count <= 0) return;
      exportBlenders_.Clear();
    }
    
    public const int WeaponPathFieldNumber = 3;
    private bool hasWeaponPath;
    private bool isWeaponPathChanged = true;
    private string weaponPath_ = "";
    public bool HasWeaponPath {
      get { return hasWeaponPath; }
    }
    public string WeaponPath {
      get { return weaponPath_; }
      set { hasWeaponPath = true;
        isWeaponPathChanged = true;
        weaponPath_ = value;}
    }
    
    public const int BoundPathListFieldNumber = 4;
    private pbc::PopsicleList<string> boundPathList_ = new pbc::PopsicleList<string>();
    private bool isBoundPathListChanged = true;
    public scg::IList<string> BoundPathList {
      get { return pbc::Lists.AsReadOnly(boundPathList_); }
    }
    public int BoundPathListCount {
      get { return boundPathList_.Count; }
    }
    public string GetBoundPathList(int index) {
      return boundPathList_[index];
    }
    public void SetBoundPathList(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      if (index < 0 || index >= boundPathList_.Count) return;
      boundPathList_[index] = value;
      isBoundPathListChanged = true;
    }
    public void AddBoundPathList(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      boundPathList_.Add(value);
      isBoundPathListChanged = true;
    }
    public void AddRangeBoundPathList(scg::IEnumerable<string> values) {
      boundPathList_.Add(values);
      isBoundPathListChanged = true;
    }
    public void RemoveBoundPathList(string value) {
      if (!boundPathList_.Contains(value)) return;
      boundPathList_.Remove(value);
      isBoundPathListChanged = true;
    }
    public void RemoveAtBoundPathList(int index) {
      if (index < 0 || index >= boundPathList_.Count) return;
      boundPathList_.RemoveAt(index);
      isBoundPathListChanged = true;
    }
    public void ClearBoundPathList() {
      if (boundPathList_.Count <= 0) return;
      boundPathList_.Clear();
      isBoundPathListChanged = true;
    }
    
    public const int HeadPathFieldNumber = 5;
    private bool hasHeadPath;
    private bool isHeadPathChanged = true;
    private string headPath_ = "";
    public bool HasHeadPath {
      get { return hasHeadPath; }
    }
    public string HeadPath {
      get { return headPath_; }
      set { hasHeadPath = true;
        isHeadPathChanged = true;
        headPath_ = value;}
    }
    
    public const int HeadSizeFieldNumber = 6;
    private bool hasHeadSize;
    private bool isHeadSizeChanged = true;
    private float headSize_;
    public bool HasHeadSize {
      get { return hasHeadSize; }
    }
    public float HeadSize {
      get { return headSize_; }
      set { hasHeadSize = true;
        isHeadSizeChanged = true;
        headSize_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _moveControllerCfgFieldNames;
      if (exportMotions_.Count > 0) {
        output.WriteMessageArray(1, field_names[2], exportMotions_);
      }
      if (exportBlenders_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], exportBlenders_);
      }
      if (hasWeaponPath) {
        output.WriteString(3, field_names[5], WeaponPath);
      }
      if (boundPathList_.Count > 0) {
        output.WriteStringArray(4, field_names[0], boundPathList_);
      }
      if (hasHeadPath) {
        output.WriteString(5, field_names[3], HeadPath);
      }
      if (hasHeadSize) {
        output.WriteFloat(6, field_names[4], HeadSize);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = 0;
      foreach (global::Protocol.MoveMotion element in ExportMotions) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      foreach (global::Protocol.Blender element in ExportBlenders) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasWeaponPath) {
        size += pb::CodedOutputStream.ComputeStringSize(3, WeaponPath);
      }
      {
        int dataSize = 0;
        foreach (string element in BoundPathList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * boundPathList_.Count;
      }
      if (hasHeadPath) {
        size += pb::CodedOutputStream.ComputeStringSize(5, HeadPath);
      }
      if (hasHeadSize) {
        size += pb::CodedOutputStream.ComputeFloatSize(6, HeadSize);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    
    public MoveControllerCfg CommitChange() {
      MoveControllerCfg other = new MoveControllerCfg();
      bool isChange = false;
      isChange = true;
      other.exportMotions_.Add(exportMotions_);
      isChange = true;
      other.exportBlenders_.Add(exportBlenders_);
      if (isWeaponPathChanged) {
        isChange = true;
        other.WeaponPath = WeaponPath;
        isWeaponPathChanged = false;
      }
        isChange = true;
        other.boundPathList_.Add(boundPathList_);
      if (isHeadPathChanged) {
        isChange = true;
        other.HeadPath = HeadPath;
        isHeadPathChanged = false;
      }
      if (isHeadSizeChanged) {
        isChange = true;
        other.HeadSize = HeadSize;
        isHeadSizeChanged = false;
      }
      return isChange?other:null;
    }
    
    public void MergeFrom(MoveControllerCfg other, bool isFull = false) {
      if (other == global::Protocol.MoveControllerCfg.DefaultInstance) return;
        exportMotions_.Clear();
        exportMotions_.Add(other.exportMotions_);
        exportBlenders_.Clear();
        exportBlenders_.Add(other.exportBlenders_);
      if (other.HasWeaponPath) {
        WeaponPath = other.WeaponPath;
      }
      if (other.boundPathList_.Count != 0) {
        boundPathList_.Clear();
        boundPathList_.Add(other.boundPathList_);
      }
      if (other.HasHeadPath) {
        HeadPath = other.HeadPath;
      }
      if (other.HasHeadSize) {
        HeadSize = other.HeadSize;
      }
    }
    
    public static MoveControllerCfg ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveControllerCfg ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveControllerCfg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveControllerCfg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveControllerCfg MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveControllerCfg prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveControllerCfg, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveControllerCfg cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveControllerCfg result;
      
      private MoveControllerCfg PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveControllerCfg original = result;
          result = new MoveControllerCfg();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveControllerCfg MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Protocol.MoveControllerCfg.Descriptor; }
      }
      
      public override MoveControllerCfg DefaultInstanceForType {
        get { return global::Protocol.MoveControllerCfg.DefaultInstance; }
      }
      
      public override MoveControllerCfg BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveControllerCfg) {
          return MergeFrom((MoveControllerCfg) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveControllerCfg other) {
        if (other == global::Protocol.MoveControllerCfg.DefaultInstance) return this;
        PrepareBuilder();
        if (other.exportMotions_.Count != 0) {
          result.exportMotions_.Add(other.exportMotions_);
        }
        if (other.exportBlenders_.Count != 0) {
          result.exportBlenders_.Add(other.exportBlenders_);
        }
        if (other.HasWeaponPath) {
          WeaponPath = other.WeaponPath;
        }
        if (other.boundPathList_.Count != 0) {
          result.boundPathList_.Add(other.boundPathList_);
        }
        if (other.HasHeadPath) {
          HeadPath = other.HeadPath;
        }
        if (other.HasHeadSize) {
          HeadSize = other.HeadSize;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveControllerCfgFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveControllerCfgFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.exportMotions_, global::Protocol.MoveMotion.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.exportBlenders_, global::Protocol.Blender.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              result.hasWeaponPath = input.ReadString(ref result.weaponPath_);
              break;
            }
            case 34: {
              input.ReadStringArray(tag, field_name, result.boundPathList_);
              break;
            }
            case 42: {
              result.hasHeadPath = input.ReadString(ref result.headPath_);
              break;
            }
            case 53: {
              result.hasHeadSize = input.ReadFloat(ref result.headSize_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Protocol.MoveMotion> ExportMotions {
        get { return PrepareBuilder().exportMotions_; }
      }
      public int ExportMotionsCount {
        get { return result.ExportMotionsCount; }
      }
      public global::Protocol.MoveMotion GetExportMotions(int index) {
        return result.GetExportMotions(index);
      }
      public Builder SetExportMotions(int index, global::Protocol.MoveMotion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.exportMotions_[index] = value;
        return this;
      }
      public Builder SetExportMotions(int index, global::Protocol.MoveMotion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.exportMotions_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddExportMotions(global::Protocol.MoveMotion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.exportMotions_.Add(value);
        return this;
      }
      public Builder AddExportMotions(global::Protocol.MoveMotion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.exportMotions_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeExportMotions(scg::IEnumerable<global::Protocol.MoveMotion> values) {
        PrepareBuilder();
        result.exportMotions_.Add(values);
        return this;
      }
      public Builder ClearExportMotions() {
        PrepareBuilder();
        result.exportMotions_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Protocol.Blender> ExportBlenders {
        get { return PrepareBuilder().exportBlenders_; }
      }
      public int ExportBlendersCount {
        get { return result.ExportBlendersCount; }
      }
      public global::Protocol.Blender GetExportBlenders(int index) {
        return result.GetExportBlenders(index);
      }
      public Builder SetExportBlenders(int index, global::Protocol.Blender value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.exportBlenders_[index] = value;
        return this;
      }
      public Builder SetExportBlenders(int index, global::Protocol.Blender.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.exportBlenders_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddExportBlenders(global::Protocol.Blender value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.exportBlenders_.Add(value);
        return this;
      }
      public Builder AddExportBlenders(global::Protocol.Blender.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.exportBlenders_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeExportBlenders(scg::IEnumerable<global::Protocol.Blender> values) {
        PrepareBuilder();
        result.exportBlenders_.Add(values);
        return this;
      }
      public Builder ClearExportBlenders() {
        PrepareBuilder();
        result.exportBlenders_.Clear();
        return this;
      }
      
      public bool HasWeaponPath {
        get { return result.hasWeaponPath; }
      }
      public string WeaponPath {
        get { return result.WeaponPath; }
        set { SetWeaponPath(value); }
      }
      public Builder SetWeaponPath(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWeaponPath = true;
        result.weaponPath_ = value;
        return this;
      }
      public Builder ClearWeaponPath() {
        PrepareBuilder();
        result.hasWeaponPath = false;
        result.weaponPath_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<string> BoundPathList {
        get { return PrepareBuilder().boundPathList_; }
      }
      public int BoundPathListCount {
        get { return result.BoundPathListCount; }
      }
      public string GetBoundPathList(int index) {
        return result.GetBoundPathList(index);
      }
      public Builder SetBoundPathList(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.boundPathList_[index] = value;
        return this;
      }
      public Builder AddBoundPathList(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.boundPathList_.Add(value);
        return this;
      }
      public Builder AddRangeBoundPathList(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.boundPathList_.Add(values);
        return this;
      }
      public Builder ClearBoundPathList() {
        PrepareBuilder();
        result.boundPathList_.Clear();
        return this;
      }
      
      public bool HasHeadPath {
        get { return result.hasHeadPath; }
      }
      public string HeadPath {
        get { return result.HeadPath; }
        set { SetHeadPath(value); }
      }
      public Builder SetHeadPath(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeadPath = true;
        result.headPath_ = value;
        return this;
      }
      public Builder ClearHeadPath() {
        PrepareBuilder();
        result.hasHeadPath = false;
        result.headPath_ = "";
        return this;
      }
      
      public bool HasHeadSize {
        get { return result.hasHeadSize; }
      }
      public float HeadSize {
        get { return result.HeadSize; }
        set { SetHeadSize(value); }
      }
      public Builder SetHeadSize(float value) {
        PrepareBuilder();
        result.hasHeadSize = true;
        result.headSize_ = value;
        return this;
      }
      public Builder ClearHeadSize() {
        PrepareBuilder();
        result.hasHeadSize = false;
        result.headSize_ = 0F;
        return this;
      }
    }
    static MoveControllerCfg() {
      object.ReferenceEquals(global::Protocol.ProtoEditor.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
